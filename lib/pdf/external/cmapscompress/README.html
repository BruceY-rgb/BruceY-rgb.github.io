<h1 id="Quick-notes-about-binary-CMap-format-bcmap"><a href="#Quick-notes-about-binary-CMap-format-bcmap" class="headerlink" title="Quick notes about binary CMap format (bcmap)"></a>Quick notes about binary CMap format (bcmap)</h1><p>The format is designed to package some information from the CMap files located at external&#x2F;cmap. Please notice for size optimization reasons, the original information blocks can be changed (split or joined) and items in the blocks can be swapped.</p>
<p>The data stored in binary format in network byte order (big-endian).</p>
<h1 id="Data-primitives"><a href="#Data-primitives" class="headerlink" title="Data primitives"></a>Data primitives</h1><p>The following primitives used during encoding of the file:</p>
<ul>
<li>byte (B) – a byte, bits are numbered from 0 (less significant) to 7 (most significant)</li>
<li>bytes block (B[n])  – a sequence of n bytes</li>
<li>unsigned number (UN) – the number is encoded as sequence of bytes, bit 7 is flag to continue decoding the byte, bits 6-0 store number information, e.g. bytes 0x818407 will represent 16903 (0x4207). Limited to the 32 bit.</li>
<li>signed number (SN) – the number is encoded as sequence of bytes, as UN, however shall be transformed before encoding: if n &lt; 0, the n shall be encoded as (-2<em>n-1) using UN encoding, other n shall be encoded as (2</em>n) using UN encoding. So the lowest bit of the number indicates the sign of the initial number</li>
<li>unsigned fixed number (UB[n]) – similar to the UN, but it represents an unsigned number that is stored in B[n]</li>
<li>signed fixed number (SB[n]) – similar to the SN, but it represents a signed number that is stored in B[n]</li>
<li>string (S) – the string is encoded as sequence of bytes. First comes length is characters encoded as UN, when UTF16 characters encoded as UN.</li>
</ul>
<h1 id="File-structure"><a href="#File-structure" class="headerlink" title="File structure"></a>File structure</h1><p>The first byte is a header:</p>
<ul>
<li>bits 2-1 – indicate a CMapType. Valid values are 1 and 2</li>
<li>bit 0 – indicate WMode. Valid values are 0 and 1.</li>
</ul>
<p>Then records follow. The records starts from the record header encoded as B, where bits 7-5 indicate record type (see description of other bits below):</p>
<ul>
<li>0 – codespacerange</li>
<li>1 – notdefrange</li>
<li>2 – cidchar</li>
<li>3 – cidrange</li>
<li>4 – bfchar</li>
<li>5 – bfrange</li>
<li>6 – reserved</li>
<li>7 – metadata</li>
</ul>
<h2 id="Metadata-record"><a href="#Metadata-record" class="headerlink" title="Metadata record"></a>Metadata record</h2><p>The metadata record header bit 4-0 contain id of the metadata:</p>
<ul>
<li>0 – comment, body of the record is encoded comment string (S)</li>
<li>1 – UseCMap, body of the record is usecmap id string (S)</li>
</ul>
<h2 id="Data-records"><a href="#Data-records" class="headerlink" title="Data records"></a>Data records</h2><p>The records that have types 0 – 5, have the following fields in the header:</p>
<ul>
<li>bit 4 – indicate the char or start&#x2F;end entries are stored in a sequence in this block</li>
<li>bits 3-0 – contain length of the data size minus 1 in this block (dataSize)</li>
</ul>
<p>The amount of entries encoded as UN follows the header. The items records follow (see below).</p>
<h3 id="codespacerange-0"><a href="#codespacerange-0" class="headerlink" title="codespacerange (0)"></a>codespacerange (0)</h3><p>Represents the following CMap block:</p>
<p>  n begincodespacerange<br>  <start> <end><br>  endcodespacerange</p>
<p>First record format is:</p>
<ul>
<li>start as B[dataSize]</li>
<li>endDelta as UB[dataSize], end is calculated as (start + endDelta)</li>
</ul>
<p>Next record format is:</p>
<ul>
<li>startDelta as UB[dataSize], start &#x3D; end + startDelta</li>
<li>endDelta as UB[dataSize], end &#x3D; start + endDelta</li>
</ul>
<h3 id="notdefrange-1"><a href="#notdefrange-1" class="headerlink" title="notdefrange (1)"></a>notdefrange (1)</h3><p>Represents the following CMap block:</p>
<p>  n beginnotdefrange<br>  <start> <end> code<br>  endnotdefrange</p>
<p>First record format is:</p>
<ul>
<li>start as B[dataSize]</li>
<li>endDelta as UB[dataSize], end is calculated as (start + endDelta)</li>
<li>code as UN</li>
</ul>
<p>Next record format is:</p>
<ul>
<li>startDelta as UB[dataSize], start &#x3D; end + startDelta</li>
<li>endDelta as UB[dataSize], end &#x3D; start + endDelta</li>
<li>code as UN</li>
</ul>
<h3 id="cidchar-2"><a href="#cidchar-2" class="headerlink" title="cidchar (2)"></a>cidchar (2)</h3><p>Represents the following CMap block:</p>
<p>  n begincidchar<br>  <char> code<br>  endcidchar</p>
<p>First record format is:</p>
<ul>
<li>char as B[dataSize]</li>
<li>code as UN</li>
</ul>
<p>Next record format is:</p>
<ul>
<li>if sequence &#x3D; 0, charDelta as UB[dataSize], char &#x3D; char + charDelta + 1</li>
<li>if sequence &#x3D; 1, char &#x3D; char + 1</li>
<li>codeDelta as SN, code &#x3D; code + codeDelta</li>
</ul>
<h3 id="cidrange-3"><a href="#cidrange-3" class="headerlink" title="cidrange (3)"></a>cidrange (3)</h3><p>Represents the following CMap block:</p>
<p>  n begincidrange<br>  <start> <end> code<br>  endcidrange</p>
<p>First record format is:</p>
<ul>
<li>start as B[dataSize]</li>
<li>endDelta as UN[dataSize], end is calculated as (start + endDelta)</li>
<li>code as UN</li>
</ul>
<p>Next record format is:</p>
<ul>
<li>if sequence &#x3D; 0, startDelta as UB[dataSize], start &#x3D; end + startDelta + 1</li>
<li>if sequence &#x3D; 1, start &#x3D; end + 1</li>
<li>endDelta as UN[dataSize], end &#x3D; start + endDelta</li>
<li>code as UN</li>
</ul>
<h3 id="bfchar-4"><a href="#bfchar-4" class="headerlink" title="bfchar (4)"></a>bfchar (4)</h3><p>Represents the following CMap block:</p>
<p>  n beginbfchar<br>  <char> <code><br>  endbfchar</p>
<p>First record format is:</p>
<ul>
<li>char as B[ucs2Size], where ucs2Size = 2 (here and below)</li>
<li>code as B[dataSize]</li>
</ul>
<p>Next record format is:</p>
<ul>
<li>if sequence = 0, charDelta as UN[ucs2Size], char = charDelta + charDelta + 1</li>
<li>if sequence = 1, char = char + 1</li>
<li>codeDelta as SB[dataSize], code = code + codeDelta</li>
</ul>
<h3 id="bfrange-5"><a href="#bfrange-5" class="headerlink" title="bfrange (5)"></a>bfrange (5)</h3><p>Represents the following CMap block:</p>
<p>  n beginbfrange<br>  <start> <end> <code><br>  endbfrange</p>
<p>First record format is:</p>
<ul>
<li>start as B[ucs2Size]</li>
<li>endDelta as UB[ucs2Size], end is calculated as (start + endDelta)</li>
<li>code as B[dataSize]</li>
</ul>
<p>Next record format is:</p>
<ul>
<li>if sequence = 0, startDelta as UB[ucs2Size], start = end + startDelta + 1</li>
<li>if sequence = 1, start = end + 1</li>
<li>endDelta as UB[ucs2Size], end = start + endDelta</li>
<li>code as B[dataSize]</li>
</ul>
