<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据库系统 Database System | BruceYang的笔记小站</title><meta name="author" content="Bruce Yang"><meta name="copyright" content="Bruce Yang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 1: Introduction1. Database SystemsDBMS(Database Management System)  数据库定义 数据组织、存储和管理 数据操作 数据库的事务管理和运行管理 数据库的建立和维护 不同数据库之间的交互    数据库系统是一些管理互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合2. 数据库系统的目标相比于File-Pro">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库系统 Database System">
<meta property="og:url" content="http://example.com/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/index.html">
<meta property="og:site_name" content="BruceYang的笔记小站">
<meta property="og:description" content="Chapter 1: Introduction1. Database SystemsDBMS(Database Management System)  数据库定义 数据组织、存储和管理 数据操作 数据库的事务管理和运行管理 数据库的建立和维护 不同数据库之间的交互    数据库系统是一些管理互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合2. 数据库系统的目标相比于File-Pro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2025-04-06T03:27:59.000Z">
<meta property="article:modified_time" content="2025-04-07T10:35:27.474Z">
<meta property="article:author" content="Bruce Yang">
<meta property="article:tag" content="CS Software and Hardware">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据库系统 Database System",
  "url": "http://example.com/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/",
  "image": "http://example.com/img/avatar.jpg",
  "datePublished": "2025-04-06T03:27:59.000Z",
  "dateModified": "2025-04-07T10:35:27.474Z",
  "author": [
    {
      "@type": "Person",
      "name": "Bruce Yang",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据库系统 Database System',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="example1.js"></script><script src="example2.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/rss2.xml" title="BruceYang的笔记小站" type="application/rss+xml">
</head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">BruceYang的笔记小站</span></a><a class="nav-page-title" href="/"><span class="site-name">数据库系统 Database System</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">数据库系统 Database System</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-06T03:27:59.000Z" title="发表于 2025-04-06 11:27:59">2025-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-07T10:35:27.474Z" title="更新于 2025-04-07 18:35:27">2025-04-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h1><h2 id="1-Database-Systems"><a href="#1-Database-Systems" class="headerlink" title="1. Database Systems"></a>1. Database Systems</h2><p>DBMS(Database Management System)</p>
<ul>
<li>数据库定义</li>
<li>数据组织、存储和管理</li>
<li>数据操作</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护</li>
<li>不同数据库之间的交互</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-20.png" alt="alt text"></p>
<ul>
<li>数据库系统是一些管理互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合<h2 id="2-数据库系统的目标"><a href="#2-数据库系统的目标" class="headerlink" title="2. 数据库系统的目标"></a>2. 数据库系统的目标</h2>相比于File-Processing System，数据库系统可以解决下面的问题</li>
</ul>
<p><strong><em>两者一个巨大的区别是文件系统是操作系统的重要组成部分，DBMS是独立于操作系统的软件。DBMS的实现与操作系统中的文件系统是紧密相关的</em></strong></p>
<ul>
<li>数据冗余(rebundancy)和不一致性(inconsistency):相同的信息可能在不同的文件中重复存储；不同文件中的信息在修改后可能会出现不一致的现象</li>
<li>数据访问困难：对于有特定要求的数据，传统的文件管理系统需要写大量的访问应用程序保证能够按照要求访问数据。</li>
<li>数据孤立：数据分散在不同文件中，文件可能不具有相同的文件格式，编写应用程序来检索适当数据是很困难的</li>
<li>完整性问题(integrity problems):数据库中存储的数据值需要满足一些特定的约束条件(constraint)，比如银行账户余额必须非负，学生ID的位数必须相同等等。</li>
<li>原子性问题(atomicity problems):一个原子的操作要么全部发生要么根本不发生</li>
<li>并发访问异常(Concurrent access anomalies):并发的更新操作可能相互影响，有可能导致数据的不一致。eg.学生选课，教学班容量差一人，两名学生同事抢课就会存在计数异常的情况导致两名同学都可以选到这门课</li>
<li>安全性问题：数据库系统有明确的访问权限，并非每一个用户都可以访问所有数据<h2 id="3-数据库的特征"><a href="#3-数据库的特征" class="headerlink" title="3. 数据库的特征"></a>3. 数据库的特征</h2></li>
<li>数据持久性</li>
<li>数据访问便利</li>
<li>数据完整性</li>
<li>多用户并发控制</li>
<li>故障恢复</li>
<li>安全控制<h2 id="4-数据视图"><a href="#4-数据视图" class="headerlink" title="4. 数据视图"></a>4. 数据视图</h2>数据库的主要目的是给用户提供数据的抽象视图，我们对数据库进行三级的抽象。</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-21.png" alt="alt text"></p>
<ul>
<li>Physical Level:描述数据实际上是怎样存储的。物理层详细描述复杂的底层数据结构。</li>
<li>Logical Level:比物理层层次稍高的抽象，描述数据库中存储什么数据以及这些数据间存在什么联系。<ul>
<li>物理数据独立性：虽然逻辑层的简单数据结构的实现可能涉及复杂的物理层结构，但是逻辑层的用户不比意识到这样的复杂性。</li>
</ul>
</li>
<li>View Level:最高层次的抽象。只描述数据库的某个部分。尽管在逻辑层使用了相对简单的结构，但是由于一个大型数据库中所存储的信息的多样性仍存在一定程度的复杂性。但是用户不需要所有的这些信息，而只需要访问数据库的一部分。视图层抽象的存在正是为了使这些用户与系统之间的交互更加简单。<ul>
<li><strong><em>系统可以为统一数据库提供多个视图</em></strong></li>
</ul>
</li>
</ul>
<p><strong>Advantages</strong></p>
<ul>
<li>隐藏了复杂性</li>
<li>对变化的适应得到增强<ul>
<li>硬件变化(physical level)，可以通过调整逻辑关系和映射来适应新的硬件环境。</li>
<li>逻辑环境变化(logical level),可以通过视图层和logic的映射使得view尽量少变化。<h3 id="4-1-模式-schema-与实例-Instance"><a href="#4-1-模式-schema-与实例-Instance" class="headerlink" title="4.1 模式(schema)与实例(Instance)"></a>4.1 模式(schema)与实例(Instance)</h3>与编程语言中的类型和变量概念相似：</li>
</ul>
</li>
<li>模式(schema)-数据库的逻辑结构(physical/logical)</li>
<li>实例(instance)-在<strong><em>某一个特定的时间点</em></strong>数据库中的真实内容<h3 id="4-2-数据独立性-指数据和程序相互不依赖，把数据的定义从程序中分离出来"><a href="#4-2-数据独立性-指数据和程序相互不依赖，把数据的定义从程序中分离出来" class="headerlink" title="4.2 数据独立性(指数据和程序相互不依赖，把数据的定义从程序中分离出来)"></a>4.2 数据独立性(指数据和程序相互不依赖，把数据的定义从程序中分离出来)</h3></li>
</ul>
<p>DBMS负责数据的存储，从而简化应用程序</p>
<ul>
<li><strong>物理数据独立性</strong>：the ability to modify the physical schema without changing the logical schema，需要修改内模式与概念模式之间的映射关系</li>
<li><strong>逻辑数据独立性</strong>：the ability to modify the logical schema without changing the user view schema，需要修改外模式与概念模式之间的映射关系</li>
</ul>
<p>映射修改，但不用修改schema</p>
<h2 id="5-Data-Models"><a href="#5-Data-Models" class="headerlink" title="5. Data Models"></a>5. Data Models</h2><p>Data models is a collection of tools for describing data, data relationships, data semantics(数据的语义), data constraints.</p>
<ul>
<li><p>三要素</p>
<ul>
<li>数据结构 </li>
<li>数据操作 </li>
<li>数据约束条件<blockquote>
<p>模型就是对现实世界特征的抽象，数据模型是对现实世界数据特征的抽象</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Relational model(关系模型)：（表格）数据库系统层面</p>
</li>
<li>Entity-Relationship(实体-联系) data model：需求分析层面</li>
<li>Object-based data models<ul>
<li>Object-oriented (面向对象数据模型)</li>
<li>Object-relational (对象-关系模型模型)</li>
</ul>
</li>
<li>Semistructured data model (XML)(半结构化数据模型)</li>
<li>Other older models:<ul>
<li>Network model (网状模型)</li>
<li>Hierarchical model(层次模型)</li>
</ul>
</li>
</ul>
<ul>
<li>概念数据模型：按照用户的观点对数据和信息建模，是现实世界到信息世界的第一层抽象<ul>
<li>ER模型：接近于人类的思考方式，容易理解并且与计算机无关。只能说明实体之间的语义练习，不能进一步地详细说明数据结构</li>
</ul>
</li>
<li>基本数据模型：按计算机系统的关键对数据建模，，是现实数据特征的抽象<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型：用二维表格结构表达实体集以及实体集之间的联系。最大的特征就是<strong>描述的一致性</strong></li>
<li>面向对象数据模型<h2 id="6-数据库语言"><a href="#6-数据库语言" class="headerlink" title="6. 数据库语言"></a>6. 数据库语言</h2><h3 id="6-1-数据定义语言（Data-Definition-Language-DDL）"><a href="#6-1-数据定义语言（Data-Definition-Language-DDL）" class="headerlink" title="6.1 数据定义语言（Data Definition Language,DDL）"></a>6.1 数据定义语言（Data Definition Language,DDL）</h3><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-22.png" alt="alt text"><br>数据字典包含元数据(metadata)</li>
</ul>
</li>
<li>描述数据属性、结构、关系等的数据</li>
<li>DDL编译器生成一系列table templates并存储在数据字典（数据字典是一系列表，包含一系列元数据）</li>
<li>Authorization(权限)</li>
<li>Integrity constraints (完整性约束) Primary key (ID uniquely identifies instructors, 主键) Referential integrity (references constraint in SQL, 参照完整性) e.g. dept_name value in any instructor tuple must appear in department relational<h3 id="6-2-Data-Manipulation-Language-DML-数据操作语言"><a href="#6-2-Data-Manipulation-Language-DML-数据操作语言" class="headerlink" title="6.2 Data Manipulation Language (DML, 数据操作语言)"></a>6.2 Data Manipulation Language (DML, 数据操作语言)</h3></li>
<li>Procedural(过程式):用户确定需要什么数据和如何获取这些数据eg.C</li>
<li>Declarative(声明式):用户只描述需要什么数据(陈述式，非过程式nonprocedural):用户确定需要什么数据但是不需要确定如何获取这些数据eg.SQL</li>
</ul>
<h3 id="6-3-SQL-Query-Language"><a href="#6-3-SQL-Query-Language" class="headerlink" title="6.3 SQL Query Language"></a>6.3 SQL Query Language</h3><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-23.png" alt="alt text"></p>
<h3 id="6-4-Database-Access-from-Application-Program"><a href="#6-4-Database-Access-from-Application-Program" class="headerlink" title="6.4 Database Access from Application Program"></a>6.4 Database Access from Application Program</h3><ul>
<li>数据库必须由过程式语言编写</li>
<li>Application programs generally access databases through one of <strong>Language extensions to allow embedded SQL e.g. 通过预处理器，将 select 语句识别出来，翻译成 C 语言的函数调用。</strong> API (Application program interface) e.g. ODBC/JDBC which allow SQL queries to be sent to a database.<h2 id="7-数据库设计"><a href="#7-数据库设计" class="headerlink" title="7. 数据库设计"></a>7. 数据库设计</h2></li>
<li>解决的问题：如何组织这些属性到各个表中</li>
<li>实体-联系模型：Entity Relationship Model一对一/一对多/多对一/多对多</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-24.png" alt="alt text"></p>
<ul>
<li>Normalization Theory (规范化理论):Formalize what designs are bad, and test for them。将所有的属性集作为输入，生成一组关系表<blockquote>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-25.png" alt="alt text"></p>
<blockquote>
<p>这个表存在冗余, department 有重复，应该拆分为两个表（前四列和后三列）然后通过外键进行表的关联</p>
<h2 id="8-数据库引擎"><a href="#8-数据库引擎" class="headerlink" title="8. 数据库引擎"></a>8. 数据库引擎</h2><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-26.png" alt="alt text"></p>
</blockquote>
</blockquote>
</li>
<li>存储管理器</li>
<li>查询处理器</li>
<li>事务管理<blockquote>
<p>数据库系统的功能部件</p>
<h3 id="8-1-存储管理器"><a href="#8-1-存储管理器" class="headerlink" title="8.1 存储管理器"></a>8.1 存储管理器</h3></blockquote>
</li>
<li>权限及完整性管理器</li>
<li>事务管理器：保证一旦发生故障，数据库的一致性状态</li>
<li>文件管理器：管理用于表示磁盘所有信息的数据结构</li>
<li>缓冲管理器：负责将数据从磁盘放入内存，并决定哪些数据应被缓冲放入内存</li>
</ul>
<p>负责数据库中数据的<strong>存储、检索和更新</strong></p>
<ul>
<li>在数据库中存储的<strong>底层数据与应用程序</strong>以及向系统提交的查询之间提供接口的部件。</li>
<li>与文件管理器进行交互，原始数据通过系统提供的文件系统存储在磁盘上</li>
<li><p>将各种DML语句翻译为底层文件系统命令</p>
</li>
<li><p>作为数据库系统物理实现的一部分，存储管理器实现了以下几种数据结构</p>
<ul>
<li>数据文件：存储数据库自身</li>
<li>数据字典：存储关于数据库结构的元数据，特别是数据库模式</li>
<li>索引：存储关于数据库中数据的索引，提供对数据项的快速访问<h3 id="8-2-查询处理器"><a href="#8-2-查询处理器" class="headerlink" title="8.2 查询处理器"></a>8.2 查询处理器</h3>查询处理器组件包括：</li>
</ul>
</li>
<li>DDL解释器：解释DDL语句并将这些定义记录在数据字典中</li>
<li>DML解释器：将查询语言中的<strong>DML语句</strong>翻译成<strong>查询执行引擎能够理解的低级指令的执行方案</strong><ul>
<li>查询优化：从几个有相同结果的候选执行计划中选出代价最小的那个执行计划。（执行计划会根据统计数据的改变而改变）</li>
</ul>
</li>
<li>查询执行引擎(query evaluation engine)：执行由DML编译器产生的低级指令</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-27.png" alt="alt text"></p>
<h3 id="8-3-事务管理-Transaction-Management"><a href="#8-3-事务管理-Transaction-Management" class="headerlink" title="8.3 事务管理(Transaction Management)"></a>8.3 事务管理(Transaction Management)</h3><p>银行转账，A 转账到 B, A 余额减掉 B 余额加上。 要有隔离性，延迟写回</p>
<ul>
<li>事务:数据库应用中完成单一逻辑功能的操作集合。每一个事务既具有原子性又具有一致性</li>
<li>恢复管理器(Recover Manager)：当故障发生时，为保证原子性，数据库必须被恢复到该事务开始执行以前的状态。</li>
<li>并发控制器(Concurrency-control manager):控制并发事务间的相互影响，保证数据库的一致性<h2 id="9-Database-Users"><a href="#9-Database-Users" class="headerlink" title="9. Database Users"></a>9. Database Users</h2><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-29.png" alt="alt text"></li>
</ul>
<h1 id="Chapter-2-Introduction-to-Relational-Model"><a href="#Chapter-2-Introduction-to-Relational-Model" class="headerlink" title="Chapter 2:Introduction to Relational Model"></a>Chapter 2:Introduction to Relational Model</h1><blockquote>
<p>你和你的宠物狗属于relationship的概念；足球队所有的成员属于relation的概念</p>
<h2 id="1-Structure-of-Relational-Databases"><a href="#1-Structure-of-Relational-Databases" class="headerlink" title="1. Structure of Relational Databases"></a>1. Structure of Relational Databases</h2><h3 id="1-1-Concepts"><a href="#1-1-Concepts" class="headerlink" title="1.1 Concepts"></a>1.1 Concepts</h3><p>Formally, given set $D_1,D_2,…,D_n$(一系列单元素的集合).</p>
<ul>
<li>A relation r is a subset of $D_1\times D_2 \times D_n$.Thus a relation is a set of n-tuple $(a_1,a_2,…a_n)$ where each $a_i\in D_i$</li>
</ul>
</blockquote>
<ul>
<li>$A_1,A_2,…,A_n$都是attributes(属性)。$R=(A_1,A_2,…,A_n)$是一个关系模型</li>
<li>关系实例r根据关系实例定义为r(R)</li>
<li>因为关系是一个集合，所以关系都是无序的</li>
<li>关系中的元组不存在重复的情况</li>
<li>属性的值是原子的<h3 id="1-2-Attributes"><a href="#1-2-Attributes" class="headerlink" title="1.2 Attributes"></a>1.2 Attributes</h3></li>
<li>The set of allowed values for each attribute is called the domain (域)of the attribute</li>
<li>Attribute values are (normally) required to be atomic (原子的); that is, indivisible<ul>
<li>Strictly indivisible example:存储姓名时将姓和名分开。如果不需要查询姓和名可以将姓名作为一个属性，名字这个属性就是不可拆分的整体</li>
<li>Non-atomic example:两个电话号码存储在了一个属性中；一本书的所有信息存储在一个属性中</li>
</ul>
</li>
<li>The special value null (空值) is a member of every domain.<ul>
<li>不存在的信息</li>
<li>存在但是未知的信息</li>
</ul>
</li>
</ul>
<h2 id="2-Database-Schema"><a href="#2-Database-Schema" class="headerlink" title="2. Database Schema"></a>2. Database Schema</h2><ul>
<li>Bad design:把所有信息储存在一个属性中<ul>
<li>信息的重复(如两名同学有相同的导师)导致了不一致和信息冗余</li>
<li>空值的需求(一个学生没有导师)，需要额外处理</li>
</ul>
</li>
<li>Database schema:is the logical structure of the database.-抽象的定义，database中所有的schema</li>
<li>Database instance:is a snapshot of the data in the database at a given instant in time.-具体的实例，database中所有的instance<blockquote>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-30.png" alt="alt text"></p>
<h2 id="3-Keys"><a href="#3-Keys" class="headerlink" title="3. Keys"></a>3. Keys</h2><p>Let $K \subseteq R$</p>
</blockquote>
</li>
<li>K is a superkey (超键) of R if values for K are sufficient to identify (唯一确定) a unique tuple of each possible relation r(R)<ul>
<li>可以唯一确定一行，但是可能会存在冗余的属性</li>
<li>e.g.{ID}和{ID,name}都是superkey</li>
</ul>
</li>
<li>Superkey K is a candidate key (候选键) if K is minimal.<ul>
<li>K可以确定唯一一行且没有冗余属性.也就是K没有子集可以是超键</li>
<li>候选键可以由多个元素组成</li>
</ul>
</li>
<li>侯选建中的一个可以给选作primary key（主键）<ul>
<li>选择的主键往往是相对稳定的</li>
<li>往往手动确定</li>
</ul>
</li>
<li><p>Foreign key（外键）限制：关系r1引用的主键必须在关系r2中出现。类似于指针</p>
<ul>
<li>引入的意义：实现完整性约束</li>
<li>Referenced Relation是被引用的表（被引用的属性往往都是primary key），Referencing是外键所在的表</li>
<li>为什么需要外键限制：数据库是支持由完整约束条件定义出来的，并维护完整性约束条件。则当我们定义外键后，上述例子中黄色条目是不会出现的。</li>
<li><p>外码的值可以是空值：避免在数据不完整时插入无效的外码值<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-31.png" alt="alt text"></p>
<p>Referential Integrity(参照完整性)：类似于外键限制，但是不限制于主键</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-33.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-32.png" alt="alt text"></p>
<ul>
<li>course 指课程信息，无论是否开课，都会有其定义。</li>
<li>section 表示教学班，真正开课时就有相应的实例。（类比于高铁的列车号，和每天对应的班次）</li>
<li>teachers 具体教哪个教学班的老师</li>
<li>takes 表示学生注册课程</li>
<li>time_slot 表示一门课的具体上课时间段，如数据库在周一 3, 4, 5 节; 周一 7, 8 节。</li>
<li>上图中红线表示引用完整性的约束；黑线表示外键约束。<h2 id="4-Relational-Algebra"><a href="#4-Relational-Algebra" class="headerlink" title="4. Relational Algebra"></a>4. Relational Algebra</h2></li>
</ul>
<blockquote>
<p>关系运算最基本的特点就是操作的对象和操作结果都是集合</p>
</blockquote>
<p>是一种过程语言，但不是编程语言</p>
<p>Input and output are all relations</p>
<p>Six basic operators</p>
<ul>
<li>For one relation:<ul>
<li>select:$\sigma$</li>
<li>project:$\Pi$</li>
<li>rename:$\rho$</li>
</ul>
</li>
<li>For two relations:<ul>
<li>union:$\cup$</li>
<li>Cartesian product:$\times$</li>
<li>difference:$-$</li>
</ul>
</li>
</ul>
<h3 id="4-1-Select"><a href="#4-1-Select" class="headerlink" title="4.1 Select"></a>4.1 Select</h3><ul>
<li>在表中找符合条件的tuple然后返回一张表<br>$σ_p(r)= \{t∣t∈r and p(t)\}$,p被称为selection predicate<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-34.png" alt="alt text"></li>
</ul>
<h3 id="4-2-Project"><a href="#4-2-Project" class="headerlink" title="4.2 Project"></a>4.2 Project</h3><p>The project operation is a unary operation that returns its argument relation, with certain attributes left out.</p>
<ul>
<li>目的：隐藏某些属性<br>$∏_{A_1,A_2,…,A_ k}(r)$ 其中$A_i$是属性的名称，r是关系的名字</li>
</ul>
<p>The result is defined as the relation of k columns obtained by erasing the columns that are not listed. 会对结果进行去重。<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-35.png" alt="alt text"></p>
<h3 id="4-3-Union"><a href="#4-3-Union" class="headerlink" title="4.3 Union"></a>4.3 Union</h3><p>The union operation allows us to combine two relations.</p>
<p>$r \cup s= \{ t|t\in r or t \in s \}$</p>
<ul>
<li>r and s must have the same arity (元数) (same number f attributes)</li>
<li>The attribute domains must be compatible</li>
<li>使用条件：等目（拥有的attribute数量一致）同源（attribute的值域相同）<blockquote>
<p>eg.Find all customers with either an account or a loan:两张表中的属性不可能完全相同，所以要先进行投影操作<br>当属性有关联类型时，对于每个输入i, 两个输入关系的第i个属性的类型必须相同。<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-36.png" alt="alt text"></p>
</blockquote>
</li>
</ul>
<h3 id="4-4-Set-Difference"><a href="#4-4-Set-Difference" class="headerlink" title="4.4 Set Difference"></a>4.4 Set Difference</h3><p>The set-difference operation allows us to find tuples that are in one relation but are not in another.<br>$r-s=\{t|t\in r and t\notin s\}$</p>
<p>Set differences must be taken between compatible relations.</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-37.png" alt="alt text"></p>
<h3 id="4-5-Cartesian-Product"><a href="#4-5-Cartesian-Product" class="headerlink" title="4.5 Cartesian Product"></a>4.5 Cartesian Product</h3><p>The Cartesian-product operation (denoted by ×) allows us to combine information from any two relations.<br>$r \times s= \{ (t,u)|t\in r and u\in s \}$</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-38.png" alt="alt text"></p>
<ul>
<li>笛卡尔积操作没有任何限制</li>
<li>如果进行笛卡尔积的两个relation中有名字相同的属性，我们也要将他们视为不同的属性进行操作。<h3 id="4-6-Rename"><a href="#4-6-Rename" class="headerlink" title="4.6 Rename"></a>4.6 Rename</h3>Allows us to refer to a relation by more than one name.</li>
<li><p>往往是在产生临时表的过程中产生的操作<br>$\rho_x (E)$ 表达式E的名称为x<br>$\rho_{x(A_1,A_2,…,A_n)} (E)$返回表达式E的名称为x，同时将属性重新命名为$A_1,A_2,…,A_n$</p>
</li>
<li><p>Composition of Operations 1:Find the names of all instructors in the Physics department, along with the course_id of all courses they have taught.<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-40.png" alt="alt text"></p>
<blockquote>
<p>两条语句语义是相同的，但第二种先select，笛卡尔积操作代价小，更高效<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-41.png" alt="alt text"></p>
<h3 id="4-7-Additional-Operators"><a href="#4-7-Additional-Operators" class="headerlink" title="4.7 Additional Operators"></a>4.7 Additional Operators</h3></blockquote>
</li>
<li>set intersection:$r \cap s$</li>
<li>natural join:$r \bowtie s$</li>
<li>assignment:$r \leftarrow s$</li>
<li>outer join:$r \rtimes s$,$r \ltimes s$,$r⟗s$</li>
<li>division operator:$r \div s$<h4 id="4-7-1-set-intersection-operation"><a href="#4-7-1-set-intersection-operation" class="headerlink" title="4.7.1 set-intersection operation"></a>4.7.1 set-intersection operation</h4></li>
<li>Notation:$r \cap s$</li>
<li>Defined as:$r \cap s= \{ t|t\in r and t\in s \}$</li>
<li>r和s有相同的arity</li>
<li>r和s的属性是兼容的，也就是值域是相同的</li>
<li>等目同源-与union操作的限制条件是相同的</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-42.png" alt="alt text"></p>
<h4 id="4-7-2-Natural-Join-Operation"><a href="#4-7-2-Natural-Join-Operation" class="headerlink" title="4.7.2 Natural Join Operation"></a>4.7.2 Natural Join Operation</h4><ul>
<li>Notation:$r \bowtie s$</li>
<li>Example:R=(A,B,C,D),S=(B,D,E)<ul>
<li>natural join 得到的 result schema是(A,B,C,D,E)</li>
<li>$r \bowtie s= \Pi_{r.A,r.B,r.C,r.D,s.E}(\sigma_{r.B=s.B ∧ r.D=s.D}(r \times s))$</li>
</ul>
</li>
</ul>
<p>Let r and s be relations on schemas R and S respectively. Then, $r \bowtie s$<br> is a relation on schema $R \cup S$<br> obtained as follows:</p>
<ul>
<li>Consider each pair of tuples $t_r$ from r and $t_s$ from s</li>
<li>如果$t_r$和$t_s$在$R \cap S$中每一个相同的属性都有相同的值，在结果relation中加上这样的元组<ul>
<li>t有与r中的$t_r$相同的值</li>
<li>t有与s中的$t_s$相同的值<blockquote>
<p>对乘法的扩展，相当于先做笛卡尔积<br>再 select, 最后 project.</p>
<ul>
<li>使用条件：</li>
</ul>
</blockquote>
</li>
<li>r，s必须有共同属性(名和域都对应相同)</li>
<li>连接两个关系中同名属性值相等的元组</li>
<li>结果属性是二者属性集的并集，但<strong>消去重名属性</strong></li>
</ul>
</li>
</ul>
<h4 id="Theta-Join-Operation-Formalization"><a href="#Theta-Join-Operation-Formalization" class="headerlink" title="Theta Join Operation Formalization"></a>Theta Join Operation Formalization</h4><ul>
<li>Notation:$r \bowtie_{\theta} s$<ul>
<li>$\theta$是模式中对于属性的predicate</li>
<li>Theta Join:$r \bowtie_{\theta}(r \times s)$</li>
</ul>
</li>
<li>Theta Join is the extension to the Natural Join</li>
</ul>
<h4 id="4-7-3-Division-Operation"><a href="#4-7-3-Division-Operation" class="headerlink" title="4.7.3 Division Operation"></a>4.7.3 Division Operation</h4><p>题目中要找<code>all</code>就要使用division operation</p>
<ul>
<li>Notation:$r \div s$</li>
<li>认为r和s分别是模式R和S下的关系，其中$R=(A_1,…,A_m,B_1,…,B_n),S=(B_1,…B_n)$<ul>
<li>result relation的模式是$R-S=(A_1,A_2,…,A_n)$</li>
<li>$r \div s = \{t|t \in \Pi_{R-S}(r)∧ \forall u \in s(t \times u \in r)\}$</li>
</ul>
</li>
<li>商来自于$\Pi_{R-S}$，并且其元组t与s所有元组的拼接被r覆盖（是r的一个子集）<script type="math/tex; mode=display">
\begin{align*}
  temp1 & \leftarrow \Pi_{R-S}(r)\\
  temp2 & \leftarrow \Pi_{R-S}((temp1 \times s)- \Pi_{R-S,S}(r))\\
  result & = temp1 - temp2
\end{align*}</script></li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-45.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-46.png" alt="alt text"></p>
<h4 id="4-7-4-Assignment-Operation"><a href="#4-7-4-Assignment-Operation" class="headerlink" title="4.7.4 Assignment Operation"></a>4.7.4 Assignment Operation</h4><p>The assignment operation &lt;- provides a convenient way to express complex queries.</p>
<ul>
<li>将查询表达式写成一系列包含下列内容的程序<ul>
<li>A series of assignments</li>
<li>Followed by an expression whose value is displayed as a result of the query</li>
</ul>
</li>
<li>assignment的结果是一个临时表<h3 id="4-8-操作符的优先级"><a href="#4-8-操作符的优先级" class="headerlink" title="4.8 操作符的优先级"></a>4.8 操作符的优先级</h3></li>
<li>Project</li>
<li>Select</li>
<li>Cartesian product</li>
<li>Join,division</li>
<li>Intersection</li>
<li>Union,difference<h3 id="4-9-Extended-Relational-Algebra-Operations"><a href="#4-9-Extended-Relational-Algebra-Operations" class="headerlink" title="4.9 Extended Relational-Algebra Operations"></a>4.9 Extended Relational-Algebra Operations</h3></li>
<li>Generalized Projection</li>
<li>Aggregate Functions</li>
<li>Outer Join<h4 id="4-9-1-Aggregate-Functions"><a href="#4-9-1-Aggregate-Functions" class="headerlink" title="4.9.1 Aggregate Functions"></a>4.9.1 Aggregate Functions</h4>Aggregation function（聚合函数）takes a collection of values and returns a single value as a result.</li>
<li>avg: average value</li>
<li>min: minimum value</li>
<li>max: maximum value</li>
<li>sum: sum of values</li>
<li><p>count: number of values</p>
</li>
<li><p>聚合函数会接受一组值，返回单个值</p>
</li>
</ul>
<p>Aggregate operation in relational algebra: $G_1,G_2,\ldots,G_n \mathcal{G}_{F_1(A_1),\ldots F_n(A_n)}(E)$</p>
<ul>
<li>E是任意一个关系代数表达式</li>
<li>$G_1,…$是分组的属性清单，对同一组是具有相同value的tuple，对每一组进行对应的聚合函数操作</li>
<li>$F_i$是聚合函数</li>
<li>$A_i$是属性的名称</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-43.png" alt="alt text"></p>
<ul>
<li><p>聚合的结果是没有名称的</p>
<ul>
<li>可以使用重命名操作进行命名</li>
<li>为了方便我们提供了<code>as</code>语句作为聚合操作的一部分从而进行重命名<script type="math/tex; mode=display">
branch-name \mathcal{G}_{sum(balance) as sum-balance}(account)</script><h4 id="4-9-2-Outer-Join"><a href="#4-9-2-Outer-Join" class="headerlink" title="4.9.2 Outer Join"></a>4.9.2 Outer Join</h4>Natural Join操作会造成一部分数据的丢失，这时我们对natural join进行扩展操作可以有效避免信息的丢失</li>
</ul>
</li>
<li><p>计算出自然连接，然后加上某一个关系中没有在另一个关系中匹配的元组加入自然连接的结果</p>
<ul>
<li>一些属性存在空值情况，我们使用<code>null</code>作为value的值</li>
</ul>
</li>
<li>$r\rtimes s$ 保留r关系中的元组</li>
<li>$r\ltimes s$ 保留s关系中的元组</li>
<li>$r⟗s$ </li>
</ul>
<h4 id="4-9-3-Null-values"><a href="#4-9-3-Null-values" class="headerlink" title="4.9.3 Null values"></a>4.9.3 Null values</h4><ul>
<li>null值可以是一个未知的值或者是不存在的值</li>
<li>一切包含null的算数表达式的结果一定是null</li>
<li>聚合函数计算时忽略null值(除了count以外，count时null被视为一个正常值)</li>
<li>对于去重删除和分组操作时，null被视作与正常值一样的值，两个null被看做相等的值</li>
<li>比较时引入除了<code>true</code>和<code>false</code>以外的第三个值<code>unknown</code></li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-44.png" alt="alt text"></p>
<ul>
<li><p>P is unknown可以作为谓词，对应值上是unknown时返回true</p>
</li>
<li><p>完整性约束</p>
<ul>
<li>实体完整性（Entity Integrity）：数据库中的每个表都必须有一个主键且主键不能为NULL</li>
<li>参照完整性(Referential Integrity)：外键的值必须是空值或者被引用表中主键的有效值</li>
<li>用户定义完整性（User defined Integrity）：根据具体业务需求定义的约束条件,由应用的环境决定<br>、<h1 id="Chapter-3-Introduction-to-SQL"><a href="#Chapter-3-Introduction-to-SQL" class="headerlink" title="Chapter 3 Introduction to SQL"></a>Chapter 3 Introduction to SQL</h1><h2 id="1-Data-Definition"><a href="#1-Data-Definition" class="headerlink" title="1 Data Definition"></a>1 Data Definition</h2><h3 id="1-1-Domain-Types-in-SQL"><a href="#1-1-Domain-Types-in-SQL" class="headerlink" title="1.1 Domain Types in SQL"></a>1.1 Domain Types in SQL</h3></li>
</ul>
</li>
<li><code>char(n)</code>.Fixed length character string, with user-specified length n.</li>
</ul>
<p>定长字符串，C语言里字符串结尾有<code>\0</code>，但是数据库中没有，长度由定义而得</p>
<ul>
<li><code>varchar(n)</code>.Variable length character string, with user-specified <code>maximum</code> length n.</li>
</ul>
<p>不定长字符串(可变长字符串)。不同的数据类型比较可能有问题(比如定长和不定长的字符串)</p>
<ul>
<li><p><code>int</code>.Integer (a finite subset of the integers that is machine-dependent).</p>
</li>
<li><p><code>smallint</code>Small integer (a machine-dependent subset of the integer domain type).</p>
</li>
</ul>
<p>往往是int长度的一半</p>
<ul>
<li><code>numeric(p,d)</code>. Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point.<br>p 表示有效数字位数, d 表示小数点后多少位。 e.g. number(3,1) allows 44.5 to be store exactly, but neither 444.5 or 0.32</li>
<li><code>real</code>, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision.</li>
<li><code>float(n)</code>. Floating point number, with user-specified precision of at least n digits.</li>
</ul>
<h3 id="1-2-Built-in-Data-Types-in-SQL"><a href="#1-2-Built-in-Data-Types-in-SQL" class="headerlink" title="1.2 Built-in Data Types in SQL"></a>1.2 Built-in Data Types in SQL</h3><ul>
<li>date: Dates, containing a (4 digit) year, month and date</li>
</ul>
<p>e.g. date ‘2005-7-27’</p>
<ul>
<li>time: Time of day, in hours, minutes and seconds. e.g. time ‘09:00:30’ time ‘09:00:30.75’</li>
<li>timestamp: date plus time of day e.g. timestamp ‘2005-7-27 09:00:30.75’</li>
<li>interval: period of time e.g. interval ‘1’ day<ul>
<li>Subtracting a date/time/timestamp value from another gives an interval value.</li>
<li>Interval values can be added to date/time/timestamp values</li>
<li>built-in date, time functions: current_date(), current_time(), year(x), month(x), day(x), hour(x), minute(x), second(x)</li>
</ul>
</li>
</ul>
<h3 id="1-3-Create-Table-Consrtuct"><a href="#1-3-Create-Table-Consrtuct" class="headerlink" title="1.3 Create Table Consrtuct"></a>1.3 Create Table Consrtuct</h3><p>An SQL relation is defined using the create table command:</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> r (A1 D1, A2 D2, ..., An Dn,           (integrity<span class="operator">-</span>constraint1),            </span><br><span class="line">..,         </span><br><span class="line">(integrity<span class="operator">-</span>constraintk))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>r is the name of the relation</li>
<li>each $A_i$ is an attribute name in the schema of relation r</li>
<li>$D_i$ is the data type of values in the domain of attribute $D_i$</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> instructor(</span><br><span class="line">    ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>) </span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>not null</code></li>
<li>primary key $(A_1,…,A_n)$</li>
</ul>
<p>不能为空：表内不能有相同的</p>
<ul>
<li>foreign key $(A_1,…,A_n)$ references r</li>
</ul>
<p>隐含：引用对应表的主键，外键是空值就是没有连接到任何值</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-47.png" alt="alt text"></p>
<p>可以给一个缺省值，比如<code>default 0</code></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-48.png" alt="alt text"></p>
<p><code>sec_id</code> can not be dropped from primary key above, to ensure a student cannot be registered for two sections of the same course in the same semester</p>
<p>如果引用的表中有条目被删除，可能会破坏完整性约束条件。有下面的方法：</p>
<ul>
<li><code>restrict</code>:如果有条目是被引用的，那么不允许被删除</li>
<li><code>cascade</code>:引用的条目被删了之后，引用者也一并被删除</li>
<li><code>set null</code>:引用者的指针设为null</li>
<li><code>set default</code>:引用者的指针设为默认值</li>
</ul>
<p>如果引用的表中有更新，也有类似上面的四种方法</p>
<h3 id="1-4-Drop-and-Alter-Table-Constructs"><a href="#1-4-Drop-and-Alter-Table-Constructs" class="headerlink" title="1.4 Drop and Alter Table Constructs"></a>1.4 Drop and Alter Table Constructs</h3><ul>
<li>drop:将表和内容同时删除</li>
<li>delete：删除表中的所有内容，但是始终保留表结构</li>
<li>alter table：可以动态修改表的定义<ul>
<li><code>alter table r add A D</code><ul>
<li>A是被添加到表中的属性名</li>
<li>D是A的domain</li>
<li>所有关系中的元组的新属性都被置为空值</li>
<li>还可以增加外键的约束条件，也可以删掉<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> Employees <span class="keyword">add</span> Email <span class="type">varchar</span>(<span class="number">50</span>)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><code>alter table r drop A</code><ul>
<li>A是r表中的一个属性</li>
<li>drop操作在很多数据库系统中是被禁用的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Basic-Query-Structure"><a href="#2-Basic-Query-Structure" class="headerlink" title="2 Basic Query Structure"></a>2 Basic Query Structure</h2><p>typical SQL query structure:</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> R1, ..., Rm</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>SQL查询的结果是一个relation</li>
<li>SQL查询的结果是多重集，有重复的记录是允许的<h3 id="2-1-The-select-Clause"><a href="#2-1-The-select-Clause" class="headerlink" title="2.1 The select Clause"></a>2.1 The select Clause</h3></li>
</ul>
<p>The select clause list the attributes desired in the result of a query.</p>
<ul>
<li>为了强制消除掉重复元素，在select的后面加上关键词<code>distinct</code></li>
</ul>
<blockquote>
<p>eg <code>select distinct dept_name from instructor</code>可以加all表示不去重，加不加无所谓</p>
</blockquote>
<ul>
<li><p>An asterisk in the select clause denotes “all attributes”<br>e.g. select * from instructor</p>
</li>
<li><p>The select clause can contain arithmetic expressions involving the operation,$+, -, \times<br>, and \div$, and operating on constants or attributes of tuples.<br>可以有加减乘除运算 e.g. select ID, name, salary/12 from instructor</p>
<blockquote>
<p>泛化投影,即可以在投影属性中引入运算</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-The-where-clause"><a href="#2-2-The-where-clause" class="headerlink" title="2.2 The where clause"></a>2.2 The where clause</h3><p>The where clause specifies conditions that the result must satisfy.<br>Corresponds to the selection predicate of the relational algebra.</p>
<ul>
<li>SQL includes a between comparison operator e.g. select name from instructor where salary between 90000 and 100000</li>
<li>tuple comparison 元组相等等价于各个元素相等</li>
</ul>
<h3 id="2-3-The-from-clause"><a href="#2-3-The-from-clause" class="headerlink" title="2.3 The from clause"></a>2.3 The from clause</h3><p>The from clause lists the relations involved in the query.</p>
<p>Corresponds to the Cartesian product operation of the relational algebra.</p>
<h3 id="2-4-Natural-Join"><a href="#2-4-Natural-Join" class="headerlink" title="2.4 Natural Join"></a>2.4 Natural Join</h3><ul>
<li><p><code>select name, course_id from instructor, teaches where instructor.ID = teaches.ID;</code><br><code>select name, course_id from instructor natural join teaches;</code><br>上面两条语句是等价的。</p>
</li>
<li><p>注意：自然连接的问题是如果两个表有相同的属性名但是有不同的含义不能使用自然连接，否则会造成内容的缺省</p>
</li>
</ul>
<blockquote>
<p>Example:course(course_id,title, dept_name,credits）, teaches(ID, course_id,sec_id,semester, year), instructor(ID, name, dept_name,salary） 这里的 department 含义各有不同，不能直接自然连接。<br>教师所在的学院不一定与课程所在的学院相同<br>可以人为规定连接的属性，对应于$\sigma_{\theta}$<br>Find students who takes courses across his/her department.</p>
</blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> student.id</span><br><span class="line">    <span class="keyword">from</span> (student <span class="keyword">natural</span> <span class="keyword">join</span> takes) </span><br><span class="line">           <span class="keyword">join</span> course <span class="keyword">using</span> (course_id)</span><br><span class="line">    <span class="keyword">where</span> student.dept_name <span class="operator">=</span> course.dept_name</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-5-The-Rename-Operation"><a href="#2-5-The-Rename-Operation" class="headerlink" title="2.5 The Rename Operation"></a>2.5 The Rename Operation</h3><p>The SQL allows renaming relations and attributes using the <code>as</code> clause.</p>
<p><code>old_name as new_name</code></p>
<p><strong>eg</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary<span class="operator">&gt;</span>S.salary <span class="keyword">and</span> S.dept_name<span class="operator">=</span><span class="string">'Comp.Sci'</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>Keyword as is optional and may be omitted</p>
<blockquote>
<p>eg.<code>instructor as T</code>与<code>instructor T</code>是完全等价的</p>
</blockquote>
</li>
<li><p>使用aggregate function和表的自身比较时往往需要使用重命名操作</p>
<h3 id="2-6-String-Operations"><a href="#2-6-String-Operations" class="headerlink" title="2.6 String Operations"></a>2.6 String Operations</h3></li>
</ul>
<p>SQL includes a string-matching operator for comparisons on character strings. The operator <code>like</code> uses patterns that are described using two special characters.</p>
<ul>
<li><p>注意单引号表示字符串</p>
</li>
<li><p>percent(%):The % character matches any substring.</p>
<blockquote>
<p>eg. <code>select name from instructor where name like '%dar%'</code>找名字里含有<code>dar</code>的字符串</p>
</blockquote>
</li>
<li><p>underscore(_):The _ character matches any character.</p>
<blockquote>
<p>eg. <code>select name from instructor where name like '_ar%'</code>找名字里第二个字母是<code>ar</code>的字符串</p>
</blockquote>
</li>
<li><p>‘—-‘matches any string of exactly three characters</p>
</li>
<li><p>‘—-%’matches any string of at least three characters.</p>
</li>
<li><p>Match the string </p>
<ul>
<li>匹配字符串<code>100%</code>但是<code>%</code>符号被我们作为了通配符，这里我们需要用到转义符<code>\</code>.<code>\%</code>即将<code>%</code>作为正常字符匹配</li>
<li><code>\</code>也可以是一个基本符号，我们需要在后面写出<code>escape</code>表示其在这里作为转义符。类似地我们还可以将转义字符定义为<code>#</code></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">like</span> `<span class="number">100</span> \<span class="operator">%</span><span class="string">'  escape  '</span>\<span class="string">' </span></span><br><span class="line"><span class="string">like `100 \%'</span>  </span><br><span class="line"><span class="keyword">like</span> `<span class="number">100</span>  #<span class="operator">%</span><span class="string">'  escape  `#'</span> </span><br></pre></td></tr></tbody></table></figure>
<p>SQL supports a variety of string operations such as</p>
<ul>
<li><p>concatenation(using ||)</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'客户名='</span><span class="operator">||</span> customer.name</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>原本name这个属性对应的值显示为客户名=name</p>
</blockquote>
</li>
<li><p>converting from upper to lower case(and vie versa)</p>
</li>
<li><p>finding string length,extracting substrings</p>
</li>
</ul>
<h3 id="2-7-Ordering-the-Display-of-Tuples"><a href="#2-7-Ordering-the-Display-of-Tuples" class="headerlink" title="2.7 Ordering the Display of Tuples"></a>2.7 Ordering the Display of Tuples</h3><p>关系是无序的，但是我们可以规定显示出来的顺序</p>
<ul>
<li>对于某一个属性，我们定义降序为<code>desc</code>，升序为<code>asc</code><blockquote>
<p>eg.<code>order by name desc</code>可以排序的类型，如字符串、数字</p>
</blockquote>
</li>
<li>可以对多个属性进行排序<blockquote>
<p>eg. <code>order by dept_name,name</code>先按dept_name排序，如果该属性相同再按照name排序</p>
</blockquote>
</li>
</ul>
<h3 id="2-8-The-limit-Clause"><a href="#2-8-The-limit-Clause" class="headerlink" title="2.8 The limit Clause"></a>2.8 The <code>limit</code> Clause</h3><p>The <code>limit</code> clause can be used to constrain the number of rowa returned by the select statement.</p>
<p>limit clause takes one or two numeric arguments,which must both be nonnegative integer constants:</p>
<blockquote>
<p>eg. <code>select name from instructor limit 2</code>限制最多返回两行</p>
</blockquote>
<h3 id="2-9-Set-Operations"><a href="#2-9-Set-Operations" class="headerlink" title="2.9 Set Operations"></a>2.9 Set Operations</h3><ul>
<li><p><code>union</code>,<code>intersect</code>,<code>except</code>是严格的集合操作，会对结果去重</p>
</li>
<li><p><code>union all</code>,<code>intersect all</code>,<code>except all</code>保持多重集可以存在重复的记录</p>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-49.png" alt="alt text"></p>
<h3 id="2-10-Null-Values"><a href="#2-10-Null-Values" class="headerlink" title="2.10 Null Values"></a>2.10 Null Values</h3><p>null提供的是一个存在但是未知的值或不存在的值</p>
<ul>
<li><p>The result of any arithmetic expression involving null is null.<br>e.g. 5 + null returns null</p>
</li>
<li><p>The predicate is null can be used to check for null values.<br>e.g. Find all instructors whose salary is null.<br>select name from instructor where salary is null</p>
</li>
<li><p>Comparisons with null values return the special truth value: unknown.</p>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-50.png" alt="alt text"></p>
<ul>
<li>如果where子句中结果为unknown被当做false处理。理解UNKNOWN被当作FALSE处理有助于编写更精确的查询，避免意外地排除或包含某些数据。</li>
</ul>
<h3 id="2-11-Aggregate-Functions"><a href="#2-11-Aggregate-Functions" class="headerlink" title="2.11 Aggregate Functions"></a>2.11 Aggregate Functions</h3><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-51.png" alt="alt text"></p>
<p>注意在<code>select</code>里出现的属性，除了统计函数以外，一定要是分组属性里面出现过的</p>
<h4 id="2-11-1-Having-Clause"><a href="#2-11-1-Having-Clause" class="headerlink" title="2.11.1 Having Clause"></a>2.11.1 Having Clause</h4><p>对分组后的组进行筛选</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">count</span> (<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span>  salary <span class="operator">&gt;=</span><span class="number">100000</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span>  <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cnt;</span><br></pre></td></tr></tbody></table></figure>
<p>having clause中的谓词在分组完成之后应用，而where子句中的谓词在组形成前应用</p>
<ul>
<li>having子句是对aggregate function的约束</li>
<li>如果group语句中存在多个属性，则需要将多个属性按照出现的顺序形成一个组合值，然后进行分组。只有当所有属性的值完全相同时才可以作为同一组</li>
<li>执行顺序为:from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order by <h4 id="2-11-2-Null-Values-and-Aggregates"><a href="#2-11-2-Null-Values-and-Aggregates" class="headerlink" title="2.11.2 Null Values and Aggregates"></a>2.11.2 Null Values and Aggregates</h4></li>
</ul>
<p><code>select sum(salary) from instructor</code></p>
<ul>
<li>上述语句中计算sum时会忽略掉null值</li>
<li>如果没有non-null值那么结果为null，只有count会返回0</li>
<li>所有aggregate操作除了<code>count(*)</code>都会忽略元组中的null值</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-52.png" alt="alt text"> </p>
<p>第二个表示重名率小于千分之一</p>
<h3 id="2-12-Nested-Subqueries"><a href="#2-12-Nested-Subqueries" class="headerlink" title="2.12 Nested Subqueries"></a>2.12 Nested Subqueries</h3><p>A subquery is a select-from-where expression that is nested within another query.</p>
<h4 id="2-12-1-Set-Membership"><a href="#2-12-1-Set-Membership" class="headerlink" title="2.12.1 Set Membership"></a>2.12.1 Set Membership</h4><p><code>in</code>,<code>not in</code></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-53.png" alt="alt text"></p>
<p>除了单个元素外，元组也可以使用 in, not in</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> (customer_id, product_id) <span class="keyword">IN</span> (<span class="keyword">select</span> customer_id,product_id <span class="keyword">from</span> info <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">100</span>)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-12-2-Set-Comparison"><a href="#2-12-2-Set-Comparison" class="headerlink" title="2.12.2 Set Comparison"></a>2.12.2 Set Comparison</h4><ul>
<li><code>some</code> 某些成员</li>
<li><code>all</code> 所有成员</li>
</ul>
<blockquote>
<p>eg 工资大于生物系中的某些老师的老师</p>
</blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (<span class="keyword">select</span> salary</span><br><span class="line">                                    <span class="keyword">from</span> instructor</span><br><span class="line">                                    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">'Biology'</span>);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-12-3-Scalar-Subquery"><a href="#2-12-3-Scalar-Subquery" class="headerlink" title="2.12.3 Scalar Subquery"></a>2.12.3 Scalar Subquery</h3><p><strong>Scalar(标量) Subquery</strong> is one which is used where a single value is expected.</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span>  salary <span class="operator">*</span> <span class="number">10</span> <span class="operator">&gt;</span> </span><br><span class="line">    (<span class="keyword">select</span> budget  <span class="keyword">from</span> department </span><br><span class="line">    <span class="keyword">where</span> department.dept_name <span class="operator">=</span> instructor.dept_name)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这里 dept_name 是这个表的主键，只返回一个元组，这种情况下是可以不用 some, all 的。</li>
</ul>
<h4 id="2-12-4-Test-for-Empty-Relations"><a href="#2-12-4-Test-for-Empty-Relations" class="headerlink" title="2.12.4 Test for Empty Relations"></a>2.12.4 Test for Empty Relations</h4><p>The exists construct returns the value true if the argument subquery is nonempty.</p>
<ul>
<li><code>exists r</code>&lt;=&gt; $r \neq \emptyset$</li>
<li><code>not exists r</code>&lt;=&gt; $r = \emptyset$</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">'Fall'</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span> <span class="number">2009</span> <span class="keyword">and</span>                </span><br><span class="line">    <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span>                            </span><br><span class="line">    <span class="keyword">from</span> section <span class="keyword">as</span> T                      </span><br><span class="line">    <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">'Spring'</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span> <span class="number">2010</span> <span class="keyword">and</span> S.course_id<span class="operator">=</span> T.course_id);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Find all students who have taken all courses offered in the Biology department.<br>SQL 语句往往需要逆向考虑，即找到这样的学生，不存在他没选过的生物系的课。</p>
</blockquote>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( (<span class="keyword">select</span> course_id</span><br><span class="line">                        <span class="keyword">from</span> course</span><br><span class="line">                        <span class="keyword">where</span> dept_name <span class="operator">=</span> ’Biology’)</span><br><span class="line">                <span class="keyword">except</span></span><br><span class="line">                    (<span class="keyword">select</span> T.course_id</span><br><span class="line">                        <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">                        <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID));</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-12-5-Test-for-Absence-of-Duplicate-Tuples"><a href="#2-12-5-Test-for-Absence-of-Duplicate-Tuples" class="headerlink" title="2.12.5 Test for Absence of Duplicate Tuples"></a>2.12.5 Test for Absence of Duplicate Tuples</h4><p>The unique construct tests whether a subquery has any duplicate tuples in its result.<br>验证一个集合是否是集合，而非多重集</p>
<ul>
<li>Evaluates to “true” on an empty set.可以将 unique 理解为 at most once.</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-54.png" alt="alt text"></p>
<ul>
<li>not unique一般题目中会描述为<code>at least two</code></li>
</ul>
<h3 id="2-13-With-Clause"><a href="#2-13-With-Clause" class="headerlink" title="2.13 With Clause"></a>2.13 With Clause</h3><p>The <code>with</code> clause提供了一个定义relation definition只对with子句发生的查询开放的临时表</p>
<ul>
<li><p>只是一个临时表，随着查询的结束自动消除</p>
<blockquote>
<p>Find all departments with the maximum budget</p>
</blockquote>
</li>
<li><p>一般可以在选择一个具有特定性质的值的时候使用</p>
</li>
</ul>
<h1 id="Chapter-4-Intermediate-SQL"><a href="#Chapter-4-Intermediate-SQL" class="headerlink" title="Chapter 4 Intermediate SQL"></a>Chapter 4 Intermediate SQL</h1><h2 id="4-1-Joined-Relations"><a href="#4-1-Joined-Relations" class="headerlink" title="4.1 Joined Relations"></a>4.1 Joined Relations</h2><ul>
<li>连接操作输入两个关系，并返回另一个关系</li>
<li>连接操作通常用作from子句中的子查询表达式</li>
<li>连接条件(Join Condition):定义两个关系中的哪些元组匹配，以及链接结果中存在哪些属性</li>
<li>连接类型(Join Type):定义如何处理另一个关系中的任何元组不匹配的元组(基于连接条件)</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-62.png" alt="alt text"></p>
<h3 id="4-1-1-Natural-Join"><a href="#4-1-1-Natural-Join" class="headerlink" title="4.1.1 Natural Join"></a>4.1.1 Natural Join</h3><ul>
<li>from子句获得的是求解好后的新关系，因此有些实现不支持再用原来的关系名访问原属性</li>
<li>可以用多个<code>natural join</code>来连接多个关系</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> r1 <span class="keyword">natural</span> <span class="keyword">join</span> r2 <span class="keyword">natural</span> <span class="keyword">join</span> ... <span class="keyword">natural</span> <span class="keyword">join</span> rm</span><br><span class="line"><span class="keyword">where</span> P;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>另外，使用<code>join...using</code>子句可以从两个关系的同名属性中选择指定的属性作为连接的依据，更加灵活<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, title</span><br><span class="line"><span class="keyword">from</span> (student <span class="keyword">natural</span> <span class="keyword">join</span> takes) <span class="keyword">join</span> course <span class="keyword">using</span> (course_id);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="4-1-2-Join-Conditions"><a href="#4-1-2-Join-Conditions" class="headerlink" title="4.1.2 Join Conditions"></a>4.1.2 Join Conditions</h3><ul>
<li>除了<code>joing using</code>以外，还有更加通用的<code>join...on</code>运算。只要<code>where</code>支持的谓词，<code>on</code>条件均支持，因此能够表达更为丰富的连接条件<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID <span class="operator">=</span> takes.ID;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-1-3-Outer-Join"><a href="#4-1-3-Outer-Join" class="headerlink" title="4.1.3 Outer Join"></a>4.1.3 Outer Join</h3><blockquote>
<p>自然连接仅仅保留那些同名属性值相等的元组，那些不相等的元组都会被抛弃，但是有时我们需要保留这些不相等的元组。这个时候，就需要用到外连接(Outer Join)</p>
</blockquote>
</li>
</ul>
<p>外连接的作用类似于自然连接，区别在于<strong>外连接会保留那些两个关系中同名属性值不相等的属性，设为null</strong>。SQL提供了三种不同形式的外连接：</p>
<ul>
<li>左外连接(Left Outer Join):使用 <code>left outer join</code> 运算符，仅保留第一个关系的所有元组</li>
<li>右外连接(Right Outer Join):使用 <code>right outer join</code> 运算符，仅保留第二个关系的所有元组</li>
<li>全外连接(Full Outer Join):使用 <code>full outer join</code> 运算符，保留两个关系的所有元组<ul>
<li>可以将其结果看作左外连接与右外连接结果的并集</li>
<li>有些数据库系统不支持全外连接</li>
</ul>
</li>
</ul>
<p>对应地，前面介绍的哪些没有保留不匹配元组的连接方式称为<strong>内连接(Inner Join)</strong></p>
<ul>
<li>在 SQL 语法中可以显式指出 inner join，但可以省略 inner，因为 join 子句默认是内连接的</li>
</ul>
<p>在外连接中，<code>on</code>和<code>where</code>子句的区别在于:</p>
<ul>
<li><code>on</code>子句会保留那些不符合条件的元组</li>
<li><code>where</code>子句会丢掉那些不符合条件的元组</li>
</ul>
<p>eg.现在有两张表<code>student</code>和<code>score</code></p>
<ul>
<li>student表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Alice</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Scores表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>85</td>
</tr>
<tr>
<td>4</td>
<td>95</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Students.StudentID, Students.Name, Scores.Score</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Scores</span><br><span class="line"><span class="keyword">ON</span> Students.StudentID <span class="operator">=</span> Scores.StudentID;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>结果为</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Name</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Alice</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>85</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>结果表明<code>on</code>只是按照条件将两张表进行连接但不会去除未能连接的表</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-63.png" alt="alt text"></p>
<p>可以发现课程CS-315对应的prereq不存在，以及CS-437的课程信息不存在</p>
<ul>
<li><p>如果我们使用<code>course natural left outer join prereq</code>,这将<code>prereq</code>的结果保存下来，没有信息的课程CS-315结果设为NULL<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-64.png" alt="alt text"></p>
</li>
<li><p>如果我们使用 <code>course natural right outer join prereq</code>，这将 course 的结果保存下来，没有信息的课程 CS-437 结果设为 NULL：<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-65.png" alt="alt text"></p>
</li>
<li><p>如果我们使用<code>course natural full outer join prereq</code>,这将 course 和 prereq 的结果保存下来，没有信息的课程 CS-315 和 CS-437 结果设为 NULL：<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-67.png" alt="alt text"></p>
</li>
</ul>
<h2 id="4-2-SQL-Data-Types-and-Schemas"><a href="#4-2-SQL-Data-Types-and-Schemas" class="headerlink" title="4.2 SQL Data Types and Schemas"></a>4.2 SQL Data Types and Schemas</h2><h3 id="4-2-1-User-Defined-Types"><a href="#4-2-1-User-Defined-Types" class="headerlink" title="4.2.1 User-Defined Types"></a>4.2.1 User-Defined Types</h3><ul>
<li>SQL支持两种形式的用户定义数据类型(User-Defined Data Types):<ul>
<li>区分类型 （Distinct Types）：基于现有类型创建的新类型<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE MONEY <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">CREATE</span> TYPE PERCENTAGE <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure></li>
<li>结构化数据类型（Structured Data Types）：复杂的数据类型，包括嵌套记录结构、数组、多重集<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE Address <span class="keyword">AS</span> (</span><br><span class="line">    street <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    city <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    zipcode <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> Customers (</span><br><span class="line">    id <span class="type">INTEGER</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    address Address</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li>不同的属性可能有相同的类型，但有时我们希望将这些属性的类型区分开来，我们使用 create type 语句来定义用户定义数据类型中的区分类型<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> type Dollars <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>, <span class="number">2</span>) <span class="keyword">final</span>;</span><br><span class="line"><span class="keyword">create</span> type Pounds <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>, <span class="number">2</span>) <span class="keyword">final</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>定义了<code>dollars</code>和<code>pounds</code>类型后，就可以把它们作为元类使用：<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> department  </span><br><span class="line">(dept_name <span class="type">varchar</span> (<span class="number">20</span>),  </span><br><span class="line">building <span class="type">varchar</span> (<span class="number">15</span>),  </span><br><span class="line">budget Dollars);</span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>用户定义的这两个类型 Dollars 和 Pounds，虽然底层类型相同，但会被视为不同的类型。因此这两种类型不能直接进行运算，甚至不能与 numeric 类型运算，这时就需要用 cast 子句进行强制类型转换<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误：不能直接对 Dollars 和 Pounds 进行运算</span></span><br><span class="line"><span class="keyword">SELECT</span> US_Sales.amount <span class="operator">+</span> UK_Sales.amount</span><br><span class="line"><span class="keyword">FROM</span> US_Sales, UK_Sales;</span><br><span class="line"><span class="comment">-- 将 Pounds 转换为 Dollars 进行运算</span></span><br><span class="line"><span class="keyword">SELECT</span> US_Sales.amount <span class="operator">+</span> <span class="built_in">CAST</span>(UK_Sales.amount <span class="keyword">AS</span> Dollars)</span><br><span class="line"><span class="keyword">FROM</span> US_Sales, UK_Sales;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-2-2-Domains"><a href="#4-2-2-Domains" class="headerlink" title="4.2.2 Domains"></a>4.2.2 Domains</h3></li>
<li>SQL的<code>domain</code>关键字提供了与<code>type</code>类似的功能，用于为底层类型添加完整性约束<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain person_name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not null</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>我们还可以使用<code>check</code>子句来添加额外的约束条件<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain degree_level <span class="type">varchar</span>(<span class="number">10</span>)  </span><br><span class="line"><span class="comment">--- degree_level_test是约束条件的名称</span></span><br><span class="line"><span class="keyword">constraint</span> degree_level_test  </span><br><span class="line"><span class="keyword">check</span> (<span class="keyword">value</span> <span class="keyword">in</span> (’Bachelors’, ’Masters’, ’Doctorate’));</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p><strong><code>type</code>和<code>domain</code>之间的区别</strong></p>
<ul>
<li>域可以有约束，并且可以使用域类型的默认值</li>
<li>域并没有强制的类型要求。因此，只要底层类型是可兼容的，在某个域的值就可以被赋予另一个域类型的值<ul>
<li>例如，如果两个域都是基于字符串类型定义的，即使它们的约束不同，也可以相互赋值。</li>
</ul>
</li>
</ul>
<h3 id="4-2-3-Large-Object-Types"><a href="#4-2-3-Large-Object-Types" class="headerlink" title="4.2.3 Large-Object Types"></a>4.2.3 Large-Object Types</h3><blockquote>
<p>很多数据库系统需要存储包含大数据项的属性，比如照片、高分辨率的图像或视频等。因此 SQL 为字符数据（CLOB）和二进制数据（BLOB）提供了大对象数据类型（Large-Object Data Types）</p>
<ul>
<li>BLOB：二进制大对象（Binary Large Object）——对象是未解释的二进制数据的大型集合（其解释由数据库系统之外的应用程序定义）<ul>
<li>在 MySQL 中，BLOB 数据类型有：<ul>
<li>TinyBlob：0～255 字节</li>
<li>Blob：0～64K 字节</li>
<li>MediumBlob：0～16M 字节</li>
<li>LargeBlob：0～4G 字节</li>
</ul>
</li>
</ul>
</li>
<li>CLOB：字符大对象（Character Large Object）——对象是大型字符数据的集合</li>
<li>当查询返回大型对象时，将返回指针，而不是大型对象本身。</li>
</ul>
</blockquote>
<h2 id="4-3-Integrity-Constraints"><a href="#4-3-Integrity-Constraints" class="headerlink" title="4.3 Integrity Constraints"></a>4.3 Integrity Constraints</h2><ul>
<li>完整性约束通过确保对数据库的授权更改不会导致数据一致性的丢失，来访时数据库的以外损坏。对于一个关系来说，有以下几种<ul>
<li><code>not null</code>:定义键值不允许为空</li>
<li><code>primary key</code></li>
<li><code>unique</code><ul>
<li><code>unique(A1, A2, ..., Am)</code> 指出属性 A1、A2、…Am 形成一个超级键（不一定是一个候选键）</li>
<li><strong>候选键允许为null</strong></li>
</ul>
</li>
<li><code>check(P)</code>其中P是一个谓词<ul>
<li>也可以有复杂查询，但许多数据库不支持</li>
<li>eg. e.g. <code>check ((course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches))</code></li>
</ul>
</li>
<li>foreign key</li>
</ul>
</li>
</ul>
<p>确保每个课程的学期为春夏秋冬其中之一<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> section (</span><br><span class="line">&nbsp;&nbsp;&nbsp; course_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; sec_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; semester <span class="type">varchar</span> (<span class="number">6</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; <span class="keyword">year</span> <span class="type">numeric</span> (<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; room_number <span class="type">varchar</span> (<span class="number">7</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; <span class="type">time</span> slot id <span class="type">varchar</span> (<span class="number">4</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; <span class="keyword">primary key</span> (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">&nbsp;&nbsp;&nbsp; <span class="keyword">check</span> (semester <span class="keyword">in</span> (’Fall’, ’Winter’, ’Spring’, ’Summer’))  </span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p></p>
<h3 id="4-3-1-Referential-Integrity"><a href="#4-3-1-Referential-Integrity" class="headerlink" title="4.3.1 Referential Integrity"></a>4.3.1 Referential Integrity</h3><ul>
<li>参照完整性(Referential Integrity)确保在给定属性集的一个关系中出现的值，也出现在另一个关系中的特定属性集中<ul>
<li>例如，如果 “Biology” 是出现在关系 instructor 的某个元组中的部门名称，则 “Biology” 的关系 department 中存在一个元组</li>
</ul>
</li>
<li>在SQL中，参照完整性约束由<strong>外键</strong>实现，语法为<code>FOREIGN KEY (dept_name) REFERENCES department</code><ul>
<li>设 A 为一组属性。 设 R 和 S 是包含属性 A 的两个关系，其中 A 是 S 的主键。如果 A 的任何值出现在 R 中，这些值也出现在 S 中，则称 A 是 R 的外键</li>
</ul>
</li>
<li>执行违反参照完整性约束的语句时会被拒绝。然而，对于在被参照关系上的更新和删除行为，如果违反约束，系统必须采取行动来改变参照关系的元组，以恢复约束。对于以下语句:<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> course (</span><br><span class="line">    <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>以删除操作为例，如果要删除 department 里的元组，那么就会违背参照完整性约束，不过系统不会拒绝这个操作，而是通过级联（Cascade）删除的方式删除在 course 中参照在 department 中被删除元组的元组。更新操作与之同理 - 除了 cascade 关键字外，还可以设置 set null 或 set default，当违反约束时会触发这些操作</p>
<h1 id="Chapter-5-Advanced-SQL"><a href="#Chapter-5-Advanced-SQL" class="headerlink" title="Chapter 5 Advanced SQL"></a>Chapter 5 Advanced SQL</h1><h2 id="5-1-Accessing-SQL-from-Programming-Languages"><a href="#5-1-Accessing-SQL-from-Programming-Languages" class="headerlink" title="5.1 Accessing SQL from Programming Languages"></a>5.1 Accessing SQL from Programming Languages</h2><p>数据库程序员必须能够掌握通用编程语言，至少有两个原因</p>
<ul>
<li>并非所有查询都可以用SQL表示，因为SQL不能提供通用语言的全部表达能力</li>
<li>非声明性操作(比如打印报告、与用户交互或将查询结果发送到图形用户界面)不能在SQL中完成</li>
</ul>
<p>有两种方法可以从通用编程语言访问数据库：</p>
<ul>
<li>API(应用程序接口)：通用程序可以使用函数集合连接到数据库服务器并与之通信，程序可以在运行时(RunTime)用字符串构造SQL查询，提交查询，并且将检索的结果放到程序变量中(一次仅能存储一个元组)，动态SQL有以下标准<ul>
<li>JDBC:JAVA用于连接数据库的API</li>
<li>ODBC:原来为C写的用于连接数据库的API，现在也适用于C++、C#、Ruby、Go等</li>
</ul>
</li>
<li>嵌入式SQL(Embedded SQL)：提供程序与数据库服务器交互的方法<ul>
<li>SQL语句在编译时转换为函数调用</li>
<li>在运行时，这些函数调用使用提供动态SQL工具的API连接到数据库</li>
</ul>
</li>
</ul>
<h3 id="5-1-1-JDBC"><a href="#5-1-1-JDBC" class="headerlink" title="5.1.1 JDBC"></a>5.1.1 JDBC</h3><ul>
<li>JDBC是一个JAVA API，用于与支持SQL的数据库系统进行通信</li>
<li>JDBC支持用于查询和更新数据以及检索查询结果的各种功能</li>
<li>JDBC还支持元数据检索，例如查询数据库中存在的关系以及关系属性的名称和类型</li>
</ul>
<p><strong>JDBC一般与数据库通信的模型</strong></p>
<ol>
<li><p>打开连接</p>
</li>
<li><p>创建”statement”对象</p>
</li>
<li><p>使用”statement”对象执行查询以发送查询并获取结果</p>
</li>
<li><p>用于处理错误的异常机制</p>
</li>
</ol>
<blockquote>
<p>在下面的程序中，必须在开头出导入java.sql.*,里面包含了JDBC提供的功能借口定义</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String dbid,String userid,String passwd)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        Connection conn=DriverManager.getConnection(</span><br><span class="line">            <span class="string">"jdbc:oracle:thin:@db.yale.edu:2000:univdb"</span>,userid,passwd</span><br><span class="line">        );</span><br><span class="line">        Statement stmt=conn.createStatement();</span><br><span class="line">        ...Do actual work here...</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span>(SQLException sqle){</span><br><span class="line">        System.out.println(<span class="string">"SQLException: "</span>+sqle);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Database Connection:在Java程序访问数据库的第一步是建立与数据库的连接，连接好后才能执行SQL语句。具体来说，需要使用DriverManager类的getConnection()方法，它接受以下参数：<ul>
<li>数据库相关信息，包括URL/机器名，协议，端口号，数据库名<ul>
<li>JDBC并没有规定协议，协议取决于数据库实现</li>
<li>JDBC支持多种协议，比如 jdbc:oracle:thin 是 Oracle 支持的协议，而 jdbc:mysql 是 MySQL 支持的协议等</li>
</ul>
</li>
<li>数据库用户名</li>
<li>密码</li>
<li>返回一个Connection对象，用于与数据库通信</li>
</ul>
</li>
<li>SQL Statements:建立连接后，就要将SQL语句发送到数据库系统，然后在里面执行语句，在java中通过Statement类的实例来做到这一点。Statement对象并非SQL语句本身，而是一种让Java程序里调用和传送SQL语句到数据库相关的方法的对象，而执行语句需要调用executeQuery()或executeUpdate()方法，它们分别对应查询语句和费查询语句(更新，插入，删除，创建)等的执行，并且后者会返回一个表示被插入/更新/删除的元组数(如果是创建语句的话则返回0)</li>
<li>Exceptions<ul>
<li>执行任何的SQL语句都有可能抛出异常，所以编程时需要记得用try{…}catch{…}语句块捕获异常</li>
<li>异常可以分为SQLException(与SQL相关的异常)和Exception(一般的异常，与Java相关，比如空指针，数组越界等)</li>
<li>如果可以的话，最好编写一个完整的异常处理函数，以应对各种异常</li>
</ul>
</li>
<li>Resource Management<ul>
<li>建立连接、创建语句以及其他JDBC对象都会占用系统资源，所以需要确保程序能够关闭上述这些资源，以免产生资源池耗尽导致的故障</li>
<li>一种方法是显式调用关闭语句(比如conn.close()、stmt.close()分别关闭连接和语句)，但一旦遇到异常，提前退出的话，这些关闭语句就来不及被调用，那么问题还是没解决</li>
<li>更可靠的方法是使用try-with-resources构造块，就是在try关键字和语句块之间加上圆括号，里面包含连接、语句对象等资源，这样的话当离开try语句块时，这些资源会被自动关闭</li>
</ul>
</li>
</ul>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">    stmt.executeUpdate(<span class="string">"insert into instructor values('77987','Kim','Physics','98000')"</span>)</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span>(SQLException sqle)</span><br><span class="line">{</span><br><span class="line">    System.out.println(<span class="string">"Could not insert tuple. "</span>+sqle);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">    <span class="string">"select dept_name, avg(salary)</span></span><br><span class="line"><span class="string">    from instructor</span></span><br><span class="line"><span class="string">    group by dept_name"</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">while</span>(rset.next())</span><br><span class="line">{</span><br><span class="line">    System.out.println(rset.getString(<span class="string">"dept_name"</span>)+<span class="string">" "</span>+rset.getFloat(<span class="number">2</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用executeQuery()方法执行查询语句后，检索得到的元组会放在一个ResultSet对象上，但是一次只能取其中的一个元组</li>
<li>具体来说，该对象调用next()方法获取下一个元组（如果还有的话），返回值是</li>
<li>另外，该对象提供了一些以get开头的方法来获取元组中具体属性的值，它们接收单个参数，可以使属性名(字符串)，也可以是属性的位置(整数值从1开始，可以看成是属性的编号)，常见的get方法有<ul>
<li>getString():可以检索<strong>任意</strong>SQL基本数据类型</li>
<li>getFloat():仅限于获取浮点数</li>
</ul>
</li>
</ul>
<h4 id="Getting-Result-Fields"><a href="#Getting-Result-Fields" class="headerlink" title="Getting Result Fields"></a>Getting Result Fields</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rset.getString(“dept_name”)</span><br><span class="line">rset.getString(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>如果dept_name是select result的第一个参数，上面这两行语句是等价的</p>
</blockquote>
<p>对于NULL值，可以使用wasNULL()方法来检查是否获取到了NULL值</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rset.getInt(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">if</span>(rset.wasNULL())</span><br><span class="line">    System.out.println(<span class="string">"Got null value"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Prepared-Statements"><a href="#Prepared-Statements" class="headerlink" title="Prepared Statements"></a>Prepared Statements</h4><p>我们不必预先编写一条完整的SQL语句，而是先创建一条预备语句(Prepared Statements),其中语句中出现的值用<code>?</code>替代(占用符)，之后再将具体的值插入到对应位置上。数据库系统会编译好这种预备语句。在执行这种语句的时候，数据库系统复用先前编译好的预备语句，然后将具体指应用到语句中，构成一条完整的语句</p>
<ul>
<li><code>Connection</code>类的<code>prepareStatement()</code>方法用于设置预备语句，该方法返回的是一个<code>PreparedStatement</code>对象，该对象具有<code>executeQuery()</code>和<code>executeUpdate()</code>方法</li>
<li>在 <code>prepareStatement()</code> 语句内的 SQL 语句具体值必须用 <code>?</code> 替代，之后可以用 set 开头的方法来设置具体值（比如 setInt()、setString()）。这类方法接收两个参数，第 1 个参数指明设置的是第几个 ?（从 1 开始），第 2 个参数是具体值</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(</span><br><span class="line">    <span class="string">"INSERT INTO instructor VALUES (?,?,?,?)"</span></span><br><span class="line">);</span><br><span class="line">pSmt.setString(<span class="number">1</span>,<span class="string">"88877"</span>);</span><br><span class="line">pStmt.setString(<span class="number">2</span>,<span class="string">"Perry"</span>);</span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">"Finance"</span>);</span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">"88878"</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>SQL语句等价为<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> instructor <span class="keyword">VALUES</span>("88878", "Perry", "Finance", <span class="number">125000</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p>在获取用户输入并将其添加到查询时，必须使用预备语句</p>
<p>切勿通过连接作为输入获取的字符串来创建查询，例如<code>insert into instructor values('"+ID+" ','"+name+" ' dept_name+" ','"+salary+" ');</code>这时候，如果name字段为<code>D'Souza</code>,那么查询就会变成<code>insert into instructor values(’ 88879 ’, ’ D’Souza ’, ’ Finance ’, 125000);</code>这会导致SQL语法错误</p>
<p>事实上，这就是著名的SQL注入攻击，攻击者可以通过输入恶意字符串来执行SQL语句，比如删除表、插入数据等</p>
</blockquote>
<h4 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h4><blockquote>
<p>MetaData是描述数据库自身结构、组织、关系和特征的数据，而不是数据库中存储的实际业务数据。它提供了理解和管理数据所需的信息框架</p>
</blockquote>
<p>加入在Java程序中执行这样一条SQL语句：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"SELECT * FROM instructor WHERE name = '" <span class="operator">+</span> name <span class="operator">+</span> "'"</span><br></pre></td></tr></tbody></table></figure>
<p>其中<code>name</code>是字符换变量</p>
<p>如果 name = “X’ OR ‘Y’ = ‘Y”，那么最终的语句就会变成</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"SELECT * FROM instructor WHERE name = '" <span class="operator">+</span> "X' OR 'Y' = 'Y" <span class="operator">+</span> "'"</span><br></pre></td></tr></tbody></table></figure>
<p>整理得</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"SELECT * FROM instructor WHERE name = 'X' OR 'Y' = 'Y'</span><br></pre></td></tr></tbody></table></figure>
<p>由于WHERE子句恒为true，因此查询语句就能被执行，表里的全部内容都能被查到</p>
<p>如果使用预备语句及其set方法时，上述问题就不会发生了，因为所有输入的引号都会被转化为转义字符，不会破坏原字符串的结构</p>
<h4 id="Metadata-Features"><a href="#Metadata-Features" class="headerlink" title="Metadata Features"></a>Metadata Features</h4><p>通常，Java程序会在运行时，从数据库系统中获取数据声明</p>
<p>用于存储执行查询语句的结果的ResultSet接口有一个方法<code>getMetaData()</code>，里面包含结果集的元数据(Metadata)。而这个<code>ResultSetMetaData</code>对象也有一些寻找元数据信息的方法，比如结果的列数、具体列的名称和类型等等，这样我们就能获取数据声明(即模式)了</p>
<p>执行Query获取ResultSet(重命名为rs后)</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rsmd.getColumnCount();i++)</span><br><span class="line">{</span><br><span class="line">    System.out.println(rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(rsmd.getColumnTypeName(i));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>getColumnCount()</code>方法返回元数(Arity)即列数</li>
<li><code>getColumnName()</code>方法返回列名</li>
<li><code>getColumnTypeName()</code>方法返回数据类型名，它们都接收单个表示列位置的整型参数(从1开始)<br>`</li>
</ul>
<p><code>Connection</code> 接口有一个方法 <code>getMetaData()</code>，它返回一个 DatabaseMetaData 对象。而 DatabaseMetaData 接口则提供了寻找<strong>数据库元数据</strong>shen的途径，提供了更为丰富的方法，比如返回产品名、版本号等等</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line">ResultSet rs=dbmd.getColumns(<span class="literal">null</span>,<span class="string">"univdb"</span>,<span class="string">"department"</span>,<span class="string">"%"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(rs.next())</span><br><span class="line">{</span><br><span class="line">    System.out.println(rs.getString(<span class="string">"COLUMN_NAME"</span>),rs.getSring(<span class="string">"TYPE_NAME"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>getColumns</code>方法接收四个参数<ul>
<li>目录名：<code>null</code>表示忽略该值</li>
<li>模式名</li>
<li>表名</li>
<li>列名：<code>%</code>表示返回所有列</li>
</ul>
</li>
</ul>
<p>DatabaseMetaData 还有其他方法：</p>
<ul>
<li><code>getTables()</code>：列出数据库中的所有表。前三个参数和 getColumns() 一致，最后一个参数用于限制符合条件的表，如果设为 null 则返回所有表（包括系统内部的表）</li>
<li><code>getPrimaryKeys()</code>：获取主键</li>
<li><code>getCrossReference()</code>：获取外键参照</li>
</ul>
<h4 id="Transaction-Control"><a href="#Transaction-Control" class="headerlink" title="Transaction Control"></a>Transaction Control</h4><ul>
<li>默认情况下，每个 SQL 语句都被视为自动提交的单独事务，这对于具有多个更新的事务来说是个比较麻烦的事情</li>
<li>我们可以在 Connection 中关闭自动提交<ul>
<li><code>conn.setAutoCommit(false);</code></li>
</ul>
</li>
<li>然后，我们必须显式提交或回滚事务<ul>
<li><code>conn.commit();</code>或<code>conn.rollback();</code></li>
</ul>
</li>
<li><code>conn.setAutoCommit(true)</code> 表示开启自动提交</li>
</ul>
<h3 id="5-1-2-SQLJ"><a href="#5-1-2-SQLJ" class="headerlink" title="5.1.2 SQLJ"></a>5.1.2 SQLJ</h3><blockquote>
<p>JDBC有时过于动态，编译器无法很好地提供捕获错误</p>
</blockquote>
<p>在Java中，也提供了嵌入式的SQL语句，这种语句称为SQLJ</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#sql iterator <span class="title function_">deptInfoIter</span><span class="params">(String dept name,<span class="type">int</span> avgSal)</span></span><br><span class="line"><span class="type">deptInfoIter</span> <span class="variable">iter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">#<span class="type">sql</span> <span class="variable">iter</span> <span class="operator">=</span> {select dept_name,avg(salary) as avgSal from instructor group by dept_name};</span><br><span class="line"><span class="keyword">while</span>(iter.next())</span><br><span class="line">{</span><br><span class="line">    <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> iter.dept_name();</span><br><span class="line">    <span class="type">int</span> <span class="variable">avgSal</span> <span class="operator">=</span> iter.avgSal();</span><br><span class="line">    System.out.println(deptName+<span class="string">" "</span>+avgSal);</span><br><span class="line">}</span><br><span class="line">iter.close();</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-1-3-ODBC"><a href="#5-1-3-ODBC" class="headerlink" title="5.1.3 ODBC"></a>5.1.3 ODBC</h3><ul>
<li>开放数据库连接（Open Database Connectivity,ODBC）标准<ul>
<li>应用程序与数据库服务器通信的标准</li>
<li>当客户端程序发起ODBC API的调用时，库代码便与服务器通信，执行需要执行的动作，并返回结果</li>
</ul>
</li>
<li>应用于 GUI、电子表格等应用程序</li>
<li>ODBC 最初为 Basic 和 C 定义，可用于多种语言</li>
<li>每个支持 ODBC 的数据库系统都提供了一个必须与客户端程序链接的“驱动程序”库</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-68.png" alt="alt text"></p>
<ul>
<li>当客户端程序进行ODBC API调用时，库中的代码将与服务器通信以执行请求并获取结果</li>
<li>ODBC程序首先分配一个SQL环境，然后分配一个数据库连接处理器</li>
<li>使用SQLConnect()打开数据库连接<ul>
<li>SQLConnect()的参数：<ul>
<li>连接处理器</li>
<li>要连接的服务器</li>
<li>用户标识符</li>
<li>密码</li>
</ul>
</li>
<li>还必须指定参数的类型:SQL_NTS,表示前一个参数是以NULL结尾的字符串</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INT <span class="title function_">odbcExample</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    RETCODE error;</span><br><span class="line">    HENV env;<span class="comment">//environment </span></span><br><span class="line">    HDBC conn;<span class="comment">//database connection</span></span><br><span class="line"></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    SQLAllocConnect(env,&amp;conn);</span><br><span class="line">    SQLConnect(conn,<span class="string">"db.yale.edu"</span>,SQL_NTS,<span class="string">"avi"</span>,SQL_NTS,<span class="string">"avipasswd"</span>);</span><br><span class="line">    {Do actua; work}</span><br><span class="line"></span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>程序使用<code>SQLExecDirect()</code>向数据库发送SQL命令</li>
<li>使用SQLFetch()获取结果元组</li>
<li>SQLBindCol()将C语言变量绑定到查询结果的属性<ul>
<li>当获取Tuples时，其<code>attribute</code>值会自动存储在相应的C变量中</li>
<li>SQLBindCol()的参数：<ul>
<li>ODBCstmt变量，查询结果中的属性位置</li>
<li>从SQL到C的类型转换</li>
<li>变量的地址</li>
<li>对于字符数组等可变长度类型<ul>
<li>变量的最大长度</li>
<li>用于在获取元组时存储实际长度的位置</li>
<li>注：Length字段返回负值表示该字段为NULL值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> deptname[<span class="number">80</span>];</span><br><span class="line"><span class="type">float</span> salary;</span><br><span class="line"><span class="type">int</span> lenOut1,lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* sqlquery = <span class="string">"SELECT dept_name,SUM(salary)"</span></span><br><span class="line">                <span class="string">"FROM instructor"</span></span><br><span class="line">                <span class="string">" GROUP BY dept_name"</span>;</span><br><span class="line">SQLAllocStmt(conn,&amp;stmt);</span><br><span class="line">error = SQLExecDirect(stmt,sqlquery,SQL_NTS);</span><br><span class="line"><span class="keyword">if</span>(error == SQL_SUCCESS){</span><br><span class="line">    SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="number">80</span>, &amp;lenOut1);</span><br><span class="line">    SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2);</span><br><span class="line">    <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %s %g\n"</span>, deptname, salary);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">SQLFreeStmt(stmt,SQL_DROP);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="ODBC-Prepared-Statements"><a href="#ODBC-Prepared-Statements" class="headerlink" title="ODBC Prepared Statements"></a>ODBC Prepared Statements</h4><ul>
<li>预备语句<ul>
<li>SQL语句在数据库中已经编译好</li>
<li>可以有占位符：例如<code>insert into account values(?,?,?)</code></li>
<li>使用占位符的实际值重复执行</li>
</ul>
</li>
<li>使用SQLPrepare()准备预备语句<ul>
<li>SQLPrepare(stmt,<code>&lt;SQL String&gt;</code>);</li>
</ul>
</li>
<li>绑定参数<ul>
<li>SQLBindParameter(stmt,<code>&lt;parameter#&gt;</code>,…type information and value omiitted for simplicity..)</li>
</ul>
</li>
<li>执行语句 <ul>
<li>retcode = SQLExecute(stmt);</li>
</ul>
</li>
</ul>
<h4 id="More-ODBC-Features"><a href="#More-ODBC-Features" class="headerlink" title="More ODBC Features"></a>More ODBC Features</h4><ul>
<li>元数据功能：<ul>
<li>查找数据库中的所有关系，并在数据库中查找查询结果或关系的列名称和类型</li>
</ul>
</li>
<li>默认情况下，每个SQL语句都被视为自动提交的单独事务<ul>
<li>可以关闭连接上的自动提交<code>SQLSetConnectOption(conn,SQL_AUTOCOMMIT,0)</code></li>
<li>事务必须由SQLTransaction(conn,SQL_COMMIT)或SQLTransact(conn, SQL_ROLLBACK)进行处理</li>
</ul>
</li>
</ul>
<h3 id="5-1-4-Embedded-SQL"><a href="#5-1-4-Embedded-SQL" class="headerlink" title="5.1.4 Embedded SQL"></a>5.1.4 Embedded SQL</h3><ul>
<li>SQL标准定义了SQL在各种编程语言中的嵌入</li>
<li>嵌入SQL查询的语言称为主机语言，主机语言中允许的SQL结构包括嵌入式SQL</li>
<li>这些语言的基本形式遵循在操作系统R将SQL嵌入到PL/1中的形式</li>
<li>EXEC SQL语句在主机语言中用于标识对预处理器的嵌入式SQL请求：<ul>
<li>EXEC SQL 嵌入式SQL语句</li>
<li>这样的语句因语言而异</li>
</ul>
</li>
<li>在某些语言中(如COBOL)中，分号被ED-EXEC替换</li>
<li>在 Java 中，嵌入使用 #SQL { …. }; ；在 C 中，使用 EXEC SQL <code>&lt;embedded SQL statement&gt;</code>;</li>
<li>在执行任何 SQL 语句之前，程序必须首先连接到数据库</li>
<li>这是通过以下方式完成的：<ul>
<li>使用密码的 EXEC-SQL 连接到服务器用户用户名;</li>
<li>此处，server 标识要建立连接的服务器</li>
</ul>
</li>
</ul>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><ul>
<li>主机语言的变量可以在嵌入式SQL语句中使用<ul>
<li>他们的前面有冒号以区别于SQL中的变量，eg.<code>credit_amount</code></li>
</ul>
</li>
<li>如上所述使用的主机变量必须在<code>DECLARE</code>部分声明，如下面所示。但是用于声明变量的语法尊村通常的主机语言语法<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION; </span><br><span class="line">    <span class="type">int</span> account_number;</span><br><span class="line">    <span class="type">float</span> credit_amount;</span><br><span class="line">EXEC SQL END DECLARE SECTION;   </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="Query-1"><a href="#Query-1" class="headerlink" title="Query"></a>Query</h4><ul>
<li>要编写嵌入式SQL查询，我们使用<code>declare a cursor for &lt;SQL query&gt;语句</code>,其中变量c用于标识查询</li>
<li>在主机语言中，查找完成超过主机语言中变量credit_amount中存储的学分的学生的ID和姓名</li>
<li>在SQL中指定查询，如下所示：<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> </span><br><span class="line"><span class="keyword">declare</span> c <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> ID,name </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> tot_cred <span class="operator">&gt;</span> :credit_amount;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="Open-and-Fetch"><a href="#Open-and-Fetch" class="headerlink" title="Open and Fetch"></a>Open and Fetch</h4><p>open语句如下所示</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> c;</span><br></pre></td></tr></tbody></table></figure>
<p>此语句使数据库系统执行查询并将结果保存在临时关系中，查询在执行open语句时使用主句语言变量credit-amount的值</p>
<p>fetch语句导致查询结果中的一个元组值放在主机语言变量上：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> c <span class="keyword">INTO</span> :si, :sn;</span><br></pre></td></tr></tbody></table></figure>
<p>重复调用fetch可以获取查询结果中的连续元组</p>
<h4 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h4><p>SQL 通信区域 （SQL Communication Area, SQLCA）中名为 SQLSTATE 的变量设置为“02000”，以指示没有更多数据</p>
<p>我们可以用 close 语句会导致<strong>数据库系统删除保存查询结果的临时关系</strong>：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> c;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><ul>
<li>嵌入式SQL表达式也可以用于数据库修改(更新、插入和删除)</li>
<li>可以通过声明游标用于更新cursor获取的元组</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> </span><br><span class="line"><span class="keyword">declare</span> c <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">'Music'</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>然后我们通过在cursor上执行fetch操作来迭代元组，在获取每个元组之后，我们执行以下代码：<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor </span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary<span class="operator">+</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> c;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="5-2-Procedural-Constructs-in-SQL"><a href="#5-2-Procedural-Constructs-in-SQL" class="headerlink" title="5.2 Procedural Constructs in SQL"></a>5.2 Procedural Constructs in SQL</h2><h3 id="5-2-1-Procedural-Extensions-and-Stored-Procedurals"><a href="#5-2-1-Procedural-Extensions-and-Stored-Procedurals" class="headerlink" title="5.2.1 Procedural Extensions and Stored Procedurals"></a>5.2.1 Procedural Extensions and Stored Procedurals</h3><ul>
<li>SQL提供模块语言<ul>
<li>允许在SQL中定义过程，使用if-then-else语句，for和while循环等</li>
</ul>
</li>
<li>存储过程<ul>
<li>可以在数据库中存储过程</li>
<li>然后使用call语句执行他们</li>
<li>允许外部应用程序在不知道详细信息的情况下对数据库进行操作<h3 id="5-2-2-Functions-and-Procedures"><a href="#5-2-2-Functions-and-Procedures" class="headerlink" title="5.2.2 Functions and Procedures"></a>5.2.2 Functions and Procedures</h3></li>
</ul>
</li>
<li>函数和过程允许将”业务逻辑(Business Logic)”存储在数据库中并根据SQL语句执行</li>
<li>这些可以由SQL的过程组件或外部编程语言定义</li>
<li>我们在这里介绍的语法由SQL标准定义<ul>
<li>大多数数据库都实现此语法的非标准版本</li>
</ul>
</li>
</ul>
<h4 id="1-SQL-Functions"><a href="#1-SQL-Functions" class="headerlink" title="1 SQL Functions"></a>1 SQL Functions</h4><ul>
<li>定义一个函数，该函数在给定部门名称的情况下，返回该部门中的老师人数总数</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Declaration</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(dept_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">integer</span><span class="comment">--指定返回值类型</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> d_count interger;<span class="comment">--声明一个局部变量d_count</span></span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> d_count</span><br><span class="line">        <span class="keyword">from</span> instructor<span class="comment">--结果存入d_count</span></span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> dept_name;</span><br><span class="line">    <span class="keyword">return</span> d_count;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Invocation</span><br><span class="line"><span class="keyword">select</span> dept_name, budget</span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>此外，SQL标准还支持将表作为返回结果的函数，这样的函数称为表函数(Tble Functions),也可以看作是带参数的实体化视图。具体的函数定义和调用如下所示</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Declaration</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> instructor_of(dept_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">returns</span> <span class="keyword">table</span>(</span><br><span class="line">        ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        salary <span class="type">numeric</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">table</span>(</span><br><span class="line">        <span class="keyword">select</span> ID, name, dept_name, salary</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> instructor_of.dept_name</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Invocation</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span>(instructor_of(<span class="string">'Finance'</span>));</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在函数定义内使用参数时，如果参数名有重名的情况，那么需要加上<code>函数名.</code>前缀(这就是在第十一行改为<code>instructor_of</code>)</li>
</ul>
<h4 id="2-SQL-Procedures"><a href="#2-SQL-Procedures" class="headerlink" title="2 SQL Procedures"></a>2 SQL Procedures</h4><ul>
<li>在上面的例子中，dept_count函数还可以改写为<code>procedure</code>:</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Declaration</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">in</span> dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">out</span> d_count <span class="type">integer</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> d_count</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关键字<code>in</code>和<code>out</code>分别表示接收进来的参数和存放返回结果的参数</li>
<li>我们可以使用call语句从SQL过程或嵌入式SQL调用过程</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> d_count <span class="type">integer</span>;</span><br><span class="line"><span class="keyword">call</span> dept_count_proc(<span class="string">'Physics'</span>,d_count);</span><br></pre></td></tr></tbody></table></figure>
<p>SQL允许多个参数不同的函数或过程同名，因为SQL会同时根据函数/过程名以及参数来识别函数/过程 </p>
<h3 id="5-2-3-Procedural-Constructs"><a href="#5-2-3-Procedural-Constructs" class="headerlink" title="5.2.3 Procedural Constructs"></a>5.2.3 Procedural Constructs</h3><ul>
<li>大多数数据库系统都实现了一下标准语法的变体<ul>
<li>所以用户必须阅读系统手册，了解哪些功能适用于用户的系统</li>
</ul>
</li>
<li>复合语句：begin…end…<ul>
<li>我们可以再begin和end之间包含多个SQL语句</li>
<li>局部变量可以再复合语句中声明</li>
</ul>
</li>
<li>循环语句<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--while statements</span></span><br><span class="line">while <span class="type">boolean</span> expression do </span><br><span class="line">    sequence <span class="keyword">of</span> statements;</span><br><span class="line"><span class="keyword">end</span> while</span><br><span class="line"></span><br><span class="line"><span class="comment">--Repeat Statements </span></span><br><span class="line">repeat </span><br><span class="line">    sequence <span class="keyword">of</span> statements;</span><br><span class="line">until <span class="type">boolean</span> expression</span><br><span class="line"></span><br><span class="line"><span class="comment">--for statements</span></span><br><span class="line"><span class="keyword">declare</span> n <span class="type">integer</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">as</span> <span class="comment">--r作为当前的一个游标，对关系中的每个元组进行遍历</span></span><br><span class="line">    <span class="keyword">select</span> budget <span class="keyword">from</span> department </span><br><span class="line">    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">'Music'</span></span><br><span class="line">do </span><br><span class="line">    <span class="keyword">set</span> n <span class="operator">=</span> n<span class="operator">-</span>r.budget</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">for</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>循环体内使用<code>leave</code>关键字可提前退出循环，而<code>iterate</code>则忽略当前元组，处理下一个元组。它们类似于编程语言的<code>break</code>和<code>continue</code></li>
<li>条件分之语句</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if <span class="type">boolean</span> expression </span><br><span class="line"><span class="keyword">then</span> statement <span class="keyword">or</span> compound statement</span><br><span class="line"><span class="keyword">else</span> <span class="type">boolean</span> expression</span><br><span class="line"><span class="keyword">then</span> statement <span class="keyword">or</span> compound statement</span><br><span class="line"><span class="keyword">else</span> statement <span class="keyword">or</span> compound statement</span><br><span class="line"><span class="keyword">end</span> if</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5-2-4-External-Language-Functions-Procedures"><a href="#5-2-4-External-Language-Functions-Procedures" class="headerlink" title="5.2.4 External Language Functions/Procedures"></a>5.2.4 External Language Functions/Procedures</h3><p>上述介绍的构造块鲜有数据库支持，因此程序员转而使用外部的编程语言：先用其它编程语言定义函数后，再用SQL语句导入外部的过程或函数，比如<br></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">in</span> dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">out</span> count <span class="type">integer</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">language</span> C </span><br><span class="line"><span class="keyword">external</span> name <span class="string">'/usr/avi/bin/dept_count_proc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="type">integer</span> </span><br><span class="line"><span class="keyword">language</span> C </span><br><span class="line"><span class="keyword">external</span> name <span class="string">'/usr/avi/bin/dept_count_func'</span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>外部语言功能/过程的好处：许多操作更高效，表现力更强</li>
<li>缺点：<ul>
<li>实现功能的代码可能需要加载导数据库系统中并在数据库系统的地址空间中执行，可能会有<ul>
<li>数据库结构意外损坏的风险</li>
<li>安全风险，允许用户访问未经授权的数据</li>
</ul>
</li>
<li>还有其它选择，它们可以提供良好的安全性，但代价是性能可能会变差</li>
<li>当效率比安全性更重要时，更偏向在数据库系统空间中直接执行</li>
</ul>
</li>
</ul>
<p>对于外部语言造成的风险，数据库系统提供了一些安全机制，比如：</p>
<ul>
<li>使用沙盒技术<ul>
<li>即使用像 Java 这样的安全语言，它不能用于访问/损坏数据库代码的其他部分</li>
</ul>
</li>
<li>或者，在单独的进程中运行外部语言函数/过程，而不访问数据库进程的内存<ul>
<li>通过进程间通信传输参数和结果</li>
</ul>
</li>
<li>两者都有性能开销</li>
<li>许多数据库系统同时支持上述方法以及在数据库系统地址空间中直接执行</li>
</ul>
<h2 id="5-3-Triggers"><a href="#5-3-Triggers" class="headerlink" title="5.3 Triggers"></a>5.3 Triggers</h2><p>触发器(Trigger)是一种系统自动执行的语句，作为对数据库修改的“副作用”。要想定义一个触发器，需要：</p>
<ul>
<li>指定触发器何时执行—这点可以分解为检查触发器的时间(Event)<ul>
<li>可以使插入、删除或者更新</li>
<li>更新时的触发器可以限制为特定属性<code>after update of takes on grade</code></li>
</ul>
</li>
<li>可以引用更新之前和之后的属性值<ul>
<li><code>referencing old row as</code>:用于删除和更新</li>
<li><code>referencing new row as</code>:用于插入和更新</li>
</ul>
</li>
<li>执行触发器满足的条件(Condition)</li>
<li>指定触发器需要执行的动作(Actions)</li>
</ul>
<p>要设计触发机制，我们必须：</p>
<ul>
<li>指定要执行触发器的条件</li>
<li><p>指定触发器执行时要执行的操作</p>
</li>
<li><p>对于一个表格<code>account_log(account,amount,datetime)</code></p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> account_trigger after <span class="keyword">update</span> <span class="keyword">of</span> account <span class="keyword">on</span> balance</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> new_row</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> old_row</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> nrow.balance <span class="operator">-</span> orow.balance <span class="operator">&gt;=</span> <span class="number">200000</span> <span class="keyword">or</span> </span><br><span class="line">    orow.balance <span class="operator">-</span> nrow.balance <span class="operator">&gt;=</span> <span class="number">50000</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">insert into</span> account_log <span class="keyword">values</span> (nrow.account<span class="operator">-</span>number,nrow.balance <span class="operator">-</span> orow.balance,<span class="built_in">current_time</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>time_slot_id</code>不是主键，因此我们无法创建从section到timeslot的外检约束，再删除操作中不会引起其他影响。但我们可以设计一个触发器，用来检查当前课程的<code>time_slot_id</code>是否在表内，在section和timeslot上使用触发器来实施完整性约束</p>
</li>
<li><p>检查新记录的<code>time_slot_id</code>是否存在于<code>timeslot</code>表中，从而保证section表中的<code>time_slot_id</code>都是有效的</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 </span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id</span><br><span class="line">    <span class="keyword">FROM</span> time_slot <span class="comment">/* time_slot_id not present in time_slot */</span></span><br><span class="line">))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><code>for each row</code>字句能够显式迭代每一个被插入的行记录</li>
<li><code>referencing new row as nrow</code>子句创建了一个过渡变量(Transition Variable)，用于临时存储被插入的行记录</li>
<li><p><code>when</code>语句指明了触发器的触发条件</p>
</li>
<li><p>time_slot_id 不是主键，所以当 time_slot_id 已经被删完了，但依然有课程在引用，就要 rollback</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> timeslot_check2 after <span class="keyword">delete</span> <span class="keyword">on</span> timeslot</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> orow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (orow.time_slot_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> time_slot_id</span><br><span class="line">        <span class="keyword">from</span> time_slot</span><br><span class="line">    ) </span><br><span class="line">    <span class="keyword">and</span> orow.time_slot_id <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> time_slot_id</span><br><span class="line">        <span class="keyword">from</span> section</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">rollback</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>触发器可以在事件之前激活，这可以用做额外的约束</p>
</li>
<li><p>将空白部分设置为NULL</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> setnull_trigger before <span class="keyword">update</span> <span class="keyword">of</span> takes  </span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> nrow  </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  </span><br><span class="line"><span class="keyword">when</span> (nrow.grade <span class="operator">=</span> <span class="string">' '</span>)</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">atomic</span>  <span class="comment">--作为一个原子操作执行</span></span><br><span class="line">    <span class="keyword">set</span> nrow.grade <span class="operator">=</span> <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>我们使用触发器来保持 credits_earned 的值，如果本来挂科，或者没有成绩，更新后不再挂科而且有成绩，就把学分加上去。</p>
</li>
</ul>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned </span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">'F'</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">    <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">'F'</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> credits</span><br><span class="line">         <span class="keyword">FROM</span> course</span><br><span class="line">         <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id)</span><br><span class="line">    <span class="keyword">WHERE</span> student.id <span class="operator">=</span> nrow.id;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>很多数据库系统还支持其他触发事件，比如用户登录数据库、系统关机、修改系统设置等。</p>
<p>在上述例子中，可以看到触发器既可以在事件发生前执行，也可以在事件发生后执行。一般来说，前者作为一个额外的约束限制，不仅阻止非法行为引起的错误，还要采取补救措施，使语句变得合法。</p>
<p>除了将触发器的动作一行行地应用到表中的每个行记录上，也可以将触发器一次性作用于满足 SQL 的所有行记录上，只要：</p>
<ul>
<li>将 for each row 改为 for each statement</li>
<li>并且使用 referencing old table as 和 referencing new table as 来创建过渡表</li>
<li>我们还可以决定启用或禁用触发器，相关语法为：alter trigger trigger_name disable</li>
</ul>
<p>有些数据库采用另一种语法：disable trigger trigger_name。<br>此外，还可以删除触发器：drop trigger trigger_name。</p>
<p>与函数 / 过程的语法类似，由于很多数据库系统在 SQL 相关标准建立前就广泛使用触发器了，因此几乎每个数据库系统都有自己的触发器语法，它们是互不兼容的</p>
<h3 id="When-not-to-use-Triggers"><a href="#When-not-to-use-Triggers" class="headerlink" title="When not to use Triggers"></a>When not to use Triggers</h3><p>实际上，很多看似能够用触发器解决的问题， SQL 标准早已为我们提供了更方便的方法来解决这些问题，所以在以下场景中，没有必要使用触发器：</p>
<ul>
<li>维护实体化视图：现在很多数据库系统都支持自动维护了，因此无需使用触发器手动维护</li>
<li>维护数据库的拷贝：理由同上</li>
<li>从备份拷贝上加载数据，或备份地点上复制数据库更新</li>
</ul>
<p>编写触发器的时候需小心，因为在运行时，一个触发器的错误可能会触发下一个触发器，最严重的情况下会出现无限的连锁反应。解决方案有：</p>
<ul>
<li>某些数据库系统规定了最大的触发器链的长度，超过限制就会报错</li>
<li>另外的数据库系统泽会根据触发器是否尝试引用更新后导致自身首先出发的关系来判断是否产生错误</li>
</ul>
<h1 id="Chapter-6-Entity-Relationship-Model"><a href="#Chapter-6-Entity-Relationship-Model" class="headerlink" title="Chapter 6:Entity-Relationship Model"></a>Chapter 6:Entity-Relationship Model</h1><h2 id="Database-Design-Process"><a href="#Database-Design-Process" class="headerlink" title="Database Design Process"></a>Database Design Process</h2><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-69.png" alt="alt text"></p>
<h2 id="1-Design-phases"><a href="#1-Design-phases" class="headerlink" title="1. Design phases"></a>1. Design phases</h2><ul>
<li>初始阶段(需求规范)：充分描述潜在数据库用户的数据需求</li>
<li>第二阶段(概念设计)：选择数据模型<ul>
<li>应用所选数据模型的概念</li>
<li>将这些需求转换为数据库的概念模式</li>
<li>完全开发的概念模式代表了企业的功能要求：描述对数据执行的操作(或事务)类型</li>
</ul>
</li>
<li>最后阶段(数据库设计)：从抽象数据模型转向数据库的实现<ul>
<li>逻辑设计(Logical Design)：决定书苦苦模式<ul>
<li>数据库设计要求我们找到一个”好的”关系模式集合</li>
<li>业务决策——我们应该在数据库中记录哪些属性</li>
<li>计算机科学决策——我们应该拥有哪些关系模式，以及属性应该如何在各种关系模式之间分配</li>
</ul>
</li>
<li>物理设计——决定数据库的物理布局</li>
</ul>
</li>
</ul>
<h2 id="2-Design-Alternatives"><a href="#2-Design-Alternatives" class="headerlink" title="2. Design Alternatives"></a>2. Design Alternatives</h2><ul>
<li>在设计数据库架构时，我们必须确保避免两个主要陷阱<ul>
<li>冗余：糟糕的设计可能会导致重复的信息<ul>
<li>信息的冗余表示可能会导致各种信息副本之间的数据不一致</li>
</ul>
</li>
<li>不完整：糟糕的设计可能会使企业</li>
</ul>
</li>
<li>避免糟糕的设计是不够的。可能有很多好的设计让我们必须从中进行选择</li>
<li>数据库设计可能是一个具有挑战性的问题<ul>
<li>巨大的设计空间<h2 id="3-Design-Approaches"><a href="#3-Design-Approaches" class="headerlink" title="3. Design Approaches"></a>3. Design Approaches</h2></li>
</ul>
</li>
<li>实体关系模型<ul>
<li>将企业建模为实体和关系的集合</li>
<li>实体：可以与其他对象区别开来的事物或对象<ul>
<li>由一组属性描述</li>
</ul>
</li>
<li>关系：多个实体之间的关联</li>
<li>用实体关系图以图示方式表示</li>
</ul>
</li>
<li>归一化理论<ul>
<li>正式确定哪些设计是坏的，并对其进行测试</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-70.png" alt="alt text">  </p>
<ul>
<li>一个方形款就是一个实体的集合</li>
<li>实体与实体之间有关系，一个菱形框表示关系<ul>
<li>一对一(↔)</li>
<li>多对一(→)</li>
<li>一对多(←)</li>
<li>这里<code>instructor</code>属性不需要<code>dept</code>属性，因为在<code>department</code>实体里有了，否则会冗余</li>
</ul>
</li>
<li>每个实体直接转换为关系模式。关系转换为元组，元素为两个表的<code>foreign key</code>.对于一对多的情况(如<code>instructor</code>和<code>department</code>)转换后primary key仍为ID</li>
<li>为了减少表的数量可以把主键相同的表合并</li>
<li>双横线与单横线<ul>
<li>双横线表示每个对象都必须参与关系，而单横线则表示对象可以不参与关系。</li>
<li>如<code>course_dept</code>和<code>course</code>为双横线，则表示每一个课程都要对应一个开课部门，而<code>department</code>和<code>course_dept</code>为单横线，说明有的院系可以不开设课程</li>
</ul>
</li>
<li>有些联系是隐含的，如授课老师和听课的同学</li>
<li><code>section</code>不足以唯一确定元组，称为弱实体(weak entity)，依赖于另一个实体，因为<code>course_id</code>放在<code>section</code>会有冗余，因此没有这个属性，导致形成一个弱实体(对应的relation要加上双框)，<code>section</code>不能离开<code>course</code>存在</li>
<li><code>relationship</code>上也可以带属性，如<code>takes</code>上的<code>grade</code></li>
<li>关系双方可以是相同的实体集合，<code>course</code>这里的<code>preeq</code>是多对多，表示一门课可以有多门预修课，一门课也可以是多门课的预修课。{}里面是多个值，表示复合属性。这里表示<code>time_slot_id</code>实际上可以由这三个属性复合而成</li>
</ul>
<h2 id="4-Database-Modeling"><a href="#4-Database-Modeling" class="headerlink" title="4. Database Modeling"></a>4. Database Modeling</h2><h3 id="4-1-Entities"><a href="#4-1-Entities" class="headerlink" title="4.1 Entities"></a>4.1 Entities</h3><ul>
<li>数据库可以建模为：<ul>
<li>实体的集合</li>
<li>实体之间的关系</li>
</ul>
</li>
<li>实体是存在且可以与其他对象区分开来的对象，如特定人员、公司、事件、工厂</li>
<li>实体具有属性，如对于一个人来说，有地址、姓名、性别等</li>
<li>实体集是一组共享相同属性的相同类型的实体，如所有人员、公司、树、假日的集合</li>
<li>实体集可以按如下方式以图形方式表示<ul>
<li>实体集以矩形框表示</li>
<li>实体矩形内列出的属性</li>
<li>下划线表示主键属性<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-71.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="4-2-Relationship-Sets"><a href="#4-2-Relationship-Sets" class="headerlink" title="4.2 Relationship Sets"></a>4.2 Relationship Sets</h3><ul>
<li>关系是多个实体之间的关联</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-72.png" alt="alt text"></p>
<ul>
<li><p>关系集是$n \geq 2$个实体之间的数学关系，每个实体都取自实体集，即${e_1,e_2,…,e_n|e_1 \in E_1,e_2 \in E_2,…,e_n \in E_n}$,其中$(e_1,e_2,…,e_n)$是一个关系</p>
<ul>
<li>按照上面的例子，$(44553,22222) \in advisor$</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-73.png" alt="alt text"></p>
<h3 id="4-3-Relationship-Set-with-Attributes"><a href="#4-3-Relationship-Set-with-Attributes" class="headerlink" title="4.3 Relationship Set with Attributes"></a>4.3 Relationship Set with Attributes</h3><p>关系集也可以有属性，例如实体集instructor和student之间的advisor关系集就可能具有属性date,该属性跟踪student开始与advisor关联的时间</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-74.png" alt="alt text"><br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-75.png" alt="alt text"></p>
<h3 id="4-4-Role"><a href="#4-4-Role" class="headerlink" title="4.4 Role"></a>4.4 Role</h3><ul>
<li>关系的实体集不需要是不同的<ul>
<li>实体集的每次出现都在关系中扮演一个<code>Role</code></li>
</ul>
</li>
</ul>
</li>
<li>标签<code>course_id</code>和<code>prereq_id</code>都被称为<code>Role</code></li>
</ul>
<h3 id="4-5-Degree-of-a-Relationship-Set"><a href="#4-5-Degree-of-a-Relationship-Set" class="headerlink" title="4.5 Degree of a Relationship Set"></a>4.5 Degree of a Relationship Set</h3><ul>
<li>二元联系(Binary Relationship)<ul>
<li>涉及两个实体集(或称为degree=2)</li>
<li>数据库系统中的大多数关系都是二元的</li>
</ul>
</li>
<li>在某些情况下，将关系表示为非二元关系会更方便</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-76.png" alt="alt text"></p>
<h3 id="4-6-Attributes"><a href="#4-6-Attributes" class="headerlink" title="4.6 Attributes"></a>4.6 Attributes</h3><ul>
<li>实体由一组属性表示，这些属性是实体集的所有成员都拥有的属性<ul>
<li><code>instructor = (ID, name, street, city, salary)</code>,<code>course = (course_id, title, credits)</code></li>
</ul>
</li>
<li>域(domain)—-每个属性的允许值集</li>
<li>属性类型<ul>
<li>Simple和Composite属性</li>
<li>单值(Single-valued)和多值(Multi-valued)属性 eg.phone_numbers,可以同时拥有多个电话号码，所以电话号码这一属性不一定只有一个值</li>
</ul>
</li>
<li><p>派生(Derived)属性</p>
<ul>
<li>可以从其他属性计算</li>
<li><p>eg.给定date_of_birth，可以计算出年龄</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-77.png" alt="alt text"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-7-Mapping-Cardinality-Constraints"><a href="#4-7-Mapping-Cardinality-Constraints" class="headerlink" title="4.7 Mapping Cardinality Constraints"></a>4.7 Mapping Cardinality Constraints</h3><ul>
<li>二元关系集的映射基数约束表示另一个实体可以通过关系集关联到实体数</li>
<li>在描述二元关系时最有用</li>
<li>对于二元关系集，映射基数必须是一对一、一对多、多对一、多对多类型之一</li>
<li>我们通过在关系集和实体集之间绘制一条有向线（→）表示“一”，用一条无向线（-）表示“多”</li>
</ul>
<h4 id="4-7-1-One-to-One-Relationships"><a href="#4-7-1-One-to-One-Relationships" class="headerlink" title="4.7.1 One-to-One Relationships"></a>4.7.1 One-to-One Relationships</h4><ul>
<li>教师和学生之间的一对一关系：<ul>
<li>一个学生通过advisor<strong>最多</strong>与一名教师关联，可以没有</li>
<li>一名教师通过advisor<strong>最多</strong>与一名学生关联，可以没有</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-78.png" alt="alt text"></p>
<h4 id="4-7-2-One-to-Many-Relationships"><a href="#4-7-2-One-to-Many-Relationships" class="headerlink" title="4.7.2 One-to-Many Relationships"></a>4.7.2 One-to-Many Relationships</h4><ul>
<li>教师和学生之间的一对多关系：<ul>
<li>一名教师通过advisor与多个(包括0个)学生关联</li>
<li>一个学生通过advisor最多与一名教师关联</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-79.png" alt="alt text"></p>
<h4 id="4-7-3-Many-to-One-Relationships"><a href="#4-7-3-Many-to-One-Relationships" class="headerlink" title="4.7.3 Many-to-One Relationships"></a>4.7.3 Many-to-One Relationships</h4><ul>
<li>教师和学生之间的多对一关系<ul>
<li>一名教师通过advisor最多与一名学生关联</li>
<li>一名学生通过advisor与多个(包括0个)教师关联</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-80.png" alt="alt text"></p>
<h4 id="4-7-4-Many-to-Many-Relationships"><a href="#4-7-4-Many-to-Many-Relationships" class="headerlink" title="4.7.4 Many-to-Many Relationships"></a>4.7.4 Many-to-Many Relationships</h4><ul>
<li>教师和学生之间的多对多关系<ul>
<li>一名教师通过advisor与多个(包括0个)学生关联</li>
<li>一名学生通过advisor与多个(包括0个)教师关联</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-81.png" alt="alt text"></p>
<h3 id="4-8-Total-and-Partial-Participation"><a href="#4-8-Total-and-Partial-Participation" class="headerlink" title="4.8 Total and Partial Participation"></a>4.8 Total and Partial Participation</h3><ul>
<li>完全参与(Total Participation)通常使用双线表示，表示实体集中的每个实体都至少参与关系集中的一个关系<ul>
<li>例如每一个学生都应当至少有一个相关的advisor<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-82.png" alt="alt text"></li>
</ul>
</li>
<li>部分参与(Partial Participation)通常使用单线表示，表示某些实体可能不参与关系集中的任何关系<ul>
<li>例如一个教师可能没有相关的advisor</li>
</ul>
</li>
<li>一条线可能具有关联的最小和最大的基数，以l..h的形式表示关系，其中l是最小基数，h是最大基数<ul>
<li>最小值是1表示完全参与</li>
<li>最大值是1表示实体最多参与一个</li>
<li>最大值*表示无限制</li>
<li>例如，教师可以为0个或更多学生提供建议。学生必须有一名advisor,不能有多个advisor<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-83.png" alt="alt text"></li>
</ul>
</li>
<li>我们最多允许三元(或更高度数)关系中的一个箭头 来表示基数约束</li>
<li>例如，proj_guide到instructor的箭头表示每个学生最多有一个项目的instructor<ul>
<li>原因：这与主键的解释有关。假设有如下关系图，那么对该关系图的主键解释有两种<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/253211ac7e01c92106952a82893f4d4.jpg" alt="alt text"></li>
<li>来自$E_1,E_2$的一个特定实体组合可以和至多一个来自$E_3,E_4$的实体组合相关联。因此，联系R的主键可以用主键$E_1,E_2$的并集来构造</li>
<li>来自$E_1,E_2,E_3$的一个特定实体组合至多可与来自$E_4$的一个实体组合相关联，那么，可以用$E_1,E_2,E_3$主键的并集构成R的主键。$E_1,E_2,E_4$的主码的并集也是如此<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-84.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="4-9-Primary-Key"><a href="#4-9-Primary-Key" class="headerlink" title="4.9 Primary Key"></a>4.9 Primary Key</h3><ul>
<li>主键提供了一种指定如何区分实体和关系的方法，我们将考虑实体集、关系集、弱实体集</li>
<li>根据定义 各个实体是不同的</li>
<li>从数据库的角度来看，它们之间的差异必须用它们的属性来表示</li>
<li>实体的属性值必须使其能够唯一标识实体<ul>
<li>实体集中的任何两个实体集都不允许所有属性具有完全相同的值</li>
</ul>
</li>
<li>实体的键就是一组足以将实体区分开来的属性</li>
<li>为了区分关系集的各种关系，我们使用关系集中实体的各个主键<ul>
<li>设R为涉及实体集$E_1,E_2,…,E_n$的关系集</li>
<li>R的主键由$E_1,E_2,…,E_n$的各个主键组成</li>
<li>如果关系集R具有与其关联的属性$a_1,a_2,…,a_m$，则R的主键还包括属性$a_1,a_2,…,a_m$</li>
<li>eg.advisor关系集的主键是instructor.ID和student.ID:<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-85.png" alt="alt text"></li>
</ul>
</li>
<li>关系集的主键选择取决于关系集的映射基数<ul>
<li>如果二元关系为一对一关系，任一参与实体集的主键都可以构成一个最小超级键(Minimal Superkey),并且可以选择其中任意一个作为主键</li>
<li>如果二元关系为一对多关系或多对一，“多“关系一端的主键是最小超级键，作为主键</li>
<li>如果二元关系为多对多关系，两个实体集的主键的并集是最小超级键</li>
</ul>
</li>
</ul>
<h3 id="4-10-Weak-Entity-Sets"><a href="#4-10-Weak-Entity-Sets" class="headerlink" title="4.10 Weak Entity Sets"></a>4.10 Weak Entity Sets</h3><ul>
<li>没有主键的实体集称为弱实体集</li>
<li>弱实体集的存在取决于表示性实体集(Identifying Entity Set)的存在<ul>
<li>它必须通过从表示到弱实体集的一对多关系集与标识实体集相关</li>
<li>我们使用双菱形来描绘的标识性联系(Identifying Relationship)</li>
</ul>
</li>
<li>弱实体集的分辨符(Discriminator，或称为部分键)是指当弱实体集所依赖的标识实体已知时区分实体集的所有实体的属性集</li>
<li>我们用虚线为弱实体集的分辨符画下划线</li>
<li>我们将弱实体的识别关系放在双菱形中</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-86.png" alt="alt text"></p>
<p>注意：强实体集的主键不会与弱实体集一起显式存储，因为它隐含在标识关系中</p>
<p>如果显式存储<code>course_id</code>则section可以成为强实体，但section和course之间的关系将由course和section通用属性定义的隐式关系course_id复制</p>
<h3 id="4-11-Rebundant-Attributes"><a href="#4-11-Rebundant-Attributes" class="headerlink" title="4.11 Rebundant Attributes"></a>4.11 Rebundant Attributes</h3><ul>
<li>假设我们有实体集<ul>
<li>student，属性为：ID, name, tot_cred, dept_name</li>
<li>department，属性为：dept_name, building, budget</li>
</ul>
</li>
<li>我们使用关系集stu_dept对每个学生都有一个关联部门这一事实进行建模</li>
<li>下面student中的属性dept_name复制了关系中存在的信息，因此是多余的，并且需要被删除</li>
<li>但是，当转换回表时，在某些情况下，该属性会重新引入</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-87.png" alt="alt text"></p>
<h2 id="5-Reduction-to-Relational-Schemas"><a href="#5-Reduction-to-Relational-Schemas" class="headerlink" title="5. Reduction to Relational Schemas"></a>5. Reduction to Relational Schemas</h2><ul>
<li>实体集和关系集可以统一表示为表示数据库内容的关系架构</li>
<li>符合E-R图的数据库可以由架构集合表示</li>
<li>对于每个实体集和关系集，都有一个唯一的架构，该架构分配有相应的实体集或关系集的名称</li>
<li>每个架构都有许多列(通常对应于属性)，这些列具有唯一的名称</li>
</ul>
<h3 id="5-1-Representing-Entity-Sets-with-Simple-Attributes"><a href="#5-1-Representing-Entity-Sets-with-Simple-Attributes" class="headerlink" title="5.1 Representing Entity Sets with Simple Attributes"></a>5.1 Representing Entity Sets with Simple Attributes</h3><ul>
<li>强实体集简化为具有相同属性的架构</li>
<li>弱实体集将变成一个表，该表包含标识强实体集的主键<ul>
<li>表的主键是弱实体集的分辨符与标识强实体集的主键的并集</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-88.png" alt="alt text"></p>
<ul>
<li>section表的主键是<code>(course_id,sec_id,semester,year)</code></li>
</ul>
<h3 id="5-2-Representing-Relational-Sets"><a href="#5-2-Representing-Relational-Sets" class="headerlink" title="5.2 Representing Relational Sets"></a>5.2 Representing Relational Sets</h3><p>一个多对多关系表示为一个架构，其中包含两个参与实体集的主键的属性</p>
<ul>
<li>e.g.对于一个关系集advisor的模式：advisor=(<u>s_id,i_id</u>)</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-89.png" alt="alt text"></p>
<h3 id="5-3-Rebundancy-of-Schemas"><a href="#5-3-Rebundancy-of-Schemas" class="headerlink" title="5.3 Rebundancy of Schemas"></a>5.3 Rebundancy of Schemas</h3><p>在多段总计的多对一和一对多关系集可以通过向”多”的一段添加一个额外的属性来表示，该属性包含“一”一端的主键</p>
<ul>
<li>e.g. 将关系集inst_dept创建模式稀释到两个实体集中</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-90.png" alt="alt text"></p>
<ul>
<li><p>对于一对一关系集，可以选择任何一方作为“多”的一端</p>
<ul>
<li>也就是说，可以将更多的属性添加到与两个实体集对应的任意表中</li>
</ul>
</li>
<li><p>如果参与在“多”的一端是部分参与，则在与“多”的一端对应的模式中用额外的属性替换模式可能会导致null值</p>
</li>
<li>与将弱实体集链接到其标识的强实体集的关系集对应的模式是多余的<ul>
<li>e.g.section模式已包含将显示在sec_course模式中的属性</li>
</ul>
</li>
</ul>
<h3 id="5-4-Composite-and-Multivalued-Attributes"><a href="#5-4-Composite-and-Multivalued-Attributes" class="headerlink" title="5.4 Composite and Multivalued Attributes"></a>5.4 Composite and Multivalued Attributes</h3><ul>
<li>通过为每个组件属性创建单独的属性来扁平化复合属性<ul>
<li>就像在C语言里定义了一个结构，但是关系数据库里每个属性都必须是简单数据类型，就必须把这些复合属性铺平</li>
<li>e.g.给定的实体集instructor,first_name, last_name 与实体集对应的模式具有两个属性 name_first_name 和 name_last_name</li>
<li>如果没有歧义，则省略前缀</li>
<li>忽略多值属性，扩展instructor模式为：instructor(ID, first_name, middle_initial,  last_name, street_number, street_name, apt_number, city, state, zip_code,     date_of_birth, age)<ul>
<li>phone_number属性被省略</li>
</ul>
</li>
</ul>
</li>
<li>实体E的多值属性M由单独的模式EM表示<ul>
<li>模式EM具有对应于E的主键的属性和对应域多值属性M的属性<ul>
<li>e.g.instructor的多值属性phone_number由模式inst_phone表示：inst_phone(<u>ID,phone_number</u>)</li>
</ul>
</li>
<li>多值属性的每个值都映射到模式EM上关系的单独元祖<ul>
<li>e.g.主键为222222，456-7890 和 123-4567 的 instructor 实体映射到两个元组：(22222,456-7890)和(22222,123-4567)</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况：实体time_slot只有一个除主键属性之外的属性，并且该属性是多值的<ul>
<li>time_slot(<u>time_slot_id</u>,{day,start_time,end_time})可以被拆分为<ul>
<li>time_slot(<u>time_slot_id</u>)</li>
<li>time_slot_details(<u>time_slot_id,day,start_time</u>.end_time)</li>
</ul>
</li>
<li>优化：不创建实体对应的关系，time_slot_details(<u>time_slot_id,day,start_time</u>.end_time)</li>
</ul>
</li>
<li>但是因为这个优化使得time_slot属性不能是外键，可能需要用trigger来实现</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-91.png" alt="alt text"></p>
<h2 id="6-Design-Issues"><a href="#6-Design-Issues" class="headerlink" title="6. Design Issues"></a>6. Design Issues</h2><h3 id="6-1-Common-Mistakes-in-E-R-Diagrams"><a href="#6-1-Common-Mistakes-in-E-R-Diagrams" class="headerlink" title="6.1 Common Mistakes in E-R Diagrams"></a>6.1 Common Mistakes in E-R Diagrams</h3><ul>
<li><p>信息冗余<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-92.png" alt="alt text"></p>
<blockquote>
<p>student的dept_name应该去掉</p>
</blockquote>
</li>
<li><p>关系属性使用不当<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-93.png" alt="alt text"></p>
<blockquote>
<p>这是一门课，可能会有很多次作业，不能只用一个实体</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-94.png" alt="alt text"></p>
</blockquote>
</li>
</ul>
<h3 id="6-2-Placement-of-Relationship-Attributes"><a href="#6-2-Placement-of-Relationship-Attributes" class="headerlink" title="6.2 Placement of Relationship Attributes"></a>6.2 Placement of Relationship Attributes</h3><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-95.png" alt="alt text"></p>
<ul>
<li>第一种方法：可以记录每次访问日期</li>
<li>第二种方法：只能记录用户最近一次访问日期，不完整</li>
</ul>
<h3 id="6-3-Binary-VS-Non-Binary-Relationships"><a href="#6-3-Binary-VS-Non-Binary-Relationships" class="headerlink" title="6.3 Binary VS Non-Binary Relationships"></a>6.3 Binary VS Non-Binary Relationships</h3><ul>
<li>尽管可以用多个不同的二元关系集替换任何非二元关系集，但n元关系集可以更清楚地显示多个实体参与单个关系</li>
<li>一些看起来非二元的关系可能更适合使用二元关系来表示<ul>
<li>例如，将孩子与他的父亲和母亲联系起来的三元关系父母最好用两种二元关系来代替</li>
<li>使用两个二元关系允许出现部分信息(例如，只有母亲知道的信息)</li>
</ul>
</li>
<li>但是有些关系天生就是非二元的</li>
</ul>
<h3 id="6-4-Converting-Non-Binary-Relationships-to-Binary-Form"><a href="#6-4-Converting-Non-Binary-Relationships-to-Binary-Form" class="headerlink" title="6.4 Converting Non-Binary Relationships to Binary Form"></a>6.4 Converting Non-Binary Relationships to Binary Form</h3><p>通常，任何非二元关系都可以通过创建人工实体集来使用二元关系来表示</p>
<ul>
<li>将实体集 A、B 和 C 之间的 R 替换为实体集 E 和三个关系集：<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-96.png" alt="alt text"></li>
<li>为E创建特殊标识属性</li>
<li>将R的所有属性添加到E</li>
<li>对于每一个R中的关系$(a_i,b_i,c_i)$<ul>
<li>在实体集E这种建立新实体$c_i$</li>
<li>将$(e_i,a_i)$添加到$R_A$;将$(e_i,b_i)$添加到$R_B$;将$(e_i,c_i)$添加到$R_C$</li>
</ul>
</li>
<li>我们还需要转换所有的约束<ul>
<li>可能无法转换所有约束</li>
<li>已翻译的模式中可能不存在不能对应于R的任何实例</li>
<li>我们可以通过使 E 成为由三个关系集标识的弱实体集来避免创建标识属性</li>
</ul>
</li>
</ul>
<h3 id="6-5-E-R-Desogn-Decisions"><a href="#6-5-E-R-Desogn-Decisions" class="headerlink" title="6.5 E-R Desogn Decisions"></a>6.5 E-R Desogn Decisions</h3><ul>
<li>使用属性或实体集来表示对象</li>
<li>实际概念是用实体集还是关系集最好地表达</li>
<li>使用三元关系或二元关系</li>
<li>使用强实体集或弱实体集</li>
</ul>
<h3 id="6-6-Extended-ER-Features"><a href="#6-6-Extended-ER-Features" class="headerlink" title="6.6 Extended ER Features"></a>6.6 Extended ER Features</h3><ul>
<li>特化(Specialization)<ul>
<li>自上而下的设计过程：我们再实体集中指定与几何中的其他实体不同的子分组</li>
<li>属性继承：较低级别的实体集继承其链接到的较高级别实体集的所有属性和关系参与</li>
</ul>
</li>
<li>概化(Generalization)<ul>
<li>自下而上的设计过程：相同特征的多个实体集合并到更高级别的实体集中</li>
</ul>
</li>
<li>特化和概化是彼此的简单倒置，它们在E-R图中以相同的方式表示</li>
<li>术语特化和概化可以互相使用</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-97.png" alt="alt text"></p>
<ul>
<li>特化和概化的设计约束<ul>
<li>对实体是否可以属于单个概化中的多个较低级别实体集的约束<ul>
<li>不相交(Disjoint)<ul>
<li>一个实体只能属于一个较低级别的实体集</li>
<li>在E-R图中，通过让多个较低级别的实体集链接到同一个三角形来表示</li>
</ul>
</li>
<li>重叠(Overlapping)<ul>
<li>一个实体可以属于多个较低级别的实体集</li>
</ul>
</li>
</ul>
</li>
<li>完全性约束(Completeness Constraint)<ul>
<li>指较高级别实体集中的实体是否必须至少属于概化中的至少一个较低级别实体集<ul>
<li>全部(Total):实体必须属于较低级别的实体集之一</li>
<li>部分(Partial):实体不必属于较低级别的实体集之一</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Bruce Yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/">http://example.com/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">BruceYang的笔记小站</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/" title="计算机体系结构(Computer Architecture)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机体系结构(Computer Architecture)</div></div><div class="info-2"><div class="info-item-1">Chapter 1:Fundamentals of Computer DesignPart One: Introduction 冯诺依曼架构：存算分离   计算机的分类（及关键的系统特征） Personal Mobile Devices(个人移动设备)：成本、能耗、媒体性能、响应速度 Desktop Computers(桌面计算机)：性价比、能耗、图形性能 Servers Computers(服务器)：吞吐量、可用性、可扩展性（规模）、能耗 Embedded Computers(物联网/嵌入式计算机):价格、能耗、应用的特有性能 Supercomputers(超级计算机/集群、仓库计算机)：性价比、吞吐量、能耗均衡性  计算机并行 数据集并行(DLP)：使某些数据选项可以同时操作 任务机并行(TLP): 创建的工作任务可以单独执行 并且主要采用并行方式执行  Flynn’s Class(根据数据流与指令流)    Part Two: Performance 影响性能的因素：体系结构，硬件实现，编译器，OS等 衡量性能的方法 Single users on a...</div></div></div></a><a class="pagination-related" href="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/" title="宏观经济学"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">宏观经济学</div></div><div class="info-2"><div class="info-item-1">第九章 宏观经济的基本指标及其衡量第一节...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Bruce Yang</div><div class="author-info-description">主要内容为浙江大学CS本科生相关课程的笔记及代码，附带部分自学的内容和辅修课程笔记</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-1-Introduction"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1: Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Database-Systems"><span class="toc-number">1.1.</span> <span class="toc-text">1. Database Systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">2. 数据库系统的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.3.</span> <span class="toc-text">3. 数据库的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E8%A7%86%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">4. 数据视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%A8%A1%E5%BC%8F-schema-%E4%B8%8E%E5%AE%9E%E4%BE%8B-Instance"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 模式(schema)与实例(Instance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%95%B0%E6%8D%AE%E7%8B%AC%E7%AB%8B%E6%80%A7-%E6%8C%87%E6%95%B0%E6%8D%AE%E5%92%8C%E7%A8%8B%E5%BA%8F%E7%9B%B8%E4%BA%92%E4%B8%8D%E4%BE%9D%E8%B5%96%EF%BC%8C%E6%8A%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BB%8E%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%86%E7%A6%BB%E5%87%BA%E6%9D%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 数据独立性(指数据和程序相互不依赖，把数据的定义从程序中分离出来)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Data-Models"><span class="toc-number">1.5.</span> <span class="toc-text">5. Data Models</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80"><span class="toc-number">1.6.</span> <span class="toc-text">6. 数据库语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80%EF%BC%88Data-Definition-Language-DDL%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 数据定义语言（Data Definition Language,DDL）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Data-Manipulation-Language-DML-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 Data Manipulation Language (DML, 数据操作语言)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-SQL-Query-Language"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 SQL Query Language</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Database-Access-from-Application-Program"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 Database Access from Application Program</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.7.</span> <span class="toc-text">7. 数据库设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E"><span class="toc-number">1.8.</span> <span class="toc-text">8. 数据库引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 存储管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 查询处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86-Transaction-Management"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 事务管理(Transaction Management)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Database-Users"><span class="toc-number">1.9.</span> <span class="toc-text">9. Database Users</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Introduction-to-Relational-Model"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2:Introduction to Relational Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Structure-of-Relational-Databases"><span class="toc-number">2.1.</span> <span class="toc-text">1. Structure of Relational Databases</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Concepts"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 Concepts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Attributes"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Database-Schema"><span class="toc-number">2.2.</span> <span class="toc-text">2. Database Schema</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Keys"><span class="toc-number">2.3.</span> <span class="toc-text">3. Keys</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Relational-Algebra"><span class="toc-number">2.4.</span> <span class="toc-text">4. Relational Algebra</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Select"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 Select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Project"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 Project</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Union"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 Union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Set-Difference"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.4 Set Difference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Cartesian-Product"><span class="toc-number">2.4.5.</span> <span class="toc-text">4.5 Cartesian Product</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Rename"><span class="toc-number">2.4.6.</span> <span class="toc-text">4.6 Rename</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-Additional-Operators"><span class="toc-number">2.4.7.</span> <span class="toc-text">4.7 Additional Operators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-1-set-intersection-operation"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">4.7.1 set-intersection operation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-Natural-Join-Operation"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">4.7.2 Natural Join Operation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Theta-Join-Operation-Formalization"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">Theta Join Operation Formalization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-Division-Operation"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">4.7.3 Division Operation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-4-Assignment-Operation"><span class="toc-number">2.4.7.5.</span> <span class="toc-text">4.7.4 Assignment Operation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.4.8.</span> <span class="toc-text">4.8 操作符的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-Extended-Relational-Algebra-Operations"><span class="toc-number">2.4.9.</span> <span class="toc-text">4.9 Extended Relational-Algebra Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-1-Aggregate-Functions"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">4.9.1 Aggregate Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-2-Outer-Join"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">4.9.2 Outer Join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-3-Null-values"><span class="toc-number">2.4.9.3.</span> <span class="toc-text">4.9.3 Null values</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-3-Introduction-to-SQL"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3 Introduction to SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Data-Definition"><span class="toc-number">3.1.</span> <span class="toc-text">1 Data Definition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Domain-Types-in-SQL"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.1 Domain Types in SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Built-in-Data-Types-in-SQL"><span class="toc-number">3.1.2.</span> <span class="toc-text">1.2 Built-in Data Types in SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Create-Table-Consrtuct"><span class="toc-number">3.1.3.</span> <span class="toc-text">1.3 Create Table Consrtuct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Drop-and-Alter-Table-Constructs"><span class="toc-number">3.1.4.</span> <span class="toc-text">1.4 Drop and Alter Table Constructs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Basic-Query-Structure"><span class="toc-number">3.2.</span> <span class="toc-text">2 Basic Query Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-The-select-Clause"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.1 The select Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-The-where-clause"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2 The where clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-The-from-clause"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.3 The from clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Natural-Join"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.4 Natural Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-The-Rename-Operation"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.5 The Rename Operation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-String-Operations"><span class="toc-number">3.2.6.</span> <span class="toc-text">2.6 String Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-Ordering-the-Display-of-Tuples"><span class="toc-number">3.2.7.</span> <span class="toc-text">2.7 Ordering the Display of Tuples</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-The-limit-Clause"><span class="toc-number">3.2.8.</span> <span class="toc-text">2.8 The limit Clause</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-Set-Operations"><span class="toc-number">3.2.9.</span> <span class="toc-text">2.9 Set Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-Null-Values"><span class="toc-number">3.2.10.</span> <span class="toc-text">2.10 Null Values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-Aggregate-Functions"><span class="toc-number">3.2.11.</span> <span class="toc-text">2.11 Aggregate Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-1-Having-Clause"><span class="toc-number">3.2.11.1.</span> <span class="toc-text">2.11.1 Having Clause</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-11-2-Null-Values-and-Aggregates"><span class="toc-number">3.2.11.2.</span> <span class="toc-text">2.11.2 Null Values and Aggregates</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-Nested-Subqueries"><span class="toc-number">3.2.12.</span> <span class="toc-text">2.12 Nested Subqueries</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-1-Set-Membership"><span class="toc-number">3.2.12.1.</span> <span class="toc-text">2.12.1 Set Membership</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-2-Set-Comparison"><span class="toc-number">3.2.12.2.</span> <span class="toc-text">2.12.2 Set Comparison</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-3-Scalar-Subquery"><span class="toc-number">3.2.13.</span> <span class="toc-text">2.12.3 Scalar Subquery</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-4-Test-for-Empty-Relations"><span class="toc-number">3.2.13.1.</span> <span class="toc-text">2.12.4 Test for Empty Relations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-12-5-Test-for-Absence-of-Duplicate-Tuples"><span class="toc-number">3.2.13.2.</span> <span class="toc-text">2.12.5 Test for Absence of Duplicate Tuples</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-13-With-Clause"><span class="toc-number">3.2.14.</span> <span class="toc-text">2.13 With Clause</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-4-Intermediate-SQL"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4 Intermediate SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Joined-Relations"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Joined Relations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Natural-Join"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 Natural Join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-Join-Conditions"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 Join Conditions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-Outer-Join"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 Outer Join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-SQL-Data-Types-and-Schemas"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 SQL Data Types and Schemas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-User-Defined-Types"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 User-Defined Types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-Domains"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 Domains</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-Large-Object-Types"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 Large-Object Types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Integrity-Constraints"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Integrity Constraints</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-Referential-Integrity"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1 Referential Integrity</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-Advanced-SQL"><span class="toc-number">5.</span> <span class="toc-text">Chapter 5 Advanced SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Accessing-SQL-from-Programming-Languages"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 Accessing SQL from Programming Languages</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-JDBC"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#update"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Query"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">Query</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Getting-Result-Fields"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">Getting Result Fields</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prepared-Statements"><span class="toc-number">5.1.1.4.</span> <span class="toc-text">Prepared Statements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL-injection"><span class="toc-number">5.1.1.5.</span> <span class="toc-text">SQL injection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Metadata-Features"><span class="toc-number">5.1.1.6.</span> <span class="toc-text">Metadata Features</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transaction-Control"><span class="toc-number">5.1.1.7.</span> <span class="toc-text">Transaction Control</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-SQLJ"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 SQLJ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-ODBC"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3 ODBC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ODBC-Prepared-Statements"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">ODBC Prepared Statements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#More-ODBC-Features"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">More ODBC Features</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-Embedded-SQL"><span class="toc-number">5.1.4.</span> <span class="toc-text">5.1.4 Embedded SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Variables"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">Variables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Query-1"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">Query</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Open-and-Fetch"><span class="toc-number">5.1.4.3.</span> <span class="toc-text">Open and Fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Close"><span class="toc-number">5.1.4.4.</span> <span class="toc-text">Close</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Update"><span class="toc-number">5.1.4.5.</span> <span class="toc-text">Update</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-Procedural-Constructs-in-SQL"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 Procedural Constructs in SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-Procedural-Extensions-and-Stored-Procedurals"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 Procedural Extensions and Stored Procedurals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-Functions-and-Procedures"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 Functions and Procedures</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-SQL-Functions"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">1 SQL Functions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-SQL-Procedures"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">2 SQL Procedures</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-Procedural-Constructs"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3 Procedural Constructs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-External-Language-Functions-Procedures"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4 External Language Functions/Procedures</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Triggers"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 Triggers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#When-not-to-use-Triggers"><span class="toc-number">5.3.1.</span> <span class="toc-text">When not to use Triggers</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-6-Entity-Relationship-Model"><span class="toc-number">6.</span> <span class="toc-text">Chapter 6:Entity-Relationship Model</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Database-Design-Process"><span class="toc-number">6.1.</span> <span class="toc-text">Database Design Process</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Design-phases"><span class="toc-number">6.2.</span> <span class="toc-text">1. Design phases</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Design-Alternatives"><span class="toc-number">6.3.</span> <span class="toc-text">2. Design Alternatives</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Design-Approaches"><span class="toc-number">6.4.</span> <span class="toc-text">3. Design Approaches</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Database-Modeling"><span class="toc-number">6.5.</span> <span class="toc-text">4. Database Modeling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Entities"><span class="toc-number">6.5.1.</span> <span class="toc-text">4.1 Entities</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Relationship-Sets"><span class="toc-number">6.5.2.</span> <span class="toc-text">4.2 Relationship Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Relationship-Set-with-Attributes"><span class="toc-number">6.5.3.</span> <span class="toc-text">4.3 Relationship Set with Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Role"><span class="toc-number">6.5.4.</span> <span class="toc-text">4.4 Role</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Degree-of-a-Relationship-Set"><span class="toc-number">6.5.5.</span> <span class="toc-text">4.5 Degree of a Relationship Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Attributes"><span class="toc-number">6.5.6.</span> <span class="toc-text">4.6 Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-Mapping-Cardinality-Constraints"><span class="toc-number">6.5.7.</span> <span class="toc-text">4.7 Mapping Cardinality Constraints</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-1-One-to-One-Relationships"><span class="toc-number">6.5.7.1.</span> <span class="toc-text">4.7.1 One-to-One Relationships</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-2-One-to-Many-Relationships"><span class="toc-number">6.5.7.2.</span> <span class="toc-text">4.7.2 One-to-Many Relationships</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-3-Many-to-One-Relationships"><span class="toc-number">6.5.7.3.</span> <span class="toc-text">4.7.3 Many-to-One Relationships</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-4-Many-to-Many-Relationships"><span class="toc-number">6.5.7.4.</span> <span class="toc-text">4.7.4 Many-to-Many Relationships</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-Total-and-Partial-Participation"><span class="toc-number">6.5.8.</span> <span class="toc-text">4.8 Total and Partial Participation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-Primary-Key"><span class="toc-number">6.5.9.</span> <span class="toc-text">4.9 Primary Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-Weak-Entity-Sets"><span class="toc-number">6.5.10.</span> <span class="toc-text">4.10 Weak Entity Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-Rebundant-Attributes"><span class="toc-number">6.5.11.</span> <span class="toc-text">4.11 Rebundant Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Reduction-to-Relational-Schemas"><span class="toc-number">6.6.</span> <span class="toc-text">5. Reduction to Relational Schemas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Representing-Entity-Sets-with-Simple-Attributes"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.1 Representing Entity Sets with Simple Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Representing-Relational-Sets"><span class="toc-number">6.6.2.</span> <span class="toc-text">5.2 Representing Relational Sets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Rebundancy-of-Schemas"><span class="toc-number">6.6.3.</span> <span class="toc-text">5.3 Rebundancy of Schemas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-Composite-and-Multivalued-Attributes"><span class="toc-number">6.6.4.</span> <span class="toc-text">5.4 Composite and Multivalued Attributes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Design-Issues"><span class="toc-number">6.7.</span> <span class="toc-text">6. Design Issues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Common-Mistakes-in-E-R-Diagrams"><span class="toc-number">6.7.1.</span> <span class="toc-text">6.1 Common Mistakes in E-R Diagrams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Placement-of-Relationship-Attributes"><span class="toc-number">6.7.2.</span> <span class="toc-text">6.2 Placement of Relationship Attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Binary-VS-Non-Binary-Relationships"><span class="toc-number">6.7.3.</span> <span class="toc-text">6.3 Binary VS Non-Binary Relationships</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Converting-Non-Binary-Relationships-to-Binary-Form"><span class="toc-number">6.7.4.</span> <span class="toc-text">6.4 Converting Non-Binary Relationships to Binary Form</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-E-R-Desogn-Decisions"><span class="toc-number">6.7.5.</span> <span class="toc-text">6.5 E-R Desogn Decisions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-Extended-ER-Features"><span class="toc-number">6.7.6.</span> <span class="toc-text">6.6 Extended ER Features</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/" title="面向对象程序设计Object-Oriented Programming">面向对象程序设计Object-Oriented Programming</a><time datetime="2025-04-07T14:42:09.000Z" title="发表于 2025-04-07 22:42:09">2025-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/" title="宏观经济学">宏观经济学</a><time datetime="2025-04-07T04:10:28.000Z" title="发表于 2025-04-07 12:10:28">2025-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/" title="数据库系统 Database System">数据库系统 Database System</a><time datetime="2025-04-06T03:27:59.000Z" title="发表于 2025-04-06 11:27:59">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/" title="计算机体系结构(Computer Architecture)">计算机体系结构(Computer Architecture)</a><time datetime="2025-04-06T02:23:57.000Z" title="发表于 2025-04-06 10:23:57">2025-04-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2019 - 2025 By Bruce Yang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="http://example.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style>
  <script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax="">
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?zfour";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="zfour";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="height:100%;display: flex;align-items: center;justify-content: center;"><svg style="height:50px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:248px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><script data-pjax="">function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax="">function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img id="card-clock-loading" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-clock/clock/images/weather/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading" class="entered loading"></div></div></div></div></div>';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script data-pjax="">
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1500ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1500ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1500ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer="" src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer="" src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax="">
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container">${temple_html_item}</div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer="" src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer="" data-pjax="" src="https://unpkg.zhimg.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>