<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>宏观经济学</title>
    <url>/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="第九章-宏观经济的基本指标及其衡量"><a href="#第九章-宏观经济的基本指标及其衡量" class="headerlink" title="第九章 宏观经济的基本指标及其衡量"></a>第九章 宏观经济的基本指标及其衡量</h1><h2 id="第一节-国内生产总值及衡量"><a href="#第一节-国内生产总值及衡量" class="headerlink" title="第一节 国内生产总值及衡量"></a>第一节 国内生产总值及衡量</h2><h3 id="一、GDP的含义"><a href="#一、GDP的含义" class="headerlink" title="一、GDP的含义"></a>一、GDP的含义</h3><ol>
<li>总产出核算的标准</li>
</ol>
<ul>
<li>两种不同的核算体系：<ul>
<li>物质产品平衡表体系，简称MPS。计划经济国家使用<ul>
<li>容易出现重复计算问题</li>
</ul>
</li>
<li>国民经济核算体系，简称SNA。</li>
</ul>
</li>
</ul>
<ol>
<li>GDP的含义：指一定时期内在一国(或地区)境内生产的所有最终产品与服务的市场价值总和<blockquote>
<p>越发达的地区，服务总产值所占比例越高</p>
</blockquote>
</li>
</ol>
<ul>
<li>GDP是一个市场价值概念</li>
<li>GDP衡量的是最终产品和服务的价值，中间产品和服务价值不计入GDP<ul>
<li>最终产品直接供人们直接使用和消费，不在转卖</li>
<li>中间产品作为生产投入品，不能直接使用和消费的产品的服务<blockquote>
<p>当我们买车时，轮胎就作为中间产品；而当爆胎需要补胎时，轮胎就是最终产品</p>
</blockquote>
</li>
</ul>
</li>
<li>GDP是一国(或地区)范围内生产的最终产品和服务的市场价值<ul>
<li>GDP强调国土原则，而不是按照过敏原则计算</li>
</ul>
</li>
<li>GDP衡量的是一定时间内的产品和服务的价值<ul>
<li>GDP是<strong><em>流量</em></strong>而非存量</li>
<li>流量是指一定时期内发生或产生的变量</li>
<li>存量是指某一时点上存在的量<h3 id="二、GDP的衡量"><a href="#二、GDP的衡量" class="headerlink" title="二、GDP的衡量"></a>二、GDP的衡量</h3></li>
</ul>
</li>
</ul>
<ol>
<li>增值法：是从生产角度衡量GDP的一种方法<ul>
<li>基本思想：通过加总经济中各个产业的产品和服务的价值来求得GDP核算值</li>
<li>$企业的增值=企业产出价值-企业购买中间产品价值$<blockquote>
<p>例如:假设一家麦当劳店以0.5美元的价格从一个牧场主手里购买了1/4磅的牛肉,然后以1.5美元的价格卖出一个汉堡包。在这个例子中,麦当劳店的增值是多少?</p>
<blockquote>
<p>1.5-0.5=1</p>
</blockquote>
</blockquote>
</li>
<li>GDP=该国境内所有企业的增值之和</li>
</ul>
</li>
<li>收入法：用要素收入即企业生产成本核算GDP的一种方法</li>
</ol>
<ul>
<li>以要素成本衡量的国内生成净值<ul>
<li>工资收入（存在雇主）：包括净工资和雇主支付的额外福利</li>
<li>利息、租金和利润收入<ul>
<li>家庭所收到的对其资本支付的利息</li>
<li>租金：对使用土地和其他可租用的生产要素的支付</li>
<li>利润：企业利润以及自己经营企业的企业家收入</li>
</ul>
</li>
</ul>
</li>
<li>得到GDP需要做出的调整<ul>
<li>从要素成本到生产价格：间接税和补助金造成了支出法（市场价格核算）和收入法（以要素成本来核算）计算结果的差异</li>
<li>从净产值到总产值：国内生产净值和总产值之间的差别在于折旧。收入法GDP核算中的企业利润是扣除资本折旧后的净值，以收入法得到GDP必须在总收入加上折旧<blockquote>
<p>例如:根据增值法,汽车零售商的增值就是汽车销售收入和批发成本的差额,这些差额必定会成为某些人的收入。包括:汽车零售商支付给销售人员和技工的<strong><em>工资、租金、贷款利息、利润</em></strong>。这样,全部增值以<strong><em>工资、租金、利息和利润</em></strong>的形式出现在收入流中。严格来讲,以收入法核算GDP还应包括: <strong><em>间接税、折旧、公司未分配利润</em></strong>等。</p>
<script type="math/tex; mode=display">
GDP = 工资+利息+利润+租金+折旧+间接税-补助</script><script type="math/tex; mode=display">
GDP = C(消费)+S(储蓄)+T(税)</script><script type="math/tex; mode=display">
Y(收入) = C+S+T</script></blockquote>
</li>
</ul>
</li>
</ul>
<ol>
<li>支出法:通过衡量在一定时期内整个社会购买最终产品和服务的总支出来核算GDP的一种方法</li>
</ol>
<ul>
<li><p>在实际情况下，支出法与收入法核算产生的差额被称为统计误差</p>
<ul>
<li>一国经济对产品和服务需求的角度可以划分为四个部门：家庭部门、企业部门、政府部门、国际部门<ul>
<li>开放经济-四部门经济：家庭、企业、政府、国际</li>
<li>封闭经济<ul>
<li>三部门经济：家庭、企业、政府</li>
<li>二部门经济：家庭、企业</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>企业部门的支出称为投资支出，简称投资(I)：是一定时期增加到资本存量上的新的资本流量。资本流量是指在经济中生产性资本的物质总量（厂房、设备、存货和住宅等），是<strong><em>企业在厂房、设备和存货上的支出与家庭在住宅上的支出之和</em></strong>。</p>
<ul>
<li>资本存量的增加是投资的结果</li>
<li>折旧：资本品的损耗造成的资本存量（指在经济中生产性资本的物质总量，包括所有的厂房、设备和住宅等）的减少，为了补偿或重新置换已消耗掉的资本。</li>
<li>为补偿或重新置换已消耗的资本进行的投资称为重置投资</li>
<li>重置投资=折旧</li>
<li>使资本存量出现净增加的投资被定义为净投资<ul>
<li>净投资=当年年终资本存量-上年年终资本存量</li>
<li>总投资=净投资+折旧</li>
</ul>
</li>
<li>固定投资：对新厂房、机器设备和住宅的购买</li>
<li>存货投资：指企业持有的存货价值的变化。也就是企业为了未来销售或生产而持有的原材料、半成品和成品的库存。属于流动资产<strong><em>当年存货投资=当年年终存货价值-上年年终存货价值</em></strong></li>
</ul>
</li>
<li>家庭部门对最终产品和服务的支出被称为消费支出，简称消费(C)<ul>
<li>耐用品消费支出：汽车、电视等</li>
<li>非耐用品消费支出：食品、服装等</li>
<li>劳务消费支出：医疗、教育、旅游等</li>
</ul>
</li>
<li>政府部门购买产品和服务的支出定义为政府购买(G)<ul>
<li>包括政府提供国防、修建道路、开班学校等</li>
<li>政府支出包括政府购买和政府转移支付。但政府转移支付是对收入的再分配，并不直接用于交换产品和服务，所以不构成GDP的一部分</li>
</ul>
</li>
<li>净出口：为衡量国际部门对一国产品和服务的支出引入的概念<ul>
<li>出口额(X)：是指本国向国际部门提供的产品和服务的总价值</li>
<li>进口额(M)：是指从国际部门输入到本国的产品和服务的总价值。</li>
<li><strong><em>对国际部门来说。只有净出口应计入总支出</em></strong></li>
<li>净出口=出口额-进口额(NX=X-M)<ul>
<li>当NX&gt;0时，一国经济存在贸易盈余或贸易顺差</li>
<li>当NX=0时，一国经济达到贸易平衡</li>
<li>当NX&lt;0时，一国经济存在贸易赤字或贸易逆差<script type="math/tex; mode=display">
GDP=C+I+G+NX</script><script type="math/tex; mode=display">
Y=C+I+G+NX</script></li>
</ul>
</li>
<li>从广义角度看，宏观经济中的产出、收入与支出是完全等值的，即：总产出=总收入=总支出<h2 id="三、名义GDP与实际GDP"><a href="#三、名义GDP与实际GDP" class="headerlink" title="三、名义GDP与实际GDP"></a>三、名义GDP与实际GDP</h2></li>
</ul>
</li>
</ul>
<ol>
<li>名义GDP：用生产产品和服务的当年价格计算的全部最终产品和服务的市场价值<ul>
<li>用于反映当年经济规模</li>
</ul>
</li>
<li>实际GDP：选定某一时期作为基期，然后以基期价格核算出的某年所生产的全部最终产品和服务的市场价值<ul>
<li>反映实际经济增长<blockquote>
<p>2023 年：生产了 100 个苹果，每个苹果的价格是 1 元。名义 GDP = 100 元，实际 GDP = 100 元。2024 年：生产了 110 个苹果，每个苹果的价格是 1.2 元。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li>将一国某一年的实际GDP除以该国人口数，可得到该国该年的人均GDP。<ul>
<li>人均实际GDP既可以被用来纵向比较一国经济在不同时期的发展状况，又可以用来横向比较不用国家的生活水平差异</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
实际GDP=\frac{名义GDP}{GDP折算指数}</script><ol>
<li>购买力平价(Purchasing Power Parity)</li>
</ol>
<ul>
<li>以实际购买力计算的两个国家不同货币之间的比例，简称PPP</li>
<li>计算方法：选取典型的商品与劳务作为比较样本，再用两个国家不同的货币与市场价格分别加权计算样本的价格总额，价格总额的比例就是体现两国货币实际购买力的换算率，即购买力平价<blockquote>
<p>如果中国市场上用人民币购头大米为每吨2000元、猪肉<br>为每吨10000元、29英寸彩色电视机为每台8000元、2.8立升排、气量的轿车为每辆100000元、购买价格总额为120000元;美国市场上用美元购买大米为每吨4000元、猪肉为每吨20000元、29英寸彩色电视机为每台1000元、2.8立升排气量的轿车为每辆5000元,购买价格总额为30000元。那么按购买力平价计算的美元与人民币的换算比例应为1美元=4元人民币。</p>
<h3 id="四、与GDP相关的其他指标"><a href="#四、与GDP相关的其他指标" class="headerlink" title="四、与GDP相关的其他指标"></a>四、与GDP相关的其他指标</h3></blockquote>
</li>
<li>国民生产总值(GNP)，是经济社会(一国或地区)<strong><em>成员</em></strong>在一定时期运用生产要素所生产的全部最终产品和服务的市场价值<blockquote>
<p>GNP强调人的属性，而GDP强调属地原则<br>一名中国公民在美国有一处房产，每年收缴的租金属于中国的GNP而不属于美国的GNP</p>
</blockquote>
</li>
<li>使用GDP不使用GNP的原因：<ul>
<li>GNP提供的产品和服务对象，解决就业问题是所在地的，而对成员所属的经济社会没有实际意义</li>
</ul>
</li>
<li>GNP=GDP+来自国外的要素报酬-支付给国外的要素报酬</li>
<li>GNP或GDP<ul>
<li>减折旧（存量）等于国民净产值(Net National Product(NNP))或国内净产值(Net Domestic Product(NDP))：$NNP=GNP-折旧$</li>
<li>减间接税(不是成员本身交的税)等于：国民收入（National Income（NI））$NI=NNP-统计误差$<blockquote>
<p>统计误差的产生是由于不同数据来源可能并不是完全一致的</p>
</blockquote>
</li>
<li>减公司未分配的利润、公司所得税、社会保险税；加转移支付(政府按照一定用途给予的)，等于：个人收入Personal Income（PI）</li>
<li>减个人所得税等于：个人可支配收入Diposable Personal Income（DPI）</li>
</ul>
</li>
</ul>
<h2 id="第二节-消费、储蓄、投资、政府购买与净出口"><a href="#第二节-消费、储蓄、投资、政府购买与净出口" class="headerlink" title="第二节 消费、储蓄、投资、政府购买与净出口"></a>第二节 消费、储蓄、投资、政府购买与净出口</h2><h3 id="一、消费和储存"><a href="#一、消费和储存" class="headerlink" title="一、消费和储存"></a>一、消费和储存</h3><h4 id="（一）消费函数和消费倾向"><a href="#（一）消费函数和消费倾向" class="headerlink" title="（一）消费函数和消费倾向"></a>（一）消费函数和消费倾向</h4><p>消费是总需求中主要的和的最大的部分</p>
<p>消费需求也是决定均衡国民收入的所有因素中最重要的因素</p>
<ol>
<li>消费和消费函数</li>
</ol>
<ul>
<li>消费：一个国家或地区一定时期内居民个人或家庭为满足消费欲望而用于购买消费品和劳务的所有支出</li>
<li>消费函数：指消费支出与决定消费的各种因素之间的依存关系,收入与消费之间的这种数量关系就是消费函数，即凯恩斯认为，在收入和消费的关系方面，存在着一条基本的心理规律，即，随着人们收入的增加，他们二等消费也会增加，但是消费不如收入增加得多$\frac{dC}{dY}&gt;0,\frac{d^2C}{d^2Y}&lt;0$</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image.png" alt="alt text"></p>
<blockquote>
<p>影响居民个人或家庭消费的因素很多，如收入水平、消费品的价格水平、消费者个人的偏好、消费者对其未来收入的预期。甚至消费信贷以及利率水平等等，但其中最重要的无疑是居民个人或家庭的收入水平。因此，宏观经济学假定消费支出与人们收入水平存在着稳定的函数关系：$C=C(Y)$</p>
</blockquote>
<p>如果消费与收入之间存在线性关系，可以表示为$C=\alpha +\beta Y$</p>
<ul>
<li>$\alpha$作为一个常数，在宏观经济学被称为自发消费，其含义是，居民个人或家庭的消费中有一个相对稳定的部分，其变化是不受收入水平的影响。即使可支配收入为0时，消费者举债或者使用先前的储蓄也必须有的基本生活消费</li>
<li>$\beta Y$在宏观经济学中被称为引致消费(也就是可支配收入引起的消费)，是居民个人或家庭的消费中受收入水平影响的部分，其中$\beta$作为该函数的斜率，被称为边际消费倾向，其含义是增加单位可支配收入由于消费的比例</li>
</ul>
<ul>
<li>长期消费函数<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-2.png" alt="alt text"></li>
</ul>
<ol>
<li>平均消费倾向(APC)</li>
</ol>
<ul>
<li>任意一个收入水平消费支出占可支配收入的比例叫做平均消费倾向，其公式为$APC=\frac{C}{Y}$</li>
<li>平均消费倾向也可以理解为某一时期内总消费支出与总收入之比。一般来说，平均消费倾向是随收入增长而趋于下降的</li>
<li>其几何表示为消费函数曲线上相应点与原点连线的斜率<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-3.png" alt="alt text"></li>
<li>交点表示可支配收入全部用于消费</li>
</ul>
<ol>
<li>边际消费倾向(MPC)</li>
</ol>
<p>每增加一个单位收入中用于消费部分所占比例为边际消费倾向。其公式是</p>
<script type="math/tex; mode=display">MPC=\frac{dC}{dY}</script><p>其几何表示为，消费函数曲线上相应点切线的斜率。一般来说，边际消费倾向也是随收入增长而趋于下降的。其含义与上面提到的$\beta$含义是相同的</p>
<h4 id="（二）储蓄函数和储蓄倾向"><a href="#（二）储蓄函数和储蓄倾向" class="headerlink" title="（二）储蓄函数和储蓄倾向"></a>（二）储蓄函数和储蓄倾向</h4><ol>
<li>储蓄和储蓄函数</li>
</ol>
<ul>
<li>储蓄：收入中没有被消费的函数。储蓄的大小不仅可以反映消费量的大小，也可以在可支配收入既定情况下影响消费量</li>
<li>储蓄函数：指储蓄与决定储蓄的各种因素之间的依存关系</li>
<li>影响因素：收入水平、财富分配状况、消费习惯、社会保障体系的结构、利率水平等，但其中最重要的是居民个人或家庭的收入水平。因此，宏观经济学假定储蓄与人们收入水平存在着稳定的函数关系 。以S代表储蓄，Y代表收入，可以用公式表示为：$S=S(Y)$(满足条件：$\frac{dS}{dY}&gt;0,\frac{d^2S}{d^2Y}&gt;0$)</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-1.png" alt="alt text"></p>
<ul>
<li>Gini系数：灰色面积所占比例，在0和1之间。等于1时绝对不公平，等于0时绝对公平</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-4.png" alt="alt text"></p>
<ol>
<li>平均储蓄倾向</li>
</ol>
<p>平均储蓄倾向：任一收入水平储蓄所占的比率，其公式为：$APS=\frac{S}{Y}$</p>
<p>储蓄曲线上任意一点与原点连线的斜率，就是平均储蓄倾向</p>
<ol>
<li>边际储蓄倾向</li>
</ol>
<p>边际储蓄倾向：储蓄增量对相应的可支配收入增量的比率。其公式为：$MPS=\frac{dS}{dY}$</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-5.png" alt="alt text"></p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-6.png" alt="alt text"></p>
<h4 id="（三）消费函数和储蓄函数的关系"><a href="#（三）消费函数和储蓄函数的关系" class="headerlink" title="（三）消费函数和储蓄函数的关系"></a>（三）消费函数和储蓄函数的关系</h4><p>储蓄函数和消费函数、储蓄倾向和消费倾向是两组对偶的变量和概念</p>
<p>在收入既定的条件下，二者互为对放在总收入中的余量；或者说二者是互补的</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-7.png" alt="alt text"></p>
<ul>
<li>消费函数和储蓄函数互补，即二者之和与其相应的收入相等(在不考虑政府情况下)</li>
<li>当APC和MPC都随收入增加而递减时，APC&gt;MPC；当APS和MPS都随收入增加而递增时，APS&lt; MPS</li>
<li>APC和APS之和，MPC和MPS之和都恒等于1。也就是说消费甘薯和储蓄函数只要有一个被确定，那么另一个也会随之被确定</li>
</ul>
<h4 id="（五）影响消费的其他因素及其对相关政策效果的影响"><a href="#（五）影响消费的其他因素及其对相关政策效果的影响" class="headerlink" title="（五）影响消费的其他因素及其对相关政策效果的影响"></a>（五）影响消费的其他因素及其对相关政策效果的影响</h4><p>可支配收入是影响消费的最重要的因素，但是可支配收入变动并非是影响消费的全部因素。</p>
<ol>
<li>影响消费的其他因素</li>
</ol>
<p>（1）利率</p>
<ul>
<li>r增加S增加 替代效应，低收入群体</li>
<li><p>r减少S增加 收入效应，高收入群体(固定S)</p>
<ul>
<li>储蓄较多，选择将资金取出进行消费<blockquote>
<p>多数情况下替代效应影响较明显<br>（2）价格水平（价格水平的变动）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>P增加Y减少 如果C不变 $\beta$增加(APC增加)</p>
</li>
<li>P减少Y增加 如果C不变 $\beta$减少(APC减少)</li>
</ul>
<p>（3）收入分配的平均程度</p>
<ul>
<li>国民收入分配越平均，全国性平均消费倾向就越大</li>
<li>收入分配越不平均，全国性平均消费就会越小</li>
</ul>
<p>（4）预期</p>
<ul>
<li>人们可以运用所有可以得到的信息做出对未来消费的适当预期</li>
</ul>
<ol>
<li>影响消费的其他因素对相关政策效果的影响</li>
</ol>
<ul>
<li>实际资本存量</li>
<li>名义基础货币</li>
<li>公债数量</li>
</ul>
<h4 id="六-其他消费理论"><a href="#六-其他消费理论" class="headerlink" title="(六)其他消费理论"></a>(六)其他消费理论</h4><ol>
<li>现期收入假定下的消费函数理论</li>
</ol>
<p>（1）绝对收入假说：</p>
<p>（2）相对收入假说</p>
<p>消费者会根据自己过去的消费习惯以及周围人们消费水准 的影响来决定 自己的现期消费水平</p>
<ul>
<li>示范效应：消费者的消费行为会受周围人们消费水准的影响</li>
<li>攀比效应：低收入者消费向高收入者看齐</li>
<li>棘轮效应：顾及社会上的相对地位还有“爱面子的考虑”，导致消费水平的降低比较有限</li>
</ul>
<blockquote>
<p>不仅会受到收入影响，还会受到身边群体的影响</p>
</blockquote>
<ol>
<li>恒久收入假定下的消费函数理论 </li>
</ol>
<p>弗里德曼的消费函数理论：（一种前向预期的消费理论，不同于凯恩斯只着眼于当前可支配收入）</p>
<ul>
<li><p>恒久收入的含义：恒久收入是消费者可以预计到的长期可支配收入。与暂时性收入不同，恒久收入反映了消费者对未来收入的长期预期，而不是短期或者一次性的收入波动</p>
</li>
<li><p>消费者的消费支出主要由恒久可支配收入水平决定</p>
<script type="math/tex; mode=display">
Y_t^P=θ⋅Y_t+(1−θ)⋅Y_{t−1}^P</script></li>
<li>$Y_t$是当前可支配收入</li>
<li>$Y_{t-1}^p$是上一期可支配收入</li>
<li>$\theta$是一个权重系数，表示当前收入对恒久收入的影响程度 </li>
</ul>
<blockquote>
<p>当期收入增加并不一定会引起恒久收入的增加</p>
</blockquote>
<ul>
<li>根据这种理论，如果政府想通过增减税收来影响总需求，那么将是不可能完全奏效的，因为人们由于减税而增加的可支配收入并不会立即被全部用于增加消费。</li>
</ul>
<ol>
<li>生命周期假说的消费函数理论</li>
</ol>
<script type="math/tex; mode=display">
C=\alpha W_R+\beta Y_L</script><ul>
<li>$W_R$代表实际财富，$Y_L$是可支配工作收入</li>
<li><p>$\alpha$代表财富的边际消费倾向，即每年消费掉的财富比例；$\beta$代表可支配工作收入的边际消费倾向</p>
</li>
<li><p>生命周期消费函数理论与恒久收入消费函数理论的不同:侧重点不同，前者侧重于储蓄动机以及财富的作用，后者侧重个人的预测与计划</p>
</li>
<li>相同点：<ul>
<li>消费函数不仅限于与现期收入相联系</li>
<li>暂时和偶然的收入变化对消费倾向影响小</li>
<li>临时性税收政策对消费影响小 </li>
</ul>
</li>
</ul>
<h3 id="二、投资"><a href="#二、投资" class="headerlink" title="二、投资"></a>二、投资</h3><h4 id="（一）投资和资本边际效率"><a href="#（一）投资和资本边际效率" class="headerlink" title="（一）投资和资本边际效率"></a>（一）投资和资本边际效率</h4><ol>
<li>投资的经济学含义：实业投资与金融投资的区别(购买证券、土地在宏观经济学角度下不属于投资)：社会资本的形成(厂房、机器设备与存货、新住宅建设)</li>
</ol>
<ul>
<li>宏观经济学意义上的投资是实体经济层面上的投资，也就是社会资本的获得<blockquote>
<p>购买上市公司上市的第一支股票属于投资，因为企业会利用其购买社会资本</p>
</blockquote>
</li>
<li><p>投资的利益权衡：投资收益$\ge$投资成本</p>
</li>
<li><p>由于资本品的损耗造成的资本存量的减少称为折旧，为补偿或重置已消耗掉的资本进行的投资，称为重置投资</p>
</li>
<li>使资本存量出现增加的投资被定义为净投资</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-8.png" alt="alt text"></p>
<blockquote>
<p>一个国家固定资产一千亿，一年折旧掉80亿，政府投资200亿。年终资本存量为1120亿，净投资是120亿，总投资是200亿</p>
</blockquote>
<ol>
<li>资本边际效率：是一种贴现率，它能够正好使一项资本品在其使用期内各个预期收益的现值之和等于这项资本品的供给价格或重置成本</li>
</ol>
<blockquote>
<p>贴现：将未来的资金或收益折算为当前价值的过程，核心思想是未来的钱不如现在的钱值钱，因为现在的钱可以用于投资或消费从而产生额外的收益</p>
<ul>
<li>贴现率=资本边际效率=预期收益率</li>
</ul>
</blockquote>
<ul>
<li>包含资本边际效率（这里就是利率），的资本现值的公式:</li>
</ul>
<script type="math/tex; mode=display">
R_0=\frac{R_1}{1+r}+\frac{R_2}{(1+r)^2}+...+\frac{R_n}{(1+r)^n}+\frac{J}{(1+r)^n}</script><ul>
<li>$R_0$代表资本品的供给价格，也就是资本在不同时期预期收益的贴现值</li>
<li>$R_1…R_n$代表不同年份(或时期)的预期收益</li>
<li>J代表该项资本品在n年年末的报废价值</li>
<li>r代表利率，也就是贴现率，也就是资本边际效率<br>如果按照投资的原则，边际收益等于边际成本：资本边际效率=利率</li>
</ul>
<p>资本边际效率的曲线</p>
<ul>
<li><p>含义：一笔投资可选择的所有项目的集合</p>
<blockquote>
<p>预期收益率越高，投资量越小</p>
</blockquote>
</li>
<li><p>MEC曲线：表示在不同资本存量水平下，资本的边际效率如何变化。</p>
<ul>
<li>MEC：指 新增一单位资本 的预期收益率。它反映了企业对现有资本存量的预期回报率。</li>
</ul>
</li>
</ul>
<p>例如，一家工厂增加一台新机器，MEC 就是这台机器未来带来的预期收益与成本的比率。</p>
<ul>
<li>MEI曲线：表示在不同投资水平下，投资的边际效率如何变化。<ul>
<li>MEI：新增一单位投资 的预期收益率。它反映了企业对新增投资的预期回报率。</li>
</ul>
</li>
</ul>
<p>例如，企业决定增加投资购买新设备，MEI 就是这笔投资未来带来的预期收益与成本的比率。</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-9.png" alt="alt text"></p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-10.png" alt="alt text"></p>
<ul>
<li>投资是存在竞争的，预期收益率会降低</li>
<li>MEI会低于MEC的原因：投资是存在竞争的，投资会在竞争中增加。比如原有资本价值300万美元的机器需投资高于300万<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-11.png" alt="alt text"></li>
<li><p>向同一个领域追加投资会导致产品同质化，产品利润被压缩</p>
</li>
<li><p>利率成为了投资的天然屏障</p>
</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-12.png" alt="alt text"></p>
<ul>
<li>投资函数的二阶导数是不确定的</li>
<li>坐标系中利率为纵坐标，投资为横坐标。</li>
<li>遇到利率、价格水平、汇率水平时，横纵坐标的方向是反的</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-13.png" alt="alt text"></p>
<ul>
<li><p>投资系数一定是大于0的</p>
</li>
<li><p>比较静态分析：慢慢逼近显示的方法，保持自变量不变，参数发生变动</p>
</li>
<li><p>经济衰退降低利率可以使投资增加从而增加收入</p>
</li>
<li><p>两部门经济中政府投资是不会考虑利率的，对利率不敏感；国外部门进入也属于自主投资</p>
</li>
<li><p>延伸拓展：曲线的平移与旋转(比较静态分析)：投资函数常数项的变动，逐渐向现实情况逼近</p>
</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-14.png" alt="alt text"></p>
<blockquote>
<p>自主投资变化<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-15.png" alt="alt text"><br>投资系数变化。改革开放前计划经济，对利率极其不敏感，图像更陡</p>
</blockquote>
<ul>
<li>利率越低，投资越高，促进消费</li>
</ul>
<h4 id="四-托宾的q理论"><a href="#四-托宾的q理论" class="headerlink" title="(四)托宾的q理论"></a>(四)托宾的q理论</h4><ol>
<li>公式：<script type="math/tex; mode=display">
q=\frac{企业的股票市场价值}{新建造企业的成本(或重置成本)}</script></li>
<li>q小于1时，买旧企业比新建企业便宜，这时就不会有新投资。q大于1时，新建企业比购买旧企业更合算，所以会有新投资</li>
</ol>
<ul>
<li>优点：避免了投资的当前成本与未来收益的时间不一致问题</li>
<li>缺点：回避了股票市场价值的不正常和未来收益的不确定性<ul>
<li>只能说明个别企业的投资方式的选择，不能说明宏观投资问题<h3 id="三、政府购买"><a href="#三、政府购买" class="headerlink" title="三、政府购买"></a>三、政府购买</h3></li>
</ul>
</li>
</ul>
<ol>
<li><p>政府需求的构成（政府购买的内容）</p>
<ul>
<li>政府维持正常生活的消费需求</li>
<li>政府公共投资和专项投资的投资需求</li>
</ul>
</li>
<li><p>政府对社会总需求的影响</p>
</li>
</ol>
<ul>
<li>直接购买支出的影响：直接影响社会总需求</li>
<li>税收的影响：增加或减少企业和个人的收入，从而影响他们的投资需求和消费需求</li>
<li>转移支付的影响：同样通过增加企业或个人的收入，从而增加消费需求</li>
<li>制度和政策的影响：具体经济制度和经济政策(如农产品补贴制度、鼓励出口的关税政策)都会影响到社会的总需求<h3 id="四、净出口"><a href="#四、净出口" class="headerlink" title="四、净出口"></a>四、净出口</h3><h4 id="（一）国外需求的决定因素"><a href="#（一）国外需求的决定因素" class="headerlink" title="（一）国外需求的决定因素"></a>（一）国外需求的决定因素</h4></li>
</ul>
<p>基本是外生决定的因素</p>
<ol>
<li><p>国外需求的大小取决于决定的因素</p>
</li>
<li><p>国外需求的大小取决于消费倾向高低</p>
</li>
<li><p>国外需求的大小取决于国外的消费结构</p>
</li>
<li><p>国外需求的大小取决于本国出口商品的价格水平高低和产品的类型结构</p>
</li>
<li><p>汇率：本国货币贬值会导致出口的增加，价格便宜更具有竞争力</p>
</li>
<li><p>本国对外实际投资</p>
</li>
<li><p>国际贸易中的竞争程度</p>
</li>
<li><p>外国的贸易保护主义强弱</p>
</li>
</ol>
<h4 id="（二）净出口的决定"><a href="#（二）净出口的决定" class="headerlink" title="（二）净出口的决定"></a>（二）净出口的决定</h4><p>在开放经济中，本国对于国外的产出也有需求，所以，真正对本国总需求起作用的是本国的净出口</p>
<ol>
<li><p>净出口是本国出口额减去进口额之后的余额：NX=X-M(国外需求会被本国对外国产品和服务的需求抵消一部分升=甚至全部)</p>
</li>
<li><p>宏观经济分析往往以国内需求为内生变量，本国对外国产品的需求越大，净出口相应地会减小，除非国外需求非常大</p>
</li>
<li><p>进口倾向M/Y与边际进口倾向$\Delta M/Y$(进口倾向取决于国民收入与消费倾向，边际进口取向一定在0和\beta之间)</p>
</li>
</ol>
<h2 id="第三节-货币需求和货币供给"><a href="#第三节-货币需求和货币供给" class="headerlink" title="第三节 货币需求和货币供给"></a>第三节 货币需求和货币供给</h2><h3 id="一、货币需求（83-87）"><a href="#一、货币需求（83-87）" class="headerlink" title="一、货币需求（83~87）"></a>一、货币需求（83~87）</h3><p>凯恩斯认为，由于货币对于不确定的经济环境具有最大的适应性和灵活性，所以人们对货币具有需求</p>
<p>货币需求是指人们出于各种目的而愿意持有的货币数量(包含已经持有的货币数量)</p>
<h4 id="（一）货币需求的动机"><a href="#（一）货币需求的动机" class="headerlink" title="（一）货币需求的动机"></a>（一）货币需求的动机</h4><ul>
<li>交易动机的货币需求：企业或个人为了进行正常的交易活动而持有货币的动机</li>
<li>预防动机的货币需求：为预防意外支出而持有一部分货币的动机，与收入成正比<ul>
<li>第一类货币需求：交易动机的货币需求+预防动机的货币需求，主要取决于收入水平<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-16.png" alt="alt text"></li>
</ul>
</li>
<li><p>投机动机的货币需求：指人们为了抓住有利的购买有价证券的机会而持有一部分货币的动机，等待合适的购买时机。投机动机的货币需求与利率成反比</p>
<ul>
<li>利率下降到一定程度变为水平线，对货币的需求趋近于无穷大，主要取决于利率<blockquote>
<p>投机动机的货币需求是符合低买高卖的需求<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-18.png" alt="alt text"></p>
<h4 id="（二）流动性陷阱-凯恩斯陷阱"><a href="#（二）流动性陷阱-凯恩斯陷阱" class="headerlink" title="（二）流动性陷阱(凯恩斯陷阱)"></a>（二）流动性陷阱(凯恩斯陷阱)</h4></blockquote>
</li>
</ul>
</li>
<li><p>流动性偏好：人们宁肯以牺牲利息收入二储存不生息的货币来保持财富的心理倾向</p>
</li>
</ul>
<p>当利率下降到<strong>社会公认的最低点时</strong>，人们认为债券价格将会达到最高，于是全部抛出手中的债券而持有货币。这时<strong>无论有多少货币，人们都愿意拿在手里，货币的需求变得极大</strong>。<br>这种情况就是流动性陷阱</p>
<ul>
<li>流动性通常用来指代现金货币<ul>
<li>$M_0$=现金</li>
<li>$M_1=M_0+企业短期存款$</li>
<li>$M_2=M_1+企业长期存款+居民的储蓄存款$</li>
<li>$M_3=M_2+短期债券$</li>
<li>$M_4=M_3+长期债券$</li>
<li>$M_5=M_4+股票等金融资产$<blockquote>
<p>流动性逐渐减小</p>
</blockquote>
</li>
</ul>
</li>
<li>经济衰退越严重，越容易出现流动性陷阱</li>
<li>货币政策是有局限的，因为调整利率不一定会使投资有效增加，利率政策是有极限的，需要用财政政策解决<br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-19.png" alt="alt text"></li>
</ul>
<h4 id="（三）货币需求函数"><a href="#（三）货币需求函数" class="headerlink" title="（三）货币需求函数"></a>（三）货币需求函数</h4><p>对货币的总需求是交易性需求、预防性需求和投机性需求的总和。</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-20.png" alt="alt text"></p>
<ul>
<li>第一类货币需求为常数(不会随着利率的变化而变化)</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-21.png" alt="alt text"></p>
<ul>
<li><p>L1,L2都是实际货币需求(衡量实际购买力)，即具有不变购买力的实际货币需求</p>
<blockquote>
<p>名义货币是不管货币购买力如何而仅计算其票面值的货币量。把名义货币量折算成具有不变购买力的实际货币量，必须用价格指数加以调整，如用M,m,P依次代表名义货币量、实际货币量和价格指数，则实际货币量=名义货币量/价格指数</p>
<p>10年前3000元与3000元的名义货币量不变，实际货币量产生变化</p>
<h3 id="二、货币供给（224-225）"><a href="#二、货币供给（224-225）" class="headerlink" title="二、货币供给（224~225）"></a>二、货币供给（224~225）</h3></blockquote>
</li>
<li><p>货币供给是一个存量概念，它是一个国家在某一时点上所保持的不属于政府和银行的所有的硬币、纸币和银行存款的总和</p>
</li>
</ul>
<ol>
<li><p>现金货币：由一个国家中央银行发行的货币</p>
</li>
<li><p>存款货币：由一个国家商业银行经营活动创造的货币</p>
</li>
</ol>
<blockquote>
<p>本身是一个外生变量，与利率大小无关，受国家调控</p>
</blockquote>
<ol>
<li>货币乘数</li>
</ol>
<p>如果用M表示货币供给，H表示中央银行发行的现金，R表示准备金率，则</p>
<script type="math/tex; mode=display">
M=\frac{H}{R}</script><p>完整的货币(政策)乘数的计算公式是：</p>
<script type="math/tex; mode=display">
k=\frac{R_c+1}{R_d+R_e+R_c}</script><p>其中$R_d,R_e,R_c$分别代表法定准备金率，超额准备金率和现金在存款中的比率。而货币(政策)乘数的基本计算公式是货币供给/基础货币。货币供给等于通货(即流通中的现金)和活期存款的总和；而基础货币等于通货和准备金的总和</p>
<h3 id="三、货币市场均衡（87-89）"><a href="#三、货币市场均衡（87-89）" class="headerlink" title="三、货币市场均衡（87~89）"></a>三、货币市场均衡（87~89）</h3><h4 id="（一）古典货币市场：古典经济学的利率决定观点"><a href="#（一）古典货币市场：古典经济学的利率决定观点" class="headerlink" title="（一）古典货币市场：古典经济学的利率决定观点"></a>（一）古典货币市场：古典经济学的利率决定观点</h4><ol>
<li>古典的利率由资金借款市场上的供求均衡决定，而且资金的供给(储蓄)和需求(投资)都是内生的</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-22.png" alt="alt text"></p>
<ol>
<li>此外，利率也会对资金的供给(储蓄)和需求(投资)进行调节</li>
</ol>
<h4 id="（二）现代货币市场：凯恩斯经济学的利率"><a href="#（二）现代货币市场：凯恩斯经济学的利率" class="headerlink" title="（二）现代货币市场：凯恩斯经济学的利率"></a>（二）现代货币市场：凯恩斯经济学的利率</h4><ol>
<li><p>利率由货币市场的均衡来决定，当货币供给等于货币需求的时候，货币市场达到均衡</p>
</li>
<li><p>只有货币需求是内生的</p>
</li>
</ol>
<ul>
<li>由经济体系内部的的因素决定，如收入、利率等</li>
</ul>
<ol>
<li>货币供给是外生的（央行供给货币与利率无关），其大小与利率无关</li>
</ol>
<ul>
<li>由中央银行决定，不受利率或者其他经济变量的影响</li>
</ul>
<blockquote>
<p>在现代货币市场中货币供求的均衡完全是由政府控制的。政府可以根据自己的目的确定货币供应量的多少，并根据货币供应量的多少来调控市场的利率水平</p>
</blockquote>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-23.png" alt="alt text"></p>
<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="第一节-均衡国民收入的决定"><a href="#第一节-均衡国民收入的决定" class="headerlink" title="第一节 均衡国民收入的决定"></a>第一节 均衡国民收入的决定</h2><h3 id="（一）一般所指的国民收入"><a href="#（一）一般所指的国民收入" class="headerlink" title="（一）一般所指的国民收入"></a>（一）一般所指的国民收入</h3><p>国民收入在宏观经济学中是个泛指的概念：GDP、GNP、NNP、NI、PI都可以看作不同条件下的国民收入</p>
<p>但在通常情况下，国民收入一般指GDP</p>
<h3 id="（二）国民收入和国民财富的生产"><a href="#（二）国民收入和国民财富的生产" class="headerlink" title="（二）国民收入和国民财富的生产"></a>（二）国民收入和国民财富的生产</h3><p>国民收入和国民财富的含义既有一致性，也有区别。其区别主要在于</p>
<ul>
<li>国民财富涉及<strong>存量</strong>角度，即涉及特定<strong>时点</strong>上的(已有商品和服务价值)数量</li>
<li>国民收入涉及<strong>流量</strong>角度，即涉及特定<strong>时期</strong>内的(发生价值)数量</li>
</ul>
<h3 id="（三）国民收入和国民财富的分配"><a href="#（三）国民收入和国民财富的分配" class="headerlink" title="（三）国民收入和国民财富的分配"></a>（三）国民收入和国民财富的分配</h3><p>基本经济制度的作用：决定<strong>国民收入和财富分配</strong>的<strong>基本立场和倾向</strong></p>
<p><strong>1. 初次分配和再分配制度的作用:</strong>国民收入和财富初次分配按<strong>要素</strong>分配，再分配则服从于政府的<strong>利益倾向和政治需要</strong><br><strong>2.相应政策的影响：</strong>这是国民收入和财富再分配的一种具体形式</p>
<h3 id="四-市场经济条件下均衡国民收入的决定原理：供给决定"><a href="#四-市场经济条件下均衡国民收入的决定原理：供给决定" class="headerlink" title="(四)市场经济条件下均衡国民收入的决定原理：供给决定"></a>(四)市场经济条件下均衡国民收入的决定原理：供给决定</h3><p><strong>均衡国民收入</strong>：是指总需求和总供给处于相等(均衡)状态时的国民收入</p>
<p>宏观经济学就是要研究和解决怎样使总需求适应总供给，或者怎样使总供给得到与总需求相适应的增长</p>
<p>宏观经济能否顺利达到均衡，不仅取决于总供给的数量匹配，也取决于宏观经济在各个环节上是否能够顺利进行。为此，就应该了解宏观经济的循环流程</p>
<ul>
<li>封闭经济下宏观经济运行的循环流程图：简略表明三个市场(产品与服务市场、货币市场、劳动市场)和三个部门(企业家庭和政府)间的关系<ul>
<li>事前的均衡国民收入是意愿的(或计划的)和未实现的</li>
<li>事后的均衡国民收入是已经实现的</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-29.png" alt="alt text"></p>
<h3 id="二、均衡国民收入决定的基本方向"><a href="#二、均衡国民收入决定的基本方向" class="headerlink" title="二、均衡国民收入决定的基本方向"></a>二、均衡国民收入决定的基本方向</h3><h4 id="（一）需求充分条件下的基本方向：均衡国民收入决定于供给"><a href="#（一）需求充分条件下的基本方向：均衡国民收入决定于供给" class="headerlink" title="（一）需求充分条件下的基本方向：均衡国民收入决定于供给"></a>（一）需求充分条件下的基本方向：均衡国民收入决定于供给</h4><ul>
<li>供给决定需求：”萨伊定理”</li>
</ul>
<ol>
<li><p>成立条件：市场上的供给普遍不足</p>
</li>
<li><p>含义：<strong>供给总是会创造出它自身的需求</strong>。这意味着只要努力增加供给，需求自然就会增加，均衡国民收入也会增加，经济不会出现问题</p>
</li>
<li><p>萨伊定律是信奉经济自由主义的古典经济学关于均衡国民收入决定的核心观点</p>
</li>
</ol>
<ul>
<li>萨伊定律的合理性和局限性，取决于其适应条件及其有限性</li>
<li>如果不讲条件地普遍运用，就会发生错误<h4 id="（二）共计充分条件下的基本方向：均衡国民收入决定于需求"><a href="#（二）共计充分条件下的基本方向：均衡国民收入决定于需求" class="headerlink" title="（二）共计充分条件下的基本方向：均衡国民收入决定于需求"></a>（二）共计充分条件下的基本方向：均衡国民收入决定于需求</h4></li>
</ul>
<ol>
<li><p>经济萧条时失衡的特征：供给相对过剩，需求相对不足</p>
</li>
<li><p>关键在于有效总需求的水平</p>
</li>
<li><p>凯恩斯的观点：强调短期(短期均衡国民收入决定理论)</p>
<h4 id="（三）一般观点：均衡国民收入由总需求和总供给共同决定"><a href="#（三）一般观点：均衡国民收入由总需求和总供给共同决定" class="headerlink" title="（三）一般观点：均衡国民收入由总需求和总供给共同决定"></a>（三）一般观点：均衡国民收入由总需求和总供给共同决定</h4></li>
<li><p>新凯恩斯主义的观点是折中的，兼顾长期</p>
</li>
<li><p>短期内主要由<strong>有效需求水平</strong>决定均衡国民收入水平</p>
</li>
<li><p>长期内主要由<strong>供给水平</strong>决定均衡国民收入水平(强调萨伊定律在长期内的有效性)</p>
</li>
</ol>
<h3 id="三、两部门经济：有效需求的原理和框架"><a href="#三、两部门经济：有效需求的原理和框架" class="headerlink" title="三、两部门经济：有效需求的原理和框架"></a>三、两部门经济：有效需求的原理和框架</h3><ul>
<li>总需求(支出)：家庭的消费和企业的投资(向市场需求)</li>
<li>总供给(收入)：家庭的储蓄和企业的生产(给市场供给)</li>
</ul>
<blockquote>
<p>总需求/总供给属于事前概念：家庭和企业对市场有需求或需要向市场供给；支出和收入属于事后概念：为了向市场需求或供给需要进行存在支出和收入</p>
</blockquote>
<h4 id="（一）有效需求的原理"><a href="#（一）有效需求的原理" class="headerlink" title="（一）有效需求的原理"></a>（一）有效需求的原理</h4><ol>
<li><p>在总供给均衡决定均衡国民收入原理基础上，强调短期内的供给过剩和需求不足(外生条件，也就是不受模型本身影响)</p>
</li>
<li><p>强调总需求(有效需求)的决定性作用</p>
</li>
<li><p>总需求(有效需求)由四个部分组成：消费需求，投资需求，国外需求，政府需求</p>
</li>
</ol>
<h4 id="（二）基本假设-两个部门一个市场"><a href="#（二）基本假设-两个部门一个市场" class="headerlink" title="（二）基本假设(两个部门一个市场)"></a>（二）基本假设(两个部门一个市场)</h4><ol>
<li><p>经济中只有居民和企业两个部门</p>
</li>
<li><p>社会总能够以不变的价格提供适应需求的产品与服务；<strong>凯恩斯定律</strong>：有效需求总能得到相应的供给，而且社会需求的变动只会引起产量和收入的变动，不会引起价格变动</p>
</li>
<li><p>社会上没有折旧和公司未分配利润</p>
</li>
<li><p>只考虑短期—强调总需求的决定性作用</p>
</li>
</ol>
<h4 id="（三）凯恩斯主义交叉图"><a href="#（三）凯恩斯主义交叉图" class="headerlink" title="（三）凯恩斯主义交叉图"></a>（三）凯恩斯主义交叉图</h4><p>两部门经济中，均衡国民收入的决定原理可以表示为公式：Y=C+I</p>
<ul>
<li>这个公式可以表明均衡国民收入的决定原理，也可以表明期望(计划)取得的均衡国民收入条件</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-24.png" alt="alt text"></p>
<ul>
<li>I是常数，总需求的函数相当于消费函数的平移</li>
<li>实际产出=计划需求(支出)+非计划存货投资（可正可负）</li>
</ul>
<blockquote>
<p>宏观经济学中，提到Y，既表示总产出也表示总收入</p>
<h4 id="（四）投资等于储蓄"><a href="#（四）投资等于储蓄" class="headerlink" title="（四）投资等于储蓄"></a>（四）投资等于储蓄</h4><ul>
<li>根据两部门均衡国民收入决定条件(公式)可以推导出其另一种表达形式，即投资等于储蓄的均衡条件(公式)</li>
</ul>
</blockquote>
<script type="math/tex; mode=display">
\because E=C+I,Y=C+S</script><script type="math/tex; mode=display">
\ S=I</script><ul>
<li>这里需要注意：计划的均衡条件与已经实现的均衡结果(恒等式)的区别</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-25.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-26.png" alt="alt text"></p>
<blockquote>
<p>I+G=S+T 经济学含义不明确，进行移项。增加政府财政赤字可以缓解经济衰退</p>
</blockquote>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-27.png" alt="alt text"></p>
<blockquote>
<p>贸易顺差可以有效解决经济衰退的问题</p>
</blockquote>
<h2 id="第二节-影响需求的重要机制-乘数"><a href="#第二节-影响需求的重要机制-乘数" class="headerlink" title="第二节 影响需求的重要机制:乘数"></a>第二节 影响需求的重要机制:乘数</h2><ul>
<li>乘数本身可以看作是一个放大系数，与初始变动量结合就可以得到总收入的变化<h3 id="一、支出乘数"><a href="#一、支出乘数" class="headerlink" title="一、支出乘数"></a>一、支出乘数</h3></li>
</ul>
<ol>
<li><p>乘数是凯恩斯主义经济学的重要内容</p>
</li>
<li><p>乘数是影响需求的重要机制(投资乘数+政府相关的乘数)</p>
</li>
<li><p>乘数是凯恩斯主义有效需求理论的有力支撑点之一</p>
</li>
</ol>
<h3 id="二、投资乘数和乘数原理"><a href="#二、投资乘数和乘数原理" class="headerlink" title="二、投资乘数和乘数原理"></a>二、投资乘数和乘数原理</h3><p>投资乘数：投资乘数就是收入变化量与带来这个变化的投资支出变化量的比率$\frac{\Delta Y}{\Delta I}$</p>
<p>根据两部门经济的决定条件(假定有关函数是线性的)：Y=C+I($Y=\alpha + \beta Y$)</p>
<p>均衡国民收入决定的条件就是：$Y=\frac{\alpha + I}{1-\beta}$</p>
<p>推导出的投资乘数是$k_i=\frac1{1-\beta}$</p>
<ul>
<li>单位投资变化引起的总产出水平的变化</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-28.png" alt="alt text"></p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-30.png" alt="alt text"></p>
<h4 id="三、政府相关的乘数"><a href="#三、政府相关的乘数" class="headerlink" title="三、政府相关的乘数"></a>三、政府相关的乘数</h4><p>涉及三部门和四部门经济中的乘数，主要是Y=C+I+G </p>
<p>其中$C=\alpha + \beta Y_d=\alpha+\beta (Y-T)$</p>
<p>则$Y=\alpha + \beta (Y-T)+I+G$</p>
<script type="math/tex; mode=display">
Y=(\alpha + I +G-\beta T)/(1-\beta)</script><p>$k_c=k_I=1/(1-\beta)$</p>
<h5 id="一-政府购买乘数"><a href="#一-政府购买乘数" class="headerlink" title="(一)政府购买乘数"></a>(一)政府购买乘数</h5><p>政府购买成熟的含义与推导</p>
<script type="math/tex; mode=display">
k_G=\frac{\Delta Y}{\Delta G}=\frac{\Delta Y}{\Delta G}=\frac{1}{1-\beta}</script><h5 id="（二）税收乘数"><a href="#（二）税收乘数" class="headerlink" title="（二）税收乘数"></a>（二）税收乘数</h5><p>税收乘数的含义与推导</p>
<script type="math/tex; mode=display">
k_T=\frac{\Delta Y}{\Delta T}=\frac{-\beta}{1-\beta}</script><h5 id="（三）政府转移乘数"><a href="#（三）政府转移乘数" class="headerlink" title="（三）政府转移乘数"></a>（三）政府转移乘数</h5><p>政府转移支付乘数的含义与推导</p>
<p>Y=C+I+G 其中$C=\alpha + \beta(Y-T+T_{tr})$</p>
<script type="math/tex; mode=display">
Y=(\alpha +I- \beta T+\beta T_{tr})/(1-\beta)</script><script type="math/tex; mode=display">
k_{tr}=\frac{\Delta Y}{\Delta T_{tr}}=\frac{\beta}{1-\beta}</script><h5 id="四-平衡预算乘数"><a href="#四-平衡预算乘数" class="headerlink" title="(四)平衡预算乘数"></a>(四)平衡预算乘数</h5><ul>
<li>含义：指正度支出和税后同时增加或减少相同金额时，国民收入的变化量与政府支出(或税收)变化量的比值</li>
</ul>
<p><strong>平衡预算乘数</strong>（Balanced Budget Multiplier）是宏观经济学中的一个概念，用于描述在政府预算保持平衡（即政府支出和税收同时增加或减少相同金额）的情况下，国民收入的变化情况。理解平衡预算乘数的关键在于分析政府支出和税收对经济的综合影响。</p>
<h3 id="平衡预算乘数的定义："><a href="#平衡预算乘数的定义：" class="headerlink" title="平衡预算乘数的定义："></a>平衡预算乘数的定义：</h3><p>平衡预算乘数是指政府支出和税收同时增加（或减少）相同金额时，国民收入的变化量与政府支出（或税收）变化量的比值。在简单凯恩斯模型中，平衡预算乘数通常等于1。</p>
<h3 id="平衡预算乘数的推导："><a href="#平衡预算乘数的推导：" class="headerlink" title="平衡预算乘数的推导："></a>平衡预算乘数的推导：</h3><ol>
<li><p><strong>政府支出乘数</strong>：</p>
<ul>
<li>政府支出增加会直接增加总需求，进而通过乘数效应放大对国民收入的影响。政府支出乘数$ k_G $通常大于1，具体取决于边际消费倾向（MPC）。</li>
<li>公式：$ k_G = \frac{1}{1 - MPC} $</li>
</ul>
</li>
<li><p><strong>税收乘数</strong>：</p>
<ul>
<li>税收增加会减少居民的可支配收入，从而减少消费和总需求。税收乘数（( k_T )）通常为负，且绝对值小于政府支出乘数。</li>
<li>公式：$ k_T = -\frac{MPC}{1 - MPC} $</li>
</ul>
</li>
<li><p><strong>平衡预算乘数</strong>：</p>
<ul>
<li>当政府支出和税收同时增加相同金额时，国民收入的变化是政府支出乘数和税收乘数的综合效果。</li>
<li>公式：$ k_{BB} = k_G + k_T = \frac{1}{1 - MPC} - \frac{MPC}{1 - MPC} = 1 $</li>
</ul>
</li>
</ol>
<h3 id="平衡预算乘数的经济意义："><a href="#平衡预算乘数的经济意义：" class="headerlink" title="平衡预算乘数的经济意义："></a>平衡预算乘数的经济意义：</h3><ul>
<li><strong>乘数为1</strong>：意味着政府支出和税收同时增加1元，国民收入也会增加1元。这是因为政府支出的增加直接刺激了总需求，而税收的增加虽然抑制了部分消费，但整体效果仍然是正向的。</li>
<li><strong>预算平衡</strong>：政府支出和税收的变化不会改变财政赤字或盈余，但会对经济产生扩张或收缩的影响。</li>
</ul>
<h3 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h3><p>假设政府增加支出100亿元，同时增加税收100亿元（保持预算平衡），且边际消费倾向（MPC）为0.8。</p>
<ol>
<li><p><strong>政府支出增加100亿元</strong>：</p>
<ul>
<li>通过乘数效应，国民收入增加：$100 \times \frac{1}{1 - 0.8} = 500 $亿元。</li>
</ul>
</li>
<li><p><strong>税收增加100亿元</strong>：</p>
<ul>
<li>通过税收乘数，国民收入减少：$100 \times \frac{0.8}{1 - 0.8} = 400 $ 亿元。</li>
</ul>
</li>
<li><p><strong>净效应</strong>：</p>
<ul>
<li>国民收入净增加：$ 500 - 400 = 100 $ 亿元。</li>
<li>平衡预算乘数为1。</li>
</ul>
</li>
</ol>
<h5 id="五-对外贸易乘数"><a href="#五-对外贸易乘数" class="headerlink" title="(五)对外贸易乘数"></a>(五)对外贸易乘数</h5><p>对外贸易乘数的含义与推导</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-31.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-32.png" alt="alt text"></p>
<h1 id="第十一章-国民收入的决定-IS-LM模型"><a href="#第十一章-国民收入的决定-IS-LM模型" class="headerlink" title="第十一章 国民收入的决定 IS-LM模型"></a>第十一章 国民收入的决定 IS-LM模型</h1><h2 id="第一节-产品市场的均衡：IS曲线"><a href="#第一节-产品市场的均衡：IS曲线" class="headerlink" title="第一节 产品市场的均衡：IS曲线"></a>第一节 产品市场的均衡：IS曲线</h2><ul>
<li>IS-LM模型强调<strong>短期</strong>，假定物价水平既定不变</li>
<li>IS-LM模型体现了凯恩斯强调总需求决定均衡国民收入的思想，长期以来它都被经济学界看作是凯恩斯有效需求理论的典型代表</li>
<li>IS-LM模型涉及产品市场与货币市场</li>
</ul>
<h3 id="一、IS曲线的前提条件：产品市场的均衡"><a href="#一、IS曲线的前提条件：产品市场的均衡" class="headerlink" title="一、IS曲线的前提条件：产品市场的均衡"></a>一、IS曲线的前提条件：产品市场的均衡</h3><ul>
<li>含义：当产品市场达到均衡的时候国民收入(y)和利率(r)之间的关系曲线 </li>
</ul>
<p>IS曲线是以产品市场的均衡为前提的</p>
<p>价格对于经济的作用被忽略(这是符合凯恩斯理论原意的)</p>
<blockquote>
<p>IS曲线不再是投资是常数的理想情况</p>
<h3 id="二、IS曲线的含义和推导"><a href="#二、IS曲线的含义和推导" class="headerlink" title="二、IS曲线的含义和推导"></a>二、IS曲线的含义和推导</h3><h4 id="（一）IS曲线的推导：两种方法"><a href="#（一）IS曲线的推导：两种方法" class="headerlink" title="（一）IS曲线的推导：两种方法"></a>（一）IS曲线的推导：两种方法</h4></blockquote>
<ol>
<li>两部门IS曲线的数理推导<script type="math/tex; mode=display">
I=S</script><script type="math/tex; mode=display">
I=e-dr</script></li>
</ol>
<p>$S=-\alpha + (1-\beta)Y$</p>
<script type="math/tex; mode=display">
r=\frac{\alpha+e}{d}-\frac{1-\beta}{d}Y</script><script type="math/tex; mode=display">
A=\frac{\alpha+e}{d},B=\frac{1-\beta}{d}</script><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-33.png" alt="alt text"></p>
<ol>
<li>IS曲线的几何推导</li>
</ol>
<ul>
<li>利率-投资-&gt;投资-储蓄-&gt;储蓄-收入-&gt;利率-收入</li>
<li>r-&gt;I-&gt;s-&gt;Y</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-34.png" alt="alt text"></p>
<h4 id="（二）IS曲线的经济含义"><a href="#（二）IS曲线的经济含义" class="headerlink" title="（二）IS曲线的经济含义"></a>（二）IS曲线的经济含义</h4><ol>
<li><p>IS曲线是一条描述<strong>产品市场</strong>达到宏观均衡即I=S时，<strong>总产出与利率</strong>之间关系的曲线</p>
</li>
<li><p>在产品市场上，总产出与利率之间存在着反向变化的关系，即利率提高时总产出水平趋于减少，利率降低时总产出水平趋于增加</p>
<blockquote>
<p>改变中间变量会使预期变化受到影响</p>
</blockquote>
</li>
<li><p>处于IS曲线上的任何点位表示$I = S$,即产品市场实现了宏观均衡。反之，偏离IS曲线的任何点位都表示$I \neq S$,即产品市场没有实现宏观均衡。如果某一点位处于IS曲线右边，表示$ I &lt; S $,即现行的利率水平过高，从而导致投资规模小于储蓄规模。如果某一点位处于IS曲线左边，表示$ I &gt; S $,即现行的利率水平过低，从而导致投资规模大于储蓄规模。</p>
</li>
</ol>
<h3 id="三、IS曲线的斜率及其变动"><a href="#三、IS曲线的斜率及其变动" class="headerlink" title="三、IS曲线的斜率及其变动"></a>三、IS曲线的斜率及其变动</h3><h4 id="（一）IS曲线的斜率"><a href="#（一）IS曲线的斜率" class="headerlink" title="（一）IS曲线的斜率"></a>（一）IS曲线的斜率</h4><script type="math/tex; mode=display">
r=\frac{\alpha+e}{d}-\frac{1-\beta}{d}Y</script><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-35.png" alt="alt text"></p>
<ul>
<li>如果d发生变动，旋转和平移会同时发生，旋转效果更加明显</li>
<li>d越大，表示投资对利率越敏感，当投资对利率较为敏感的时候，利率较小的变动就会引起较大的投资变动，从而引起收入较大的变动，IS曲线越平缓<h4 id="（二）IS曲线的变动"><a href="#（二）IS曲线的变动" class="headerlink" title="（二）IS曲线的变动"></a>（二）IS曲线的变动</h4></li>
</ul>
<ol>
<li>投资变化引起的IS曲线变动(图解)</li>
</ol>
<p>投资函数I=1250-250r变动I=1500-250r</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-36.png" alt="alt text"></p>
<ol>
<li>储蓄变化引起的IS曲线变动(图解)</li>
</ol>
<p>储蓄函数S=-500-100r变动S=-250-100r</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-37.png" alt="alt text"></p>
<ol>
<li><p>消费变化引起的IS曲线变动</p>
</li>
<li><p>政府支出引起的IS曲线变动</p>
</li>
</ol>
<script type="math/tex; mode=display">
\Delta Y=K_G\Delta G</script><ul>
<li>G,T变化属于财政政策。</li>
<li>政府支出增加属于扩张性财政政策</li>
</ul>
<ol>
<li>税收变动引起的IS曲线变动<script type="math/tex; mode=display">
\Delta Y=-K_T\Delta T</script></li>
</ol>
<ul>
<li>政府税收增加时，属于紧缩性财政政策</li>
</ul>
<ol>
<li><p>政府转移支付变动引起的IS曲线变动</p>
</li>
<li><p>国外需求引起的IS曲线变动</p>
</li>
</ol>
<h2 id="第二节-货币市场的均衡：LM曲线"><a href="#第二节-货币市场的均衡：LM曲线" class="headerlink" title="第二节 货币市场的均衡：LM曲线"></a>第二节 货币市场的均衡：LM曲线</h2><h3 id="一、LM曲线的含义和推导"><a href="#一、LM曲线的含义和推导" class="headerlink" title="一、LM曲线的含义和推导"></a>一、LM曲线的含义和推导</h3><ul>
<li>LM曲线表示满足货币市场均衡条件下(<strong>货币需求=货币供给</strong>)的收入y与利率r的关系<h4 id="（一）LM曲线的推导"><a href="#（一）LM曲线的推导" class="headerlink" title="（一）LM曲线的推导"></a>（一）LM曲线的推导</h4></li>
</ul>
<p>L=M</p>
<p>L=kY-hr</p>
<p>用P代表价格总水平则实际货币供应量M与名义货币供应量m为M=m/P或m=PM</p>
<p>如果P=1，则有</p>
<p>M=m</p>
<p>整理得到</p>
<script type="math/tex; mode=display">
r=-\frac{M}{h}+\frac{k}{h}Y</script><p>若令$-\frac{M}{h}=E,\frac{k}{h}=F$，则有r=E+FY</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-38.png" alt="alt text"></p>
<h4 id="二-从货币市场均衡角度推导LM曲线"><a href="#二-从货币市场均衡角度推导LM曲线" class="headerlink" title="(二)从货币市场均衡角度推导LM曲线"></a>(二)从货币市场均衡角度推导LM曲线</h4><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-39.png" alt="alt text"></p>
<h4 id="（三）LM曲线的经济含义"><a href="#（三）LM曲线的经济含义" class="headerlink" title="（三）LM曲线的经济含义"></a>（三）LM曲线的经济含义</h4><ol>
<li><p>LM曲线是一条描述<strong>货币市场</strong>达到宏观均衡即L=M时，总产出与利率之间关系的曲线</p>
</li>
<li><p>在货币市场上，总产出与利率之间存在着正向变化的关系，即利率提高时总产出水平趋于增加，利率降低时总产出水平趋于减少 </p>
</li>
<li><p>处于LM曲线上的任何点位都表示L=M,即货币市场实现了宏观均衡。反之,偏离LM曲线的任何点位都表示L≠M,即货币市场没有实现宏观均衡。如果某一点位处于LM曲线的右边,表示L&gt;M,即现行的利率水平过低,从而导致货币需求大于货币供应。如果某一点位处于LM曲线的左边,表示L&lt;M,即现行的利率水平过高,从而导致货币需求小于货币供应。</p>
</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-40.png" alt="alt text"></p>
<h3 id="二、LM曲线的斜率和变动"><a href="#二、LM曲线的斜率和变动" class="headerlink" title="二、LM曲线的斜率和变动"></a>二、LM曲线的斜率和变动</h3><h4 id="（一）LM曲线的斜率"><a href="#（一）LM曲线的斜率" class="headerlink" title="（一）LM曲线的斜率"></a>（一）LM曲线的斜率</h4><script type="math/tex; mode=display">
r=-\frac{M}{h}+\frac{k}{h}Y</script><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-42.png" alt="alt text"></p>
<h3 id="（二）LM曲线上的三个区域"><a href="#（二）LM曲线上的三个区域" class="headerlink" title="（二）LM曲线上的三个区域"></a>（二）LM曲线上的三个区域</h3><ul>
<li>水平的“凯恩斯区域”代表流动性陷阱</li>
<li>垂直的古典区域代表完全没有货币投机需求的状况</li>
<li>正斜率的中间区域代表经济的正常情况</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-41.png" alt="alt text"></p>
<h3 id="（三）投机需求变动引起的LM曲线变动：反方向移动"><a href="#（三）投机需求变动引起的LM曲线变动：反方向移动" class="headerlink" title="（三）投机需求变动引起的LM曲线变动：反方向移动"></a>（三）投机需求变动引起的LM曲线变动：反方向移动</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-43.png" alt="alt text"></p>
<h3 id="（四）交易需求变动引起的LM曲线变动：同方向移动"><a href="#（四）交易需求变动引起的LM曲线变动：同方向移动" class="headerlink" title="（四）交易需求变动引起的LM曲线变动：同方向移动"></a>（四）交易需求变动引起的LM曲线变动：同方向移动</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-44.png" alt="alt text"></p>
<h3 id="（五）实际货币供给量变动引起的LM曲线变动"><a href="#（五）实际货币供给量变动引起的LM曲线变动" class="headerlink" title="（五）实际货币供给量变动引起的LM曲线变动"></a>（五）实际货币供给量变动引起的LM曲线变动</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-45.png" alt="alt text"></p>
<h2 id="第三节-产品市场和货币市场的共同均衡：IS-LM模型"><a href="#第三节-产品市场和货币市场的共同均衡：IS-LM模型" class="headerlink" title="第三节 产品市场和货币市场的共同均衡：IS-LM模型"></a>第三节 产品市场和货币市场的共同均衡：IS-LM模型</h2><h3 id="一、产品市场和货币市场共同均衡"><a href="#一、产品市场和货币市场共同均衡" class="headerlink" title="一、产品市场和货币市场共同均衡"></a>一、产品市场和货币市场共同均衡</h3><h4 id="（一）均衡的决定"><a href="#（一）均衡的决定" class="headerlink" title="（一）均衡的决定"></a>（一）均衡的决定</h4><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-46.png" alt="alt text"></p>
<h4 id="（二）均衡的变动"><a href="#（二）均衡的变动" class="headerlink" title="（二）均衡的变动"></a>（二）均衡的变动</h4><p>LM曲线不变，IS曲线水平方向向左右移动，均衡状态随之改变</p>
<p>IS曲线不变，LM曲线水平向左右移动，均衡状态也将随之变动</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-47.png" alt="alt text"></p>
<h3 id="二、产品市场和货币市场失衡"><a href="#二、产品市场和货币市场失衡" class="headerlink" title="二、产品市场和货币市场失衡"></a>二、产品市场和货币市场失衡</h3><h4 id="（一）一个市场失衡，另一个市场不失衡"><a href="#（一）一个市场失衡，另一个市场不失衡" class="headerlink" title="（一）一个市场失衡，另一个市场不失衡"></a>（一）一个市场失衡，另一个市场不失衡</h4><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-48.png" alt="alt text"></p>
<h4 id="（二）两个市场的不均衡"><a href="#（二）两个市场的不均衡" class="headerlink" title="（二）两个市场的不均衡"></a>（二）两个市场的不均衡</h4><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-49.png" alt="alt text"></p>
<h3 id="三、产品市场和货币市场失衡的自我调整"><a href="#三、产品市场和货币市场失衡的自我调整" class="headerlink" title="三、产品市场和货币市场失衡的自我调整"></a>三、产品市场和货币市场失衡的自我调整</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-50.png" alt="alt text"></p>
<h3 id="四、产品市场和货币市场失衡的政府调控"><a href="#四、产品市场和货币市场失衡的政府调控" class="headerlink" title="四、产品市场和货币市场失衡的政府调控"></a>四、产品市场和货币市场失衡的政府调控</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-51.png" alt="alt text"></p>
<h1 id="第十二章-国民收入的决定：AD-AS模型"><a href="#第十二章-国民收入的决定：AD-AS模型" class="headerlink" title="第十二章 国民收入的决定：AD-AS模型"></a>第十二章 国民收入的决定：AD-AS模型</h1><p>凯恩斯理论涉及的是经济萧条，而在经济萧条时价格一般不会变动，所以凯恩斯的理论尽管分析的重点是需求，但是却不涉及价格的变动</p>
<p>本章实际上是凯恩斯主义经济学后来的发展，即将凯恩斯理论运用于非萧条但未实现充分就业的情况，也就是相对正常的情况</p>
<ul>
<li>有效需求决定模型：P=1 考虑产品市场的均衡</li>
<li>IS-LM模型：P=1 考虑产品市场、货币市场的均衡</li>
<li>AD-AS模型：P≠1 考虑产品市场、货币市场和劳动市场的均衡</li>
</ul>
<h2 id="第一节-AD曲线及其变动"><a href="#第一节-AD曲线及其变动" class="headerlink" title="第一节 AD曲线及其变动"></a>第一节 AD曲线及其变动</h2><h3 id="一、价格变动的效应"><a href="#一、价格变动的效应" class="headerlink" title="一、价格变动的效应"></a>一、价格变动的效应</h3><ol>
<li>财富效应(针对消费的变化)</li>
</ol>
<p>价格变动导致人们持有货币的实际购买力下降或消费水平相应减少的效应，叫做财富效应或实际余额效应(“庇古效应”)</p>
<p>物价水平下降提高了货币的真实价值，并使消费者变得相对富有，股利他们更多地支出。消费者支出增加意味着物品与劳务需求量更大</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-52.png" alt="alt text"></p>
<blockquote>
<p>工资的上涨与物价的上涨往往不是同步的。即使工资的上涨达到相应水平，应交税款也会随之上涨，实际可支配收入是减少的，消费随之会减少</p>
</blockquote>
<ol>
<li>利率效应(针对投资)</li>
</ol>
<p>货币供给不变时，价格上升会引起利率上升，总需求和收入水平下降。价格水平变动会引起利率同方向变动，进而使投资和产出水平反方向变动的情况叫做利率效应</p>
<p>物价水平是货币需求量的一个决定因素。物价水平降低，家庭为了购买他们想要的物品与劳务需要持有的货币就越少。因此，当物价水平下降时，家庭会通过把一些钱借出去来试图减少货币持有量(货币需求减少)，即将货币换为有利息的资产，会导致利率的下降，反过来又影响对物品与劳务的支出。同时利率的下降会导致投资的增加</p>
<blockquote>
<p>利率可以看做货币的价格，货币供给给定，需求的增加会导致利率上扬</p>
</blockquote>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-53.png" alt="alt text"></p>
<p>财富效应实际上与微观经济学部分所讲的价格变动会导致收入效应相对应。二利率效应确实宏观经济学谈到的特有效应，与微观不同</p>
<h3 id="二、AD曲线的推导"><a href="#二、AD曲线的推导" class="headerlink" title="二、AD曲线的推导"></a>二、AD曲线的推导</h3><p>总需求曲线(AD曲线)的推导：以IS-LM曲线推导</p>
<ol>
<li>AD曲线的梳理推导(总需求函数)</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-54.png" alt="alt text"></p>
<blockquote>
<p>货币市场均衡是指货币需求与名义货币供给量相等</p>
</blockquote>
<p>（5）式就是AD函数，该式表明总产出与总价格水平成反向变化关系。所以在纵轴代表价格水平P，横轴代表总产出水平Y的坐标中 ，AD曲线是一条向右下方倾斜的曲线</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-55.png" alt="alt text"></p>
<p>如果IS曲线和LM曲线已知，则我们可以求出某一经济状态AD曲线的方程：如果AD曲线已知，则我们可以根据一定的价格水平推测该经济状态的总收入水平或总产出水平</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-56.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-57.png" alt="alt text"></p>
<ol>
<li>AD曲线的几何推导</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-58.png" alt="alt text"></p>
<h3 id="三、AD曲线的经济含义"><a href="#三、AD曲线的经济含义" class="headerlink" title="三、AD曲线的经济含义"></a>三、AD曲线的经济含义</h3><ol>
<li><p>AD曲线一条描述总需求达到宏观均衡即IS=LM时，一个国家总产出水平与价格水平之间关系的曲线</p>
<blockquote>
<p>总需求是指经济社会对产品和劳务(<strong>不包括货币</strong>)的需求总量，这一需求总量通常以产出水平来表示，总需求由消费需求、投资需求、政府需求和国外需求构成</p>
</blockquote>
</li>
<li><p>AD曲线表明总产出Y与价格水平P之间存在着反向变化的关系</p>
</li>
<li><p>AD曲线反映了价格回评影响实际货币供给，实际货币供给影响利率水平，利率水平影响投资水平，投资水平影响产出水平或收入水平这样一个复杂而迂回的传导机制(P上升，M减少，r增加，I减少，Y减少)</p>
</li>
</ol>
<h3 id="四、AD曲线的变动和影响因素"><a href="#四、AD曲线的变动和影响因素" class="headerlink" title="四、AD曲线的变动和影响因素"></a>四、AD曲线的变动和影响因素</h3><ul>
<li>在价格不变时</li>
<li>扩张性政策：AD曲线右移</li>
<li>紧缩性政策：AD曲线左移</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-59.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-60.png" alt="alt text"></p>
<h3 id="五、AD曲线的斜率及其经济含义"><a href="#五、AD曲线的斜率及其经济含义" class="headerlink" title="五、AD曲线的斜率及其经济含义"></a>五、AD曲线的斜率及其经济含义</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-61.png" alt="alt text"></p>
<h2 id="第二节-AS曲线及其变动"><a href="#第二节-AS曲线及其变动" class="headerlink" title="第二节 AS曲线及其变动"></a>第二节 AS曲线及其变动</h2><p>总供给是经济社会所提供的总产量(或国民收入)</p>
<h3 id="一、AS曲线的推导"><a href="#一、AS曲线的推导" class="headerlink" title="一、AS曲线的推导"></a>一、AS曲线的推导</h3><h4 id="（一）推导凯恩斯主义的AS曲线-短期"><a href="#（一）推导凯恩斯主义的AS曲线-短期" class="headerlink" title="（一）推导凯恩斯主义的AS曲线(短期)"></a>（一）推导凯恩斯主义的AS曲线(短期)</h4><p>依据微观经济学方法推导</p>
<ol>
<li>凯恩斯主义AS曲线的一般形式(工资向下刚性，即货币工资不会轻易变动)</li>
</ol>
<ul>
<li>大萧条背景下对工作的需求高，极少工资下也可以获得较高产出</li>
</ul>
<ol>
<li>凯恩斯主义AS曲线的特殊形式：水平线</li>
</ol>
<h4 id="（二）推导古典AS曲线-长期-：垂直线-强调市场这一看不见的手"><a href="#（二）推导古典AS曲线-长期-：垂直线-强调市场这一看不见的手" class="headerlink" title="（二）推导古典AS曲线(长期)：垂直线(强调市场这一看不见的手)"></a>（二）推导古典AS曲线(长期)：垂直线(强调市场这一看不见的手)</h4><p>按照西方古典学派的说法，在长期，价格和货币工资具有伸缩性(因为在长期，时间足够长，价格和货币工资都有足够长的时间去调整)，因此劳动供给和劳动需求也有足够长的时间去实现均衡，当劳动供给与劳动需求实现均衡时，所形成的就业水平就在充分就业的状态下，此时的产量为潜在产量。</p>
<p>对于AS曲线的集中类型要注意加以区分</p>
<ul>
<li>古典学派认为，增加需求的政策并不能改变产量，而只能造成物价上涨，甚至通货膨胀</li>
</ul>
<h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><h3 id="二、AS曲线的含义"><a href="#二、AS曲线的含义" class="headerlink" title="二、AS曲线的含义"></a>二、AS曲线的含义</h3><ol>
<li><p>AS曲线是一条描述总供给达到宏观均衡时，一个国家总产出水平与价格水平之间关系的曲线</p>
</li>
<li><p>AS曲线表明总产出Y与价格水平P之间存在着正向变化的关系</p>
</li>
<li><p>AS曲线反映了价格水平影响实际工资，实际工资影响就业水平，就业水平影响投资水平，投资水平影响产出水平或收入回评这样一个复杂而迂回的传导机制(P上升，W下降，N上升，Y上升)</p>
</li>
</ol>
<blockquote>
<p>短期内，总供给主要由总就业水平决定</p>
</blockquote>
<h3 id="三、AS曲线的变动和影响因素"><a href="#三、AS曲线的变动和影响因素" class="headerlink" title="三、AS曲线的变动和影响因素"></a>三、AS曲线的变动和影响因素</h3><h4 id="（一）AS曲线的平移"><a href="#（一）AS曲线的平移" class="headerlink" title="（一）AS曲线的平移"></a>（一）AS曲线的平移</h4><p>物价水平的变化使总供给量在总供给曲线上滑动。如果物价水平不变,其他因素变化导致总供给的增加或减少,可以用AS曲线的水平移动来表示。总供给增加,AS曲线向右边平移;总供给减少,则AS曲线向左边平移:</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-62.png" alt="alt text"></p>
<p>影响总供给曲线的因素主要有生产函数(技术水平、劳动生产率)，劳动就业量(劳动需求、劳动供给)</p>
<ol>
<li>技术进步导致的AS曲线变动(中性技术进步假设)<blockquote>
<p>不会带来劳动就业量的变化的技术进步</p>
</blockquote>
</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-63.png" alt="alt text"></p>
<ol>
<li>劳动需求变动导致的AS曲线变动(图解)</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-64.png" alt="alt text"></p>
<ol>
<li>劳动供给变动导致的AS曲线变动(劳动意愿与偏好)</li>
</ol>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-65.png" alt="alt text"></p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-66.png" alt="alt text"></p>
<h3 id="四、特殊的AS曲线及其变动：凯恩斯和古典"><a href="#四、特殊的AS曲线及其变动：凯恩斯和古典" class="headerlink" title="四、特殊的AS曲线及其变动：凯恩斯和古典"></a>四、特殊的AS曲线及其变动：凯恩斯和古典</h3><p>凯恩斯的水平AS曲线：只有总需求有极大增长才会发生变化，一般在短期内不会变化</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-73.png" alt="alt text"></p>
<p>古典的垂直AS曲线：生产力有大的提高或破坏，劳动力有大的变化时才会移动</p>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-74.png" alt="alt text"></p>
<h3 id="五、AS曲线不同特征的经济含义"><a href="#五、AS曲线不同特征的经济含义" class="headerlink" title="五、AS曲线不同特征的经济含义"></a>五、AS曲线不同特征的经济含义</h3><ul>
<li>古典的AS曲线：充分就业，潜在产出水平，价格可变</li>
<li>价格不变的凯恩斯AS曲线：经济萧条时的状态</li>
<li>价格可变的凯恩斯主义AS曲线：未达充分就业，但不处于经济萧条的状态</li>
</ul>
<p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-67.png" alt="alt text"></p>
<h2 id="第三节-AD-AS模型"><a href="#第三节-AD-AS模型" class="headerlink" title="第三节 AD-AS模型"></a>第三节 AD-AS模型</h2><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-75.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-76.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-77.png" alt="alt text"></p>
<h2 id="第四节-AD-AS模型对外来冲击的反应"><a href="#第四节-AD-AS模型对外来冲击的反应" class="headerlink" title="第四节 AD-AS模型对外来冲击的反应"></a>第四节 AD-AS模型对外来冲击的反应</h2><ul>
<li>失业、衰退：总产出减少</li>
<li>通货膨胀：物价水平增加</li>
<li>滞胀：P增加的同时Y减少</li>
</ul>
<h3 id="一、对总需求方面扰动和冲击的反应"><a href="#一、对总需求方面扰动和冲击的反应" class="headerlink" title="一、对总需求方面扰动和冲击的反应"></a>一、对总需求方面扰动和冲击的反应</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-78.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-79.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-80.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-68.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-69.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-70.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-71.png" alt="alt text"></p>
<h3 id="二、对AS方面扰动和冲击的反应"><a href="#二、对AS方面扰动和冲击的反应" class="headerlink" title="二、对AS方面扰动和冲击的反应"></a>二、对AS方面扰动和冲击的反应</h3><p><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-81.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-82.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-83.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-84.png" alt="alt text"><br><img src="/2025/04/07/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E5%AD%A6/image-85.png" alt="alt text"></p>
<h4 id="短期影响（只有一条线发生变化）"><a href="#短期影响（只有一条线发生变化）" class="headerlink" title="短期影响（只有一条线发生变化）"></a>短期影响（只有一条线发生变化）</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>曲线的变动</th>
<th>宏观经济问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>AD曲线向左移动</td>
<td>失业</td>
</tr>
<tr>
<td>2</td>
<td>AD曲线向右方移动</td>
<td>通货膨胀</td>
</tr>
<tr>
<td>3</td>
<td>AS曲线向左移动</td>
<td>滞胀</td>
</tr>
</tbody>
</table>
</div>
<p><strong>长期影响（两条线都发生变化，市场这一看不见的手发挥了自我调节作用</strong></p>
<ul>
<li>在古典AS曲线附近波动</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面向对象程序设计Object-Oriented Programming</title>
    <url>/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/</url>
    <content><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1:Introduction"></a>Chapter 1:Introduction</h1><h2 id="1-The-First-C-Program"><a href="#1-The-First-C-Program" class="headerlink" title="1. The First C++ Program"></a>1. The First C++ Program</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">usingnamespace std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> sid;</span><br><span class="line">    cin &gt;&gt; age &gt;&gt;sid;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World! I am &quot;</span> &lt;&lt; age &lt;&lt; Today!<span class="string">&quot; &lt;&lt; endl;  </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>cout</code>: 标准输出流</li>
<li><code>&lt;&lt;</code>:把东西插入到左边去</li>
<li><code>cout&lt;&lt;&quot;&quot;</code>的副作用是字符串被输出，但结果是字符串本身。</li>
<li><code>cin&gt;&gt;age</code>同理，副作用是读入，结果是 age 本身。<strong><em>(读到空格为止)</em></strong><blockquote>
<p>语句本身是有结果的</p>
<h2 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h2></blockquote>
</li>
<li>string is a class in C++. (需要 #include <code>&lt;string&gt;</code>)</li>
<li>可以像定义其他类型一样定义变量。 e.g. string str;</li>
<li>可以对字符串初始化，用 cin, cout 输入输出。<h3 id="2-1-Assignment-for-string"><a href="#2-1-Assignment-for-string" class="headerlink" title="2.1 Assignment for string"></a>2.1 Assignment for string</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> charr1[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>; </span><br><span class="line">string str1;</span><br><span class="line">string str2 = <span class="string">&quot;panther&quot;</span>; </span><br><span class="line">carr1 = char2; <span class="comment">// illegal </span></span><br><span class="line">str1 = str2; <span class="comment">// legal</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>字符数组不能赋值，字符串是可以的。<br>这里 “panther” 是一个字符串字面量。</p>
<h3 id="2-2-字符串的连接"><a href="#2-2-字符串的连接" class="headerlink" title="2.2 字符串的连接"></a>2.2 字符串的连接</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str3;</span><br><span class="line">str3 = str1 + str2;</span><br><span class="line">str1 += str2;</span><br><span class="line">str1 += <span class="string">&quot;lalala&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>string name; name+=&quot;Johnson&quot;;</code>这里<code>name</code>已经有确定值了，因为这里是一个class态，为空字符串 </p>
<h3 id="2-3-字符串的长度"><a href="#2-3-字符串的长度" class="headerlink" title="2.3 字符串的长度"></a>2.3 字符串的长度</h3><p><code>s.length()</code>得到字符串的长度。(<strong><em>C++中字符串没有<code>\0</code></em></strong>)</p>
<ul>
<li>C语言中<code>.</code>用来检索结构里的成员</li>
<li>C++中<code>.</code>的做法是在结构里放入了函数，成了类<h3 id="2-4-Create-a-string-初始化字符串"><a href="#2-4-Create-a-string-初始化字符串" class="headerlink" title="2.4 Create a string 初始化字符串"></a>2.4 Create a string 初始化字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;<span class="comment">//s室=是被初始化的</span></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//i是没有被初始化的</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p><code>string major(&quot;CS&quot;);</code>这样也可以初始化一个字符串。类似地，其他类型也可以 <code>int age(18)</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *cp,<span class="type">int</span> len);</span><br><span class="line">s.<span class="built_in">string</span>(<span class="type">const</span> string&amp; s2,<span class="type">int</span> pos);</span><br><span class="line">s.<span class="built_in">string</span>(<span class="type">const</span> string&amp; s2,<span class="type">int</span> pos,<span class="type">int</span> len);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5-其他成员函数"><a href="#2-5-其他成员函数" class="headerlink" title="2.5 其他成员函数"></a>2.5 其他成员函数</h3><ul>
<li>sub-string：<code>substr(int pos,int len);</code>拷贝字符从<code>pos</code>位置开始的len个字符<ul>
<li>如果<code>pos</code> 超出字符串长度，那么会产生异常</li>
<li>如果<code>pos</code>等于字符串长度，那么会得到空字符串</li>
<li>如果<code>pos+len</code>超出了字符串的长度，那么只会拷贝到字符串的末尾。</li>
</ul>
</li>
<li>alter string<ul>
<li>assign将一个新的值赋值给字符串<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">assign</span>(<span class="type">const</span> string&amp; str);<span class="comment">//将s赋值为str中的值</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="type">const</span> string&amp; str, <span class="type">size_t</span> subpos, <span class="type">size_t</span> sublen);<span class="comment">//赋值为sstr的一个子串</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">s.<span class="built_in">assign</span>(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> n);</span><br><span class="line">s.<span class="built_in">assign</span>(<span class="type">size_t</span> n, <span class="type">char</span> c);</span><br></pre></td></tr></table></figure></li>
<li><code>insert</code>在<code>pos</code>之间插入字符<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(<span class="type">size_t</span> pos,<span class="type">const</span> string&amp; str);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="type">size_t</span> pos,<span class="type">const</span> string&amp; str,<span class="type">size_t</span> subpos,<span class="type">size_t</span> sublen);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="type">size_t</span> pos,<span class="type">const</span> <span class="type">char</span>* s);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="type">size_t</span> pos,<span class="type">const</span> <span class="type">char</span>* s,<span class="type">size_t</span> n);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="type">size_t</span> pos,<span class="type">size_t</span> n,<span class="type">char</span> c);</span><br></pre></td></tr></table></figure></li>
<li><code>find(const string&amp; str,size_t pos=0)</code>从pos开始查找字符串str，返回第一次匹配的第一个字符串的位置</li>
<li><code>erase</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(<span class="type">size_t</span> pos=<span class="number">0</span>,<span class="type">size_t</span> len=npos);</span><br></pre></td></tr></table></figure></li>
<li><code>append</code>在字符串后面添加字符串<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">append</span>(<span class="type">const</span> string&amp; str);</span><br></pre></td></tr></table></figure></li>
<li><code>replace</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(<span class="type">size_t</span> pos,<span class="type">size_t</span> len,<span class="type">const</span> string&amp; str);</span><br></pre></td></tr></table></figure>
<h3 id="2-6-Pointers-to-Object"><a href="#2-6-Pointers-to-Object" class="headerlink" title="2.6 Pointers to Object"></a>2.6 Pointers to Object</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string *ps=&amp;s;<span class="comment">//s指向ps的地址，也就是该字符串大家一个字符的地址</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-7-Two-ways-to-Access"><a href="#2-7-Two-ways-to-Access" class="headerlink" title="2.7 Two ways to Access"></a>2.7 Two ways to Access</h3><ul>
<li><code>string s;</code>s就是对象本身<ul>
<li>在这个语句中，对象s已经被创建和初始化(一个空字符串)</li>
</ul>
</li>
<li><code>string *ps;</code>ps指向对象的指针<ul>
<li>在这个语句中，ps指向的对象是未知的</li>
</ul>
</li>
</ul>
<h1 id="Chapter-2：Container-容器"><a href="#Chapter-2：Container-容器" class="headerlink" title="Chapter 2：Container(容器)"></a>Chapter 2：Container(容器)</h1><p>Collection objects are objects that can store an arbitrary number of other objects</p>
<ul>
<li>collection本身是对象</li>
<li>其可以存储任何对象</li>
</ul>
<p>在C++中，容器在STL中</p>
<ul>
<li>STL=Standard Template Library</li>
<li>Part of the ISO Standard C++ Library </li>
<li>Data Structures and algorithms for C++.</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-20.png" alt="alt text"></p>
<p>Library includes</p>
<ul>
<li>A pair of class((pairs of anything, int/int, int/char, etc))</li>
<li>Containers<ul>
<li>vector(可变数组)</li>
<li>deque(可变数组，在两侧延伸,双端队列)</li>
<li>list(double-linked)</li>
<li>sets and maps(哈希)</li>
<li>Basic Algorithms(sort,searh,etc)</li>
</ul>
</li>
<li>All identifiers in library are in the namespace std:<code>using namespace std;</code></li>
</ul>
<h2 id="2-1-Vector"><a href="#2-1-Vector" class="headerlink" title="2.1 Vector"></a>2.1 Vector</h2><p>每个容器是一个头文件，需要include<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Declare a vector of ints (no need to worry about size)</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    <span class="comment">// Add elements</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a=<span class="number">0</span>; a&lt;<span class="number">1000</span>; a++)</span><br><span class="line">    x.<span class="built_in">push_back</span>(a);</span><br><span class="line">    <span class="comment">// Have a pre-defined iterator for vector class, can use it to print out the items in vector</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line">    <span class="keyword">for</span> (p=x.<span class="built_in">begin</span>(); p&lt;x.<span class="built_in">end</span>(); p++)</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这是泛型定义(generic classes),我们需要指定<code>vector</code>和vector内元素的类型<code>vector&lt;int&gt; x</code></li>
<li><code>vector&lt;int&gt;::iterator</code>是一个类型我们称之为迭代器<ul>
<li>it不是一个指针,<code>*</code>和<code>++</code>针对iterator进行了重载</li>
</ul>
</li>
<li>语法糖（C++11）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:x)<span class="comment">//auto是指类型自动推断。这里会从x中依次取出一个值，最后放到i里去</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul>
<li>可以根据需求进行容量扩充</li>
<li>私有保持容器中已有元素的个数</li>
<li>维护插入元素的顺序<h3 id="2-1-1-Basic-Vector-Operations"><a href="#2-1-1-Basic-Vector-Operations" class="headerlink" title="2.1.1 Basic Vector Operations"></a>2.1.1 Basic Vector Operations</h3></li>
<li>Constructors<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;ElementType&gt; c;</span><br><span class="line"><span class="function">vector&lt;ElementType&gt; <span class="title">c1</span><span class="params">(c2)</span></span>;将c2容器中的元素复制到c1容器中</span><br><span class="line"><span class="function">vector&lt;ElementType&gt; <span class="title">c</span><span class="params">(n,element)</span></span>;<span class="comment">//初始化为n个element</span></span><br><span class="line"><span class="function">vector&lt;ElementType&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>Simple Methods<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">V.<span class="built_in">size</span>();<span class="comment">//num items</span></span><br><span class="line">V.<span class="built_in">empty</span>();<span class="comment">//true if empty</span></span><br><span class="line">v1==v2;<span class="comment">//true if equal（元素相同，且在容器中的顺序相同，其他关系运算符也可以使用）</span></span><br><span class="line">V.<span class="built_in">swap</span>(v2);将V中的元素与v2交换</span><br></pre></td></tr></table></figure></li>
<li>Iterators<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">V.<span class="built_in">begin</span>();<span class="comment">//first position(地址)</span></span><br><span class="line">V.<span class="built_in">end</span>();<span class="comment">//last position(地址)</span></span><br></pre></td></tr></table></figure></li>
<li>Element Access<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">V[index];<span class="comment">//element at position i</span></span><br><span class="line">V.<span class="built_in">at</span>(index);<span class="comment">//不能作为左式向指定位置写入元素</span></span><br><span class="line">V.<span class="built_in">front</span>();<span class="comment">//first element</span></span><br><span class="line">V.<span class="built_in">back</span>();<span class="comment">//last element</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>vector[] vs v.at():vector[]不会进行边界检查，越界后行为不可预测</p>
</blockquote>
</li>
<li>Add/Remove/Find<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">V.<span class="built_in">push_back</span>(element);<span class="comment">//add to end</span></span><br><span class="line">V.<span class="built_in">pop_back</span>();<span class="comment">//remove from end</span></span><br><span class="line">V.<span class="built_in">insert</span>(pos,element);<span class="comment">//pos为iterator</span></span><br><span class="line">V.<span class="built_in">erase</span>(pos);<span class="comment">//pos为iterator</span></span><br><span class="line">V.<span class="built_in">clear</span>();<span class="comment">//remove all elements</span></span><br><span class="line"><span class="built_in">find</span>(pos_first,pos_last,element);<span class="comment">//在first和last之间寻找element,返回值是element对应的迭代器位置</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-1-2-Two-ways-to-use-Vector"><a href="#2-1-2-Two-ways-to-use-Vector" class="headerlink" title="2.1.2 Two ways to use Vector"></a>2.1.2 Two ways to use Vector</h3><ul>
<li>Preallocate<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;v.<span class="built_in">capacity</span>()&lt;&lt;endl;<span class="comment">//输出为10 </span></span><br><span class="line">cout&lt;&lt;v.<span class="built_in">size</span>()&lt;&lt;endl;<span class="comment">//输出为10(说明元素被初始化为0)</span></span><br><span class="line">v[<span class="number">5</span>]=<span class="number">1</span>;<span class="comment">//okay</span></span><br><span class="line">v[<span class="number">11</span>]=<span class="number">1</span>;<span class="comment">//bad</span></span><br></pre></td></tr></table></figure></li>
<li>Grow tail<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;i)</span><br><span class="line">&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-List-Class"><a href="#2-2-List-Class" class="headerlink" title="2.2 List Class"></a>2.2 List Class</h2>与vector相同的基本概念</li>
<li>Constructor</li>
<li>比较链表的能力(==,!=,&lt;,&lt;=,&gt;,&gt;=)</li>
<li>访问链表的两端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x.<span class="built_in">front</span>();<span class="comment">//first element</span></span><br><span class="line">x.<span class="built_in">back</span>();<span class="comment">//last element</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Ability to assign items to a list,remove items<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x.<span class="built_in">push_back</span>(item);<span class="comment">//后插入</span></span><br><span class="line">x.<span class="built_in">push_front</span>(item);<span class="comment">//前插入</span></span><br><span class="line">x.<span class="built_in">pop_back</span>();<span class="comment">//删除最后一个元素</span></span><br><span class="line">x.<span class="built_in">pop_front</span>();<span class="comment">//删除第一个元素</span></span><br><span class="line">x.<span class="built_in">erase</span>(pos1,pos2);<span class="comment">//删除pos1到pos2之间的元素</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;string&gt;s;</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push_front</span>(<span class="string">&quot;tide&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push_front</span>(<span class="string">&quot;crimson&quot;</span>);</span><br><span class="line">    s.<span class="built_in">push_front</span>(<span class="string">&quot;alabama&quot;</span>);</span><br><span class="line">    list&lt;string&gt;iterator:: p;</span><br><span class="line">    <span class="keyword">for</span> (p=s.<span class="built_in">begin</span>(); p!=s.<span class="built_in">end</span>(); p++)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里是<code>p!=s.end()</code>因为列表每个空间是动态分配的，后申请的空间不能保证先申请的空间后面。对<code>vector</code>来说空间是连续的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst1;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter1=lst<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter2=lst<span class="number">1.</span><span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">while</span>(iter1&lt;iter2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>iter1和iter2不能通过比较大小的形式进行链表遍历管理，因为列表每个空间是动态分配的，分配的内存在存储空间内不一定是连续的</p>
</blockquote>
<ul>
<li>Maintaining an ordered list<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;string&gt; s;</span><br><span class="line">    string t;</span><br><span class="line">    list&lt;string&gt;::iterator p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;<span class="number">5</span>;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Enter a string: &quot;</span>;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        p=s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(p!=s.<span class="built_in">end</span>()&amp;&amp;*p&lt;t)</span><br><span class="line">        &#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    s.<span class="built_in">insert</span>(p,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(p=s.<span class="built_in">begin</span>();p!=p.<span class="built_in">end</span>();p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">## <span class="number">2.3</span> Maps</span><br><span class="line">- Maps are collections that contain pairs of values</span><br><span class="line">- Pairs是由一个key和一个value组成的</span><br><span class="line">- 在map中，key values通常用来排序和确定元素，被映射的值存储这个key相关的内容</span><br><span class="line">    - key内部的实现机制中是自动根据key进行排序的</span><br><span class="line">- 查找的工作原理是提供一个键并通过这个键进行检索</span><br><span class="line">- Maps的实现原理是通过二叉搜索树实现的</span><br><span class="line"></span><br><span class="line">- map中的常用函数总结</span><br><span class="line"></span><br><span class="line">|函数|	功能|	时间复杂度|</span><br><span class="line">|---|---|---|</span><br><span class="line">|insert	|插入一对映射	|$\mathcal&#123;O&#125;(\log n)$</span><br><span class="line">|count	|判断关键字是否存在	|$\mathcal&#123;O&#125;(\log n)$</span><br><span class="line">|size	|获取映射对个数	|$\mathcal&#123;O&#125;(<span class="number">1</span>)$</span><br><span class="line">|clear	|清空	|$\mathcal&#123;O&#125;(n)$</span><br><span class="line"></span><br><span class="line">- 我们向映射中加入新映射对的时候就是通过插入pair来实现的。如果插入的key之前已经存在了，将不会用插入的新的value替代原来的value，也就是这次插入是无效的。</span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; dict;              <span class="comment">// dict 是一个 string 到 int 的映射，存放每个名字对应的班级号，初始时为空</span></span><br><span class="line">    dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">1</span>));   <span class="comment">// &#123;&quot;Tom&quot;-&gt;1&#125;</span></span><br><span class="line">    dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Jone&quot;</span>, <span class="number">2</span>));  <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2&#125;</span></span><br><span class="line">    dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Mary&quot;</span>, <span class="number">1</span>));  <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">2</span>));   <span class="comment">// &#123;&quot;Tom&quot;-&gt;1, &quot;Jone&quot;-&gt;2, &quot;Mary&quot;-&gt;1&#125;</span></span><br><span class="line">    <span class="comment">//但是如果我们使用dict[&quot;Tom&quot;]=2;对Tom进行赋值，那么Tom的value就会变成2，不可更改的性质仅限于insert函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">map&lt;string,<span class="type">float</span>&gt; price;<span class="comment">//key是string，value是float</span></span><br><span class="line">price[<span class="string">&quot;snapple&quot;</span>]=<span class="number">0.75</span>;</span><br><span class="line">price[<span class="string">&quot;coke&quot;</span>]=<span class="number">0.50</span>;</span><br><span class="line">string item=<span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;item)</span><br><span class="line">&#123;</span><br><span class="line">    total+=price[item];<span class="comment">//字符串作为下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count函数是用来查找key的，如果找到返回1找不到返回0<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 map，键是字符串，值是整数</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 map 中插入一些键值对</span></span><br><span class="line">    myMap[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span>;</span><br><span class="line">    myMap[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    myMap[<span class="string">&quot;cherry&quot;</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 count 函数检查键是否存在</span></span><br><span class="line">    std::string key = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">count</span>(key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; exists in the map with value &quot;</span> &lt;&lt; myMap[key] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; does not exist in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查一个不存在的键</span></span><br><span class="line">    key = <span class="string">&quot;grape&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (myMap.<span class="built_in">count</span>(key) &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; exists in the map with value &quot;</span> &lt;&lt; myMap[key] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot; does not exist in the map.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">long</span>,<span class="type">int</span>&gt; root;</span><br><span class="line">root[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">root[<span class="number">10000000</span>]=<span class="number">1000</span>;</span><br><span class="line"><span class="type">long</span> l;</span><br><span class="line">cin&gt;&gt;l;</span><br><span class="line"><span class="keyword">if</span>(root.<span class="built_in">count</span>(l))<span class="comment">//寻找是否有key=l的value，有则输出</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;root[l]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;not found&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
<li>Example<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string,<span class="type">int</span>&gt; m&#123;&#123;<span class="string">&quot;CPU&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;GPU&quot;</span>,<span class="number">15</span>&#125;,&#123;<span class="string">&quot;RAM&quot;</span>,<span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print_map</span>(<span class="string">&quot;1) Initial map: &quot;</span>,m);</span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;CPU&quot;</span>]=<span class="number">25</span>;<span class="comment">//更新原有的字典元素</span></span><br><span class="line">m[<span class="string">&quot;SSD&quot;</span>]=<span class="number">30</span>;<span class="comment">//添加新的字典元素</span></span><br><span class="line"><span class="built_in">print_map</span>(<span class="string">&quot;2) Updated map: &quot;</span>,m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Using operator[] with non-existent key always performs an insert</span></span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;3) m[UPS] = &quot;</span>&lt;&lt;m[<span class="string">&quot;UPS&quot;</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">print_map</span>(<span class="string">&quot;4) Updated map: &quot;</span>,m);</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="string">&quot;GPU&quot;</span>);<span class="comment">//删除GPU</span></span><br><span class="line"><span class="built_in">print_map</span>(<span class="string">&quot;5)After erase: &quot;</span>,m);</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line">std::cout&lt;&lt;std::boolalpha&lt;&lt;<span class="string">&quot;6)Map is empty: &quot;</span>&lt;&lt;m.<span class="built_in">empty</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-Iterator-迭代器"><a href="#2-4-Iterator-迭代器" class="headerlink" title="2.4 Iterator(迭代器)"></a>2.4 Iterator(迭代器)</h2></li>
</ul>
<ol>
<li>声明<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;::iterator p;<span class="comment">//p是list容器对应的迭代器</span></span><br></pre></td></tr></table></figure></li>
<li>操作</li>
</ol>
<ul>
<li>Front of container<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">li=Ll.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure></li>
<li>Past the end<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">li=L.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure></li>
<li>Can Increment<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">li=L.<span class="built_in">begin</span>();</span><br><span class="line">li++;</span><br></pre></td></tr></table></figure></li>
<li>Can be dereferenced<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*li=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li>迭代器可以通过解引用的方式直接更改对应容器中的值</li>
</ul>
<p>在 C++ 中，迭代器（Iterator）是一种用于遍历容器（如 <code>vector</code>、<code>list</code>、<code>map</code> 等）中元素的对象。C++ 标准库定义了多种类型的迭代器，每种迭代器支持不同的操作。</p>
<h4 id="C-标准迭代器类型"><a href="#C-标准迭代器类型" class="headerlink" title="C++ 标准迭代器类型"></a><strong>C++ 标准迭代器类型</strong></h4><ol>
<li><p><strong>输入迭代器（Input Iterator）</strong>：</p>
<ul>
<li>支持读取容器中的元素。</li>
<li>只能单向移动（从前向后）。</li>
<li>例如：<code>istream_iterator</code>。</li>
</ul>
</li>
<li><p><strong>输出迭代器（Output Iterator）</strong>：</p>
<ul>
<li>支持向容器中写入元素。</li>
<li>只能单向移动（从前向后）。</li>
<li>例如：<code>ostream_iterator</code>。</li>
</ul>
</li>
<li><p><strong>前向迭代器（Forward Iterator）</strong>：</p>
<ul>
<li>支持读取和写入容器中的元素。</li>
<li>可以单向移动（从前向后）。</li>
<li>例如：<code>forward_list</code> 的迭代器。</li>
</ul>
</li>
<li><p><strong>双向迭代器（Bidirectional Iterator）</strong>：</p>
<ul>
<li>支持读取和写入容器中的元素。</li>
<li>可以双向移动（从前向后或从后向前）。</li>
<li>例如：<code>list</code> 的迭代器。</li>
</ul>
</li>
<li><p><strong>随机访问迭代器（Random Access Iterator）</strong>：</p>
<ul>
<li>支持读取和写入容器中的元素。</li>
<li>可以随机访问容器中的任意元素（支持 <code>+</code>、<code>-</code>、<code>[]</code> 等操作）。</li>
<li>例如：<code>vector</code> 和 <code>deque</code> 的迭代器。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="Chapter-3-Class"><a href="#Chapter-3-Class" class="headerlink" title="Chapter 3: Class"></a>Chapter 3: Class</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">point</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> Point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(Point* p,<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;x += dx;</span><br><span class="line">    p-&gt;y += dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Point a;</span><br><span class="line">    a.x = <span class="number">1</span>;</span><br><span class="line">    a.y = <span class="number">2</span>;</span><br><span class="line">    print(&amp;a);</span><br><span class="line">    move(&amp;a, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    print(&amp;a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是C语言风格的代码。函数只能在结构体的外面<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;Point;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>C++可以把函数也放到结构里面。这里只是声明，但不会产生实际代码。</p>
<ul>
<li><p>声明在结构内的函数是不独立的，从属于<code>Point</code>结构，需要一个body</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;       </span><br><span class="line">&#125;Point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>a.print()</code>即可调用结构体内部的成员函数，但是这个成员函数如何知道我们要输出<code>a.x,a.y</code>呢</p>
</li>
<li><p><code>this</code>指针指向的对象就是<code>a</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::init</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里必须加this，否则类似于局部变量会屏蔽全局变量，编译器会认为x=x，相当于给形参赋值，什么也没做</p>
</blockquote>
<h2 id="2-Resolver"><a href="#2-Resolver" class="headerlink" title="2 Resolver"></a>2 Resolver</h2><p>预解析器</p>
<ul>
<li><code>&lt;class name&gt;::&lt;function name&gt;</code></li>
<li><code>::&lt;function name&gt;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">S::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::<span class="built_in">f</span>(); <span class="comment">// Would be recursive otherwise!</span></span><br><span class="line">    ::a++; <span class="comment">// Select the global a</span></span><br><span class="line">    a--; <span class="comment">// The a at class scope</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>this</code>:the hidden parameter</p>
<ul>
<li><code>this</code>是每个成员函数的隐藏参数，其类型是对应的类的类型</li>
</ul>
<p><em>e.g.</em> <code>void Point::move(int dx,int dy);</code>可以写作<code>void Point::move(Point* this,int dx,int dy);</code></p>
<ul>
<li>To call the function, you must specify a variable.</li>
</ul>
<p><em>e.g.</em> p.move(10,10); can be recognized as Point::move(&amp;p,10,10);</p>
<h2 id="3-Object"><a href="#3-Object" class="headerlink" title="3 Object"></a>3 Object</h2><p><strong>Object=Attribute+Services</strong></p>
<ul>
<li>Data:the properties or status</li>
<li>Operations:the functions</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-23.png" alt="alt text"></p>
<ul>
<li>In C++, an object is just a variable, and the purest definition is “a region of storage”.</li>
<li>The struct variables learned before are just objects in C++.</li>
</ul>
<h3 id="3-1-Object-vs-Class"><a href="#3-1-Object-vs-Class" class="headerlink" title="3.1 Object vs Class"></a>3.1 Object vs Class</h3><ul>
<li>Object(this cat)<ul>
<li>Represent things,events or concepts—实体</li>
<li>Respond to message at runtime</li>
</ul>
</li>
<li>Classes(this cat)<ul>
<li>Define properties of instances</li>
<li>Act like types in C++</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-24.png" alt="alt text"></p>
<h3 id="3-2-OOP-Characteristics"><a href="#3-2-OOP-Characteristics" class="headerlink" title="3.2 OOP Characteristics"></a>3.2 OOP Characteristics</h3><ul>
<li>Everything is an object.</li>
<li>A program is a bunch of objects telling each other what to do by sending messages.<br>程序就是一堆对象，互相发送消息，告诉对方要做什么 (what instead of how)<blockquote>
<p>上课的时候，老师在讲课，电脑在发送消息给投影仪…<br>老师让同学站起来，这个消息发送过后，具体如何站起来，只由同学自己决定。</p>
</blockquote>
</li>
<li>Every object has a type.</li>
<li>All objects of a particular type can receive the same messages.<br>同类的对象，都可以接受相同的消息。<br>可以接受相同消息的对象，也可以认为是同个类型。<h2 id="4-Constructor"><a href="#4-Constructor" class="headerlink" title="4 Constructor"></a>4 Constructor</h2></li>
</ul>
<p>我们需要有机制，保证对象被创建时有合理的初值</p>
<ul>
<li>构造函数和结构名字完全相同</li>
<li>本地变量被创建时，构造函数被调用</li>
<li>在一个类中构造函数可以重载，也就是可以定义多个构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Point</span>();</span><br><span class="line">&#125;</span><br><span class="line">Point::<span class="built_in">Point</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们创建变量时<code>Point b;</code>,编译器就会自动调用对应类的构造函数。如果有参数就<code>Point a(1,2)</code>即可</li>
</ul>
<ol>
<li>Constructor with arguments</li>
</ol>
<ul>
<li>构造函数允许有参数从而允许对象确定特定的初值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">  <span class="type">int</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Tree</span>(<span class="type">int</span> initialHeight);  <span class="comment">// Constructor</span></span><br><span class="line">  ~<span class="built_in">Tree</span>();  <span class="comment">// Destructor</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">grow</span><span class="params">(<span class="type">int</span> years)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">printsize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Tree::<span class="built_in">Tree</span>(<span class="type">int</span> initialHeight) &#123;</span><br><span class="line">  height = initialHeight;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;inside Tree constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tree t(12);或Tree t=12;都可以接受相同的消息</p>
<ol>
<li>Initializer list</li>
</ol>
</blockquote>
<ul>
<li>成员变量可以在结构内被初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">&#125;;<span class="comment">//这被称为定义初始化</span></span><br></pre></td></tr></table></figure></li>
<li>构造函数也可以用初始化列表初始化成员变量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="built_in">Point</span>(xx,yy);</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义初始化-&gt;初始化列表-&gt;函数赋值(定义一个成员函数，在成员结构内部直接通过函数对其进行赋值)</p>
</blockquote>
<ol>
<li>The default constructor</li>
</ol>
<ul>
<li>是一种可以没有参数的构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> a);<span class="comment">//这不是一个没有参数的构造函数，所以在创建时必须传递变量 </span></span><br><span class="line">&#125;;</span><br><span class="line">Y y1[]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>),<span class="built_in">Y</span>(<span class="number">2</span>),<span class="built_in">Y</span>(<span class="number">3</span>)&#125;;<span class="comment">//OK</span></span><br><span class="line">Y y2[<span class="number">2</span>]=&#123;<span class="built_in">Y</span>(<span class="number">1</span>)&#125;;<span class="comment">//error,分配空间就必须传递参数进行构造</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Student</span>() &#123;</span><br><span class="line">        name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Default constructor called!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不向构造函数传递参数就是默认没有参数</p>
</blockquote>
<p><strong>“auto” default constructor</strong></p>
<ul>
<li>如果有构造函数，编译器会确保构造函数始终会被调用</li>
<li>如果没有构造函数，编译器会自动给这个类创建一个默认的构造函数</li>
</ul>
<h2 id="5-Destructor"><a href="#5-Destructor" class="headerlink" title="5 Destructor"></a>5 Destructor</h2><p>The destructor is named after the name of the class with a leading tidle(~).The destructor never has any arguments</p>
<ul>
<li>没有返回类型，没有参数</li>
<li>当其作用于结束时，析构函数会被自动调用</li>
<li>先调用构造函数的后被析构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">//! goto jump1; // Error: goto bypasses init</span></span><br><span class="line">    &#125;</span><br><span class="line">    X x1;  <span class="comment">// Constructor called here</span></span><br><span class="line">    jump1:</span><br><span class="line">    <span class="keyword">switch</span>(i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">        X x2;  <span class="comment">// Constructor called here</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//! case 2 : // Error: case bypasses init</span></span><br><span class="line">        X x3;  <span class="comment">// Constructor called here</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里 jump 跳过了 x1 的构造，但在进入函数 f 时空间已经被分配好了，当函数结束时，析构仍然会自动进行，如果没有默认零值的话析构会出问题。<br>switch case 并不能隔绝变量的作用域，里面的 x2, x3 的作用域就是这对大括号，当我们进入 switch case 时空间就已经分配，当离开大括号时析构出现问题。</p>
</blockquote>
<h1 id="Chapter-4-Inside-Object"><a href="#Chapter-4-Inside-Object" class="headerlink" title="Chapter 4:Inside Object"></a>Chapter 4:Inside Object</h1><h2 id="1-Local-and-member-variables"><a href="#1-Local-and-member-variables" class="headerlink" title="1 Local and member variables"></a>1 Local and member variables</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>local</th>
<th>global</th>
<th>member</th>
</tr>
</thead>
<tbody>
<tr>
<td>lifecycle</td>
<td>{}</td>
<td>全局</td>
<td>对象</td>
</tr>
<tr>
<td>scope</td>
<td>{}</td>
<td>全局</td>
<td>成员函数内</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>成员变量的作用域和生存期是分离的。如C语言中的static静态变量，和全局变量一样最开始就存在，但是只能作用于这个函数</li>
</ul>
<h2 id="2-C-Access-Control"><a href="#2-C-Access-Control" class="headerlink" title="2 C++ Access Control"></a>2 C++ Access Control</h2><p>The members of a class can be cataloged,marked as</p>
<ul>
<li><code>public</code>: public means all member declarations that follow are available to everyone.</li>
<li><code>private</code>:The private keyword means that no one can access that member except inside function members of that type.只有在<strong>类</strong>内部（<strong>不是对象</strong>）包括内部函数和内部变量可以访问。<ul>
<li>可以通过指针访问其他对象的私有变量<blockquote>
<p>结构中默认为<code>public</code>,类中默认为<code>private</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B *p)</span> </span>&#123;</span><br><span class="line">        p-&gt;j = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B b, bb;</span><br><span class="line">B.<span class="built_in">f</span>(&amp;bb);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种形式是正确的。private的边界是类不是对象</p>
</blockquote>
<ul>
<li><p><code>protected</code>:不让外界访问，可以让继承者访问</p>
<h2 id="Friends-友元"><a href="#Friends-友元" class="headerlink" title="Friends 友元"></a>Friends 友元</h2></li>
<li><p>is a way to explicitly grant access to a function that isnʼt a member of the structure是非成员访问类的一种函数</p>
</li>
<li>The class itself controls which code has access to its members.类自身对哪些结构可以访问类进行控制</li>
<li>Can declare a global function as a friend, as well as a member function of anotherclass, or even an entire class, as a friend.友元可以是全局函数、成员函数甚至是整个类</li>
</ul>
<p>其他函数、结构就可以访问本对象的变量。只有自己可以决定友元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">g</span><span class="params">(X*, <span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Y::y</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不同文件中的变量初始化顺序无法确定，因为这由链接器决定而不是C++编译器</p>
<ul>
<li>有依赖关系的变量尽量放在相同的文件中</li>
</ul>
</li>
<li><p><strong>友元关系不具有传递性</strong>：不能通过中间友元进行跨友元访问</p>
<h2 id="3-Where-are-the-objects"><a href="#3-Where-are-the-objects" class="headerlink" title="3 Where are the objects"></a>3 Where are the objects</h2></li>
<li>非静态成员函数：属性(property)</li>
<li>非静态成员函数：方法(method)<blockquote>
<p>二者是与对象相关的</p>
<h3 id="3-1-Local-object"><a href="#3-1-Local-object" class="headerlink" title="3.1 Local object"></a>3.1 Local object</h3></blockquote>
</li>
<li>Local variables are defined inside a method, have a scope limited to the method to which they belong<br>如果一个局部变量的名字与类的字段（成员变量）名字相同，那么在方法内部，局部变量会“遮蔽”同名的字段，导致无法直接访问字段。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TicketMachine::refundBalance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> amountToRefund;</span><br><span class="line">    amountToRefund=balance&#x27;</span><br><span class="line">    balance=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> amountToRefund;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>与字段(field)同名的局部变量将阻止从method内访问该字段<h3 id="3-2-Fields-parameters-local-variables"><a href="#3-2-Fields-parameters-local-variables" class="headerlink" title="3.2 Fields,parameters,local variables"></a>3.2 Fields,parameters,local variables</h3></li>
<li>所有三种变量都可以存储与其定义类型相匹配的值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> field; <span class="comment">// 字段</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMethod</span><span class="params">(<span class="type">int</span> parameter)</span> </span>&#123; <span class="comment">// 参数</span></span><br><span class="line">        <span class="type">int</span> localVariable = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>字段定义在构造函数和方法之外，但在类的内部<ul>
<li>字段是类的成员变量</li>
</ul>
</li>
<li>字段用于存储对象的持久数据，这些数据在对象的整个生命周期内都存在，字段的值决定了对象的当前状态</li>
<li>字段的生命周期与其所在对象相同    <ul>
<li>当对象被创建时，字段被初始化</li>
<li>当对象被销毁时，字段也随之销毁</li>
</ul>
</li>
<li>字段具有类作用域<ul>
<li>字段可以在类的任何构造函数或方法中访问</li>
<li>字段的访问权限取决于其修饰符</li>
</ul>
</li>
<li>只要他们被定义为private,field不能在类外部的任何位置被访问</li>
<li>形式参数和局部变量的生命周期<ul>
<li>形式参数和局部变量的生命周期仅限于构造函数或方法的执行期间</li>
<li>它们的值在每次调用时被创建，在调用结束后被销毁</li>
<li>因此它们的作用是临时存储而不是永久存储</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>字段(field)</th>
<th>参数(parameters)</th>
<th>局部变量(Local Variable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义位置</td>
<td>类内部，构造函数和代码块外部</td>
<td>方法或构造函数的参数列表</td>
<td>方法或代码块内部</td>
</tr>
<tr>
<td>生命周期</td>
<td>与对象相同</td>
<td>方法调用期间</td>
<td>代码块执行期间</td>
</tr>
<tr>
<td>作用域</td>
<td>整个类</td>
<td>方法内部</td>
<td>代码块内部</td>
</tr>
<tr>
<td>存储数据</td>
<td>对象的持久数据</td>
<td>方法调用时传入的值</td>
<td>临时数据</td>
</tr>
</tbody>
</table>
</div>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>形式参数(Formal Parameters)</th>
<th>局部变量(Local Variables)</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义位置</td>
<td>构造函数或方法的头部</td>
<td>构造函数或方法的主体内部</td>
</tr>
<tr>
<td>初始化</td>
<td>由实际参数初始化</td>
<td>必须在使用前显式初始化</td>
</tr>
<tr>
<td>生命周期</td>
<td>构造函数或方法执行期间</td>
<td>构造函数或方法执行期间</td>
</tr>
<tr>
<td>作用域</td>
<td>仅限于定义它们的构造函数或方法</td>
<td>仅限于定义它们的代码块</td>
</tr>
<tr>
<td>默认值</td>
<td>由实际参数初始化</td>
<td>无默认值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-3-Global-objects"><a href="#3-3-Global-objects" class="headerlink" title="3.3 Global objects"></a>3.3 Global objects</h3><ul>
<li>Consider<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;x.h&quot;</span></span></span><br><span class="line"><span class="function">X <span class="title">global_x1</span><span class="params">(<span class="number">12</span>,<span class="number">34</span>)</span></span>;</span><br><span class="line"><span class="function">X <span class="title">global_x2</span><span class="params">(<span class="number">8</span>,<span class="number">16</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>全局对象的构造函数在进入main函数之前被调用<ul>
<li>没有参数会调用默认构造函数</li>
<li>构造函数的调用顺序取决于对象定义的顺序</li>
<li><code>global_x</code>在<code>global_x2</code>之前被初始化</li>
<li><code>main()</code>不再是最先被调用的函数</li>
</ul>
</li>
<li>析构函数被调用当<ul>
<li><code>main()</code>exists or</li>
<li><code>exit()</code>is called<h4 id="Static-Initialization"><a href="#Static-Initialization" class="headerlink" title="Static Initialization"></a>Static Initialization</h4></li>
</ul>
</li>
<li>order of construction within a file is known<ul>
<li>初始化的顺序由定义的顺序决定，有依赖关系的对象要注意定义顺序</li>
</ul>
</li>
<li>Order between files is unspecified<ul>
<li>不同文件中的变量初始化顺序无法确定，它是由链接器确定的而不是由编译器决定的。有<strong>依存关系</strong>的对象不允许在不同的文件中定义</li>
</ul>
</li>
<li>A non-local static object is:<ul>
<li>defined at global <code>static int globalVar=10;</code>or namespace scope<code>namespace MyNamespace&#123;static int namespaceVar=10;&#125;</code></li>
<li>declared static in a class<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> classVar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> MyClass::classVar=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li>defined static at file scope<code>static int fileVar=40;</code></li>
</ul>
</li>
</ul>
<h2 id="4-Static"><a href="#4-Static" class="headerlink" title="4 Static"></a>4 Static</h2><ul>
<li>Two basic meanings<ul>
<li>Static storage-Local:本地变量或函数</li>
<li>Restricted access-global：全局变量或函数，只有当前文件可以访问</li>
</ul>
</li>
<li>Allocated once at a fixed address<ul>
<li>Visibility of a name </li>
<li>internal linkage</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-25.png" alt="alt text"></p>
<ul>
<li>static修饰的全局函数会限制其作用域为当前文件</li>
<li>static修饰全局变量，只能在其定义的文件中使用</li>
<li>static修饰局部变量：具有持久存储，第一次初始化时被创建，程序结束时释放</li>
<li>static修饰成员变量，由类的所有实例(对象)共享，只会在整个程序中被创建一次<ul>
<li>有静态成员变量时需要有一个根的定义<code>int StartMen</code>。类中只是给出了声明，但是不会分配内存，需要一个根的定义</li>
<li>表现：在这个类内所有的对象都维持相同的值，对象A修改了那么对象B中这个变量的值也会随之改变</li>
</ul>
</li>
<li>static修饰成员函数：由类的所有实例共享且只能访问静态成员变量。通过<code>&lt;class name&gt;::function name()</code>的形式直接调用，无需创建类的实例(对象)<ul>
<li>静态成员函数没有<code>this</code>指针，不能调用非静态成员变量，也不能访问非静态成员函数。但是可以在还没有创建对象的时候就调用静态成员函数</li>
</ul>
</li>
</ul>
<h2 id="5-Reference"><a href="#5-Reference" class="headerlink" title="5 Reference"></a>5 Reference</h2><h3 id="5-1-Declaring-Reference"><a href="#5-1-Declaring-Reference" class="headerlink" title="5.1 Declaring Reference"></a>5.1 Declaring Reference</h3><ul>
<li>Refrence is a new way to manipulate objects in C++<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> *p=&amp;c;<span class="comment">//a pointer to a character</span></span><br><span class="line"><span class="type">char</span> &amp;r=c;<span class="comment">//a reference to a character</span></span><br></pre></td></tr></table></figure>
<code>*,&amp;</code>可以是标点，也可以是运算符，如<code>&amp;</code>在第二行是一个运算符在第三行是一个标点</li>
</ul>
<p>当我们声明引用时，必须有引用的变量，此时r相当于c的一个别名</p>
<ul>
<li><code>&amp;</code>表明其右侧的变量是一个引用</li>
<li><p>Local or global variable</p>
<ul>
<li><code>type&amp; rename = name;</code></li>
<li>For ordinary variables, the initial value is required.</li>
</ul>
</li>
<li><p>In parameter lists and member variables</p>
<ul>
<li><code>type&amp; rename;</code></li>
<li>Binding defined by caller or constructor函数只有在调用时，参数才能被绑定</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">( <span class="type">int</span>&amp; x )</span></span>;</span><br><span class="line"><span class="built_in">f</span>(y); <span class="comment">// initialized when function is called</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样可以实现函数对函数外变量的值的修改</p>
<h3 id="5-2-Rules-of-references"><a href="#5-2-Rules-of-references" class="headerlink" title="5.2 Rules of references"></a>5.2 Rules of references</h3><ul>
<li>引用必须在定义时被一个已有的变量进行绑定</li>
<li>初始化可以建立一种绑定关系</li>
</ul>
</blockquote>
<ul>
<li>In declaration<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;y=x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;z=x;</span><br></pre></td></tr></table></figure></li>
<li><p>As a function argument</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系一旦确立是不能更改的</p>
<ul>
<li>可以看做一种一次性的指针</li>
</ul>
</li>
<li>赋值操作可以改变引用指向的对象的值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;y=x;</span><br><span class="line">y=<span class="number">12</span>;<span class="comment">//这时x的值也相应地变成12</span></span><br></pre></td></tr></table></figure></li>
<li>引用的对象必须有一个具体的、有内存地址的对象<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>;</span><br><span class="line"><span class="built_in">func</span>(i*<span class="number">3</span>);<span class="comment">//error因为i*3只能作为右值，不会分配内存</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Pointers-VS-References"><a href="#Pointers-VS-References" class="headerlink" title="Pointers VS References"></a>Pointers VS References</h4><ul>
<li>引用<ul>
<li>不能是空的</li>
<li>依赖于已经存在的变量，是变量的别名</li>
<li>绑定关系后不能更换到其他地址</li>
</ul>
</li>
<li>指针<ul>
<li>可以被置为空指针</li>
<li>指针变量是独立于已经存在的对象</li>
<li>可以指向位于不同地址的变量</li>
</ul>
</li>
</ul>
<h3 id="5-3-Restrictions"><a href="#5-3-Restrictions" class="headerlink" title="5.3 Restrictions"></a>5.3 Restrictions</h3><ul>
<li>No references to references<ul>
<li>引用本身是一个别名，它必须绑定到一个具体的对象，因为<strong>引用本身不是一个独立的对象</strong>，它只是目标对象的别名，所以C++不允许引用的引用出现</li>
</ul>
</li>
<li>No pointers to references没有指针的引用<ul>
<li><strong>引用本身不是一个独立的对象，它只是目标对象的别名</strong>，因此引用没有自己的内存地址<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;*p;<span class="comment">//illegal</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Reference to pointer is OK</p>
<ul>
<li>指针是一个明确的对象，有明确的内存地址，可以进行内存关系上的绑定。</li>
<li>这种用法通常用于函数参数中，以便在函数内部修改指针本身<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp;p)</span> </span>&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 修改指针 p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>No arrays of references没有引用的数组(数组中的元素是引用)</p>
<ul>
<li>数组要求元素是独立的对象，因此不能创建引用的数组</li>
</ul>
</li>
</ul>
<h3 id="左值、右值与右值引用"><a href="#左值、右值与右值引用" class="headerlink" title="左值、右值与右值引用"></a>左值、右值与右值引用</h3><ul>
<li>在赋值表达式中，出现在等号左边的就是左值，而在等号右边的就是右值</li>
<li>可以取地址、有名字的就是左值，反之，不能取地址的、没有名字的就是右值</li>
<li>C++11有两个概念组成：一个是将亡值，一个是纯右值</li>
<li>右值引用只能用右值初始化，不能用左值初始化，除非是const的左值</li>
</ul>
<h2 id="6-Constant"><a href="#6-Constant" class="headerlink" title="6 Constant"></a>6 Constant</h2><ul>
<li><p>declare a variable to have a constant value</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">123</span>;  <span class="comment">// const, literal(字面量)</span></span><br><span class="line">x = <span class="number">27</span>;     <span class="comment">// illegal!</span></span><br><span class="line">x++;    <span class="comment">// illegal!</span></span><br><span class="line"><span class="type">int</span> y = x;  <span class="comment">// ok, copy const to non-const</span></span><br><span class="line">y = x;  <span class="comment">// ok, same thing</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> z = y;    <span class="comment">// ok, const is safer</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Constants are variables常量本质上是变量，只是他们是不可以被修改的:常量声明时必须初始化且初始化后其值不能被修改</p>
<ul>
<li>Observe scoping rules：常量可以定义在全局作用域、局部作用域或命名空间内，常量的作用域决定了它在程序中的可见性和生命周期</li>
<li>Declared with <code>const</code> type modifier：常量通过<code>const</code>类型修饰符声明<ul>
<li><code>const</code>关键字用于声明常量，表示该变量的值不可修改</li>
<li><code>const</code>可以修饰基本类型、指针、引用、类对象等</li>
</ul>
</li>
</ul>
</li>
<li>A const in C++ defaults to internal linkageC++中常量默认具有内部链接<ul>
<li>the compiler tries to avoid creating storage for a const — holds the value in itssymbol table.编译器会尽量避免为常量分配存储空间，而是将常量的值保存在符号表中：如果常量是一个字面值，编译器通常会将其置于代码段<code>text</code>中而不会为其分配内存</li>
<li>extern forces storage to be allocated.extern关键字会强制为常量分配存储空间：当需要在多个文件中共享一个常量时，可以使用<code>extern</code>关键字，这时会将常量的连接属性改为外部链接，并为其分配存储空间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 外部链接，分配存储空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> x; <span class="comment">// 声明 x，使用 file1.cpp 中定义的常量</span></span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl; <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="6-1-Compile-time-Constants"><a href="#6-1-Compile-time-Constants" class="headerlink" title="6.1 Compile time Constants"></a>6.1 Compile time Constants</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufsize = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量的值必须被初始化</li>
<li>除非做一个显式的<code>extern</code>声明<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufsize;</span><br></pre></td></tr></table></figure></li>
<li>编译器不会允许你更改它的值</li>
</ul>
<h3 id="6-2-Runtime-Constants"><a href="#6-2-Runtime-Constants" class="headerlink" title="6.2 Runtime Constants"></a>6.2 Runtime Constants</h3><ul>
<li><code>const</code>值可以直接被使用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> class_size = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> finalGrade[class_size];<span class="comment">//ok</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size=x;</span><br><span class="line"><span class="type">double</span> classAverage[size];<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-3-Aggregates"><a href="#6-3-Aggregates" class="headerlink" title="6.3 Aggregates"></a>6.3 Aggregates</h3><ul>
<li>Itʼs possible to use const for aggregates, but storage will be allocated. In thesesituations, const means “a piece of storage that cannot be change<ul>
<li>可以使用<code>const</code>修饰聚合类型(如数组、结构体等)，但会为其分配存储空间</li>
<li>在这种情况下，<code>const</code>的含义是 <strong>“一块不可修改的存储空间”</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// arr 是一个常量数组</span></span><br><span class="line"><span class="comment">// arr[0] = 10; // 错误：arr 是常量，不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Point p = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;; <span class="comment">// p 是一个常量结构体</span></span><br><span class="line"><span class="comment">// p.x = 30; // 错误：p 是常量，不能修改</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>However, the value cannot be used at compile time because the compiler is notrequired to know the contents of the storage at compile time.尽管聚合类型的常量是<code>const</code>的，但是它们的值不能在编译时使用，因为编译器不需要再编译时知道存储空间的内容<ul>
<li>对于简单的常量(如<code>const int x = 10;</code>),编译器通常会在编译时将其值直接嵌入代码段中</li>
<li>但是对于聚合类型的常量，编译器通常不会再编译时知道具体的内容，因此无法在编译时使用它们的值(编译器在编译时只能看到一条语句)</li>
<li>这意味着聚合类型的常量不能用于需要在编译时确定值的场景，例如数组大小、模板参数等</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>; <span class="comment">// 简单常量</span></span><br><span class="line"><span class="type">int</span> arr[size]; <span class="comment">// 正确：size 是编译时常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 常量数组</span></span><br><span class="line"><span class="comment">// int arr2[values[0]]; // 错误：values[0] 不是编译时常量</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-Pointers-and-const"><a href="#6-4-Pointers-and-const" class="headerlink" title="6.4 Pointers and const"></a>6.4 Pointers and const</h3><p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-27.png" alt="alt text"></p>
<ul>
<li><code>const</code>后面跟的是常量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="type">const</span> q = <span class="string">&quot;abc&quot;</span>;<span class="comment">//指针本身是一个常量，指针不能修改，但是其指向的对象是可以修改的</span></span><br><span class="line">*q = <span class="string">&#x27;c&#x27;</span>;<span class="comment">//OK</span></span><br><span class="line">q++;<span class="comment">//Error,</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;ABCD&quot;</span>; <span class="comment">// (*p) is a const char</span></span><br><span class="line">*p = <span class="string">&#x27;b&#x27;</span>; <span class="comment">// ERROR! (*p) is the const</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-28.png" alt="alt text"></p>
<h3 id="6-5-String-Literals"><a href="#6-5-String-Literals" class="headerlink" title="6.5 String Literals"></a>6.5 String Literals</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s</code>是被初始化为指向字符串常量的指针</li>
<li><code>s</code>的实际类型应该是<code>const char *s</code>，但是编译器允许忽略<code>const</code></li>
<li>不要尝试修改字符串常量的字符值，这是未定义的行为<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="comment">// s[0] = &#x27;h&#x27;; // 未定义行为：尝试修改字符串常量</span></span><br></pre></td></tr></table></figure></li>
<li>如果你需要修改字符串，应该将其放在字符数组中<ul>
<li>字符数组会将字符串常量复制到栈内存中，因此可以安全地修改</li>
<li>字符数组是可修改的，因为它是一个独立的存储空间<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 正确：修改字符数组的内容</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl; <span class="comment">// 输出 &quot;hello, world!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="6-6-Conversions"><a href="#6-6-Conversions" class="headerlink" title="6.6 Conversions"></a>6.6 Conversions</h3><ul>
<li>Can always treat a non-const value as const <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* x)</span></span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">f</span>(&amp;a);<span class="comment">//ok会将非常量int*隐式转化为const int*</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a;</span><br><span class="line"><span class="built_in">f</span>(&amp;b);<span class="comment">//ok</span></span><br><span class="line">b = a + <span class="number">1</span>;<span class="comment">//ERROR常量的值不能再修改</span></span><br></pre></td></tr></table></figure></li>
<li>不能将常量对象当作非常量对象使用，除非使用显式类型转换（const_cast）<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;b); <span class="comment">// 使用 const_cast 去除常量性</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 危险：修改常量对象的值，可能导致未定义行为</span></span><br></pre></td></tr></table></figure>
<h3 id="6-7-函数中的const"><a href="#6-7-函数中的const" class="headerlink" title="6.7 函数中的const"></a>6.7 函数中的const</h3></li>
<li>函数参数中的const:可以防止参数被意外修改<ul>
<li>可以用于传递大型对象(如类对象)时，避免拷贝开销，同时确保对象不会被修改<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x++;<span class="comment">//这是不合法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>函数返回值中的const：防止返回值被意外修改<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">f4</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> j=<span class="built_in">f3</span>();<span class="comment">//ok</span></span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">f4</span>();<span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-29.png" alt="alt text"></li>
</ul>
<h3 id="6-8-const-object"><a href="#6-8-const-object" class="headerlink" title="6.8 const object"></a>6.8 const object</h3><ul>
<li>如果一个对象是const的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Currency <span class="title">the_raise</span><span class="params">(<span class="number">42</span>,<span class="number">38</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>那么只有被声明为const的成员函数才能被调用</li>
<li>放在函数声明末尾的<code>const</code>实际上是用来修饰<code>this</code>指针的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy):<span class="built_in">x</span>(xx),<span class="built_in">y</span>(yy)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> xx)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> setY <span class="title">const</span><span class="params">(<span class="type">int</span> yy)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>&#123;cout&lt;&lt;x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;y&lt;&lt;endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> point <span class="title">p</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//const object</span></span><br><span class="line">    p.<span class="built_in">print</span>();<span class="comment">//ok,因为print函数是const的</span></span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">getX</span>()&lt;&lt;endl;<span class="comment">//这是非法的，因为getX函数不是const的</span></span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">getY</span>()&lt;&lt;endl;<span class="comment">//这是合法的，因为getY函数是const的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>静态成员函数不能是const的，因为静态成员函数没有this指针</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Date::set_day</span><span class="params">(<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line"><span class="comment">//...error check d here...</span></span><br><span class="line">    day = d;</span><br><span class="line"><span class="comment">// ok, non-const so can modify</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Date::get_day</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    day++;</span><br><span class="line"><span class="comment">//ERROR modifies data member</span></span><br><span class="line">    <span class="built_in">set_day</span>(<span class="number">12</span>); <span class="comment">// ERROR calls non-const member</span></span><br><span class="line">    <span class="keyword">return</span> day; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 set_day() 是一个非const成员函数（即未声明为 const）则编译器认为它可能修改成员变量。在const函数中调用非 const 函数会导致编译错误，因为这会破坏 const 的语义保证。</p>
<ul>
<li>const成员函数的定义<ul>
<li>定义和声明中都要重复添加关键字<code>const</code></li>
<li>不做更改的成员变量被定义为<code>const</code>是更加安全的</li>
</ul>
</li>
<li>类中的常量段<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
需要在构造函数的初始化列表中被初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size;<span class="comment">//非静态成员变量不能直接在类定义中初始化</span></span><br><span class="line">    <span class="type">int</span> array[size];<span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;size=<span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> array[size];<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasArray</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size=<span class="number">100</span>;<span class="comment">//静态成员变量可以初始化</span></span><br><span class="line">    <span class="type">int</span> array[size];<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="7-Dynamically-allocated-memory"><a href="#7-Dynamically-allocated-memory" class="headerlink" title="7 Dynamically allocated memory"></a>7 Dynamically allocated memory</h2><h3 id="7-1-new"><a href="#7-1-new" class="headerlink" title="7.1 new"></a>7.1 new</h3><ul>
<li><code>new</code>是一种在程序运行时为内存动态分配空间的方式，指针是访问那块内存的唯一方式</li>
<li><code>&#123;&#125;</code>可以用来给使用<code>new</code>生成的空间对象进行初始化</li>
<li>new得到的结果一定是指针</li>
<li>new是向<strong>进程</strong>申请空间,不是直接向操作系统申请空间</li>
<li>new存在的问题是每一次找到可用的空间需要的时间可能会越来越长<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * psome = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] psome;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-delete"><a href="#7-2-delete" class="headerlink" title="7.2 delete"></a>7.2 delete</h3></li>
<li><code>delete</code>可以在讲述使用某一块内存时将内存返还给内存池</li>
<li><code>[]</code>可以告知程序应该释放整个数组，而不只是元素</li>
</ul>
<h3 id="7-3-Dynamically-allocated-memory"><a href="#7-3-Dynamically-allocated-memory" class="headerlink" title="7.3 Dynamically allocated memory"></a>7.3 Dynamically allocated memory</h3><ul>
<li>不要使用<code>delete</code>去释放没有使用<code>new</code>分配的空间</li>
<li>不要使用<code>delete</code>去释放一个已经释放过的空间</li>
<li>使用<code>delete[]</code>当我们使用<code>new[]</code>去申请数组的时候</li>
<li>使用<code>delete</code>当我们使用<code>new</code>去申请单一实体的时候</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;<span class="comment">//只析构p指向的位置，释放该变量，其它数组成员不会被析构</span></span><br><span class="line"><span class="keyword">delete</span> []p;<span class="comment">//会析构数组中所有元素，然后释放数组空间</span></span><br></pre></td></tr></table></figure>
<h2 id="8-Overloaded-functions"><a href="#8-Overloaded-functions" class="headerlink" title="8 Overloaded functions"></a>8 Overloaded functions</h2><p>可以让用户定义的类型像原生类型一样具有运算能力</p>
<ul>
<li>Allows user-defined types to act like built in types.</li>
<li>Another way of function call</li>
</ul>
<h3 id="8-1-Overloaded-Constructors"><a href="#8-1-Overloaded-Constructors" class="headerlink" title="8.1 Overloaded Constructors"></a>8.1 Overloaded Constructors</h3><ul>
<li>构造函数和类有相同的名字 </li>
<li>有时需要默认构造函数</li>
<li>有时需要另一个有参数的构造函数</li>
<li>具有相同名称但是不同参数列表的构造函数是可以同时存在的</li>
</ul>
<h4 id="Function-overloading"><a href="#Function-overloading" class="headerlink" title="Function overloading"></a>Function overloading</h4><ul>
<li>有不同参数列表的相同函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> * str, <span class="type">int</span> width)</span></span>; <span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d, <span class="type">int</span> width)</span></span>; <span class="comment">// #2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">long</span> l, <span class="type">int</span> width)</span></span>; <span class="comment">// #3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> width)</span></span>; <span class="comment">// #4</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *str)</span></span>; <span class="comment">// #5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Pancakes&quot;</span>, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Syrup&quot;</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1999.0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1999</span>, <span class="number">12</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">1999L</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Overloaded-const-and-none-const-functions"><a href="#Overloaded-const-and-none-const-functions" class="headerlink" title="Overloaded const and none-const functions"></a>Overloaded const and none-const functions</h4></li>
<li>有无参数的构造函数可以构成重载的关系</li>
<li>有无const限定的函数可以构成重载关系<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-2-Delegating-Constructors-代理构造函数"><a href="#8-2-Delegating-Constructors-代理构造函数" class="headerlink" title="8.2 Delegating Constructors(代理构造函数)"></a>8.2 Delegating Constructors(代理构造函数)</h3><ul>
<li>如果不同版本的重载函数在其内部做相同的事情<ul>
<li>Obviously code duplication is a prominent sign of bad design在每个构造函数中重复代码会导致代码冗余，这是不良设计的标志</li>
<li>The problem with calling a function inside a constructor is that it happens after initialization.但如果在构造函数中调用一个普通成员函数来封装公共逻辑，又可能引发问题，因为成员函数调用发生在对象初始化之后(即对象已构造完成)，这可能导致某些成员变量未按照预期初始化</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Info</span>()&#123;<span class="built_in">InitRest</span>();&#125;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">Info</span>()&#123;type=i;&#125;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">Info</span>()&#123;name=e;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>很多类中有很多做相似事情的构造函数中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_c</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="built_in">class_c</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">class_c</span>(<span class="type">int</span> my_max)&#123;</span><br><span class="line">        max=my_max &gt; <span class="number">0</span> ? my_max : <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">class_c</span>(<span class="type">int</span> my_max, <span class="type">int</span> my_min) &#123;</span><br><span class="line">        max = my_max &gt; <span class="number">0</span> ? my_max : <span class="number">10</span>;</span><br><span class="line">        min = my_min &gt; <span class="number">0</span> &amp;&amp; my_min &lt; max ? my_min : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">class_c</span>(<span class="type">int</span> my_max, <span class="type">int</span> my_min, <span class="type">int</span> my_middle) &#123;</span><br><span class="line">        max = my_max &gt; <span class="number">0</span> ? my_max : <span class="number">10</span>;</span><br><span class="line">        min = my_min &gt; <span class="number">0</span> &amp;&amp; my_min &lt; max ? my_min : <span class="number">1</span>;</span><br><span class="line">        middle = my_middle &lt; max &amp;&amp; my_middle &gt; min ? my_middle : <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-31.png" alt="alt text"></p>
<ul>
<li>代理可以进行串联</li>
<li>前提是构造函数是重载的</li>
</ul>
<ul>
<li>当一个构造函数委托给另一个构造函数(称为目标构造函数)时，<strong>目标构造函数会先执行，然后才执行委托构造函数的剩余代码</strong></li>
<li><p>一个构造函数不能同时委托给其它构造函数且使用初始化列表初始化成员变量</p>
<ul>
<li>在构造函数内赋值(而非使用初始化列表)是次优选择们应该优先使用初始化列表。如果允许在使用构造函数的同时初始化替他成员将会使初始化顺序难以定义</li>
</ul>
</li>
<li><p>代理关系可以形成一个<code>link</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Info</span>():<span class="built_in">Info</span>(<span class="number">1</span>)&#123;&#125;<span class="comment">//delegating</span></span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i):<span class="built_in">Info</span>(i,<span class="string">&#x27;a&#x27;</span>)&#123;&#125;<span class="comment">//target&amp;delegating</span></span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">char</span> e):<span class="built_in">Info</span>(<span class="number">1</span>,e)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> i,<span class="type">char</span> e):<span class="built_in">type</span>(i),<span class="built_in">name</span>(e)&#123;&#125;<span class="comment">//target</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>但是link不能形成闭环</li>
</ul>
<h3 id="8-3-Default-arguments"><a href="#8-3-Default-arguments" class="headerlink" title="8.3 Default arguments"></a>8.3 Default arguments</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stash</span>(<span class="type">int</span> size,<span class="type">int</span> initQuantity=<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>默认参数是指在函数声明时给出的参数的值，如果在调用函数时没有提供特定值编译器会自动给参数插入默认值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">harpo</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m = <span class="number">4</span>,<span class="type">int</span> j = <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chico</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m = <span class="number">6</span>,<span class="type">int</span> j)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">groucho</span><span class="params">(<span class="type">int</span> k=<span class="number">1</span>;<span class="type">int</span> m=<span class="number">2</span>;<span class="type">int</span> n=<span class="number">3</span>)</span></span>;</span><br><span class="line">beeps=<span class="built_in">harpo</span>(<span class="number">2</span>);</span><br><span class="line">beeps=<span class="built_in">harpo</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">beeps=<span class="built_in">harpo</span>(<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>默认参数必须从右向左依次定义<ul>
<li>如果某个参数有默认值，那么它右侧的参数也必须有默认值</li>
<li>不允许“跳过”右侧参数直接为左侧参数指定默认值</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">20</span>)</span></span>;  <span class="comment">// 正确：默认参数从右向左</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b, <span class="type">int</span> c = <span class="number">20</span>)</span></span>;  <span class="comment">// 错误：b 没有默认值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原理：C++在调用函数时，参数是按照从左到右的顺序压栈的，如果允许左侧参数默认值优先，编译器无法推断中间哪些参数被忽略</li>
</ul>
<h4 id="Pitfall-of-default-arguments"><a href="#Pitfall-of-default-arguments" class="headerlink" title="Pitfall of default arguments"></a>Pitfall of default arguments</h4><ul>
<li>默认参数只能在函数声明(原型)中指定，不能在函数定义中重复</li>
<li>默认参数可能被不规范的声明覆盖：如果函数有多个声明(如不同的头文件中)且默认参数不一致会导致未定义行为</li>
<li>默认参数的初始化顺序依赖：默认参数的值在调用点确定，而非函数定义点。如果默认参数是全局变量或表达式，其值可能被意外修改<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> default_val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x = default_val)</span></span>;  <span class="comment">// 默认参数依赖全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    default_val = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// x=20，而非 10！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="8-4-Inline-Function-内联函数"><a href="#8-4-Inline-Function-内联函数" class="headerlink" title="8.4 Inline Function(内联函数)"></a>8.4 Inline Function(内联函数)</h3><ul>
<li>内联函数在编译时将函数的目标代码插入每个调用该函数的地方<h4 id="Overhead-for-a-function-call-函数调用的额外开销"><a href="#Overhead-for-a-function-call-函数调用的额外开销" class="headerlink" title="Overhead for a function call(函数调用的额外开销)"></a>Overhead for a function call(函数调用的额外开销)</h4></li>
<li>在执行一条命令之前需要设备花费的时间<ul>
<li>Push parameters</li>
<li>Push return address<br>…</li>
<li>Prepare the return value</li>
<li>Pop all pushed</li>
</ul>
</li>
</ul>
<h4 id="Inline-functions"><a href="#Inline-functions" class="headerlink" title="Inline functions"></a>Inline functions</h4><ul>
<li>An inline function is to be expanded in place, like a preprocessor macro, so theoverhead of the function call is eliminated.内联函数会在调用处原地展开，类似于预处理宏，从而消除函数调用的开销</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在定义和声明中要重复出现关键字<code>inline</code></li>
<li><p>一个内联函数的定义可能不会在obj文件中生成任何代码</p>
</li>
<li><p>必须将内联函数的函数体放在头文件中，然后进行<code>include</code>操作：内联函数在编译时会被直接展开到调用位置(类似宏替换)，因此<strong>编译器在每个调用函数的源文件中都需要看到其完整定义</strong></p>
</li>
<li>不需要担心内联函数的多次定义，内联函数的定义都只是声明因为他们毕竟没有函数体</li>
<li>所有源文件中包含的内联函数定义必须<strong>完全一致</strong>(否则将会被视作未定义行为)</li>
<li>内联函数可以消除函数调用的额外开销</li>
<li>任何定义在类的声明内部的函数都是被自动地视为inline</li>
<li>编译器不必满足你将函数声明为inline的请求，它可能判定该函数过大，或发现函数调用了自身(递归在inline函数既不被允许也不可能实现)，又或者你所用的特定编译器可能未实现此功能</li>
<li>Pitfall of inline<ul>
<li>可以将内联成员函数的定义放在类的大括号外部。</li>
<li>但这些函数的定义必须放在可能被调用的位置之前，这种情况下应该放在头文件中，而不能定义在即将使用的cpp文件中，会导致链接错误</li>
</ul>
</li>
<li>在类内部定义的成员函数采用就地定义方式，但为了保持接口的整洁性，建议将所有定义放在类外部<h4 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h4></li>
<li>Inline:<ul>
<li>小型函数，只有两到三行</li>
<li>频繁被调用(如循环体内部)</li>
</ul>
</li>
<li>Not Inline:<ul>
<li>超过20行的大型函数</li>
<li>递归的函数<h3 id="8-5-内联变量"><a href="#8-5-内联变量" class="headerlink" title="8.5 内联变量"></a>8.5 内联变量</h3></li>
</ul>
</li>
<li>为何引入内联变量</li>
</ul>
<p>在C++17之前，在头文件中定义变量会导致问题，因为每个包含该头文件的翻译单元(即.cpp文件)都会生成该变量的独立副本。这经常会导致链接阶段出现多重定义错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constants.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;  <span class="comment">// 每个包含该头文件的.cpp都会生成自己的MAX_SIZE副本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接时可能产生&quot;ODR(One Definition Rule)违规&quot;</span></span><br></pre></td></tr></table></figure>
<p>为避免此问题，变量通常需要在头文件中用extern声明，并在单个.cpp文件中定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// source.cpp</span></span><br><span class="line"><span class="type">int</span> globalValue = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式虽然可行，但是需要将声明和定义分离，并不总是方便</p>
<p>使用内联变量，可以直接在头文件中定义变量而不会导致链接错误</p>
<ul>
<li>内联变量的特性<ul>
<li>跨翻译单元的单一定义：编译器确保即使变量被多个文件包含，也只会存在一个实例</li>
<li>头文件中的初始化：可以在头文件中同时声明和初始化变量，使代码更加清晰</li>
<li>适用于全局或静态变量：非常适合全局变量、类的静态成员</li>
</ul>
</li>
<li>何时使用内联变量<ul>
<li>在头文件中定义全局常量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="type">int</span> MAX_CONNECTIONS = <span class="number">1000</span>;  <span class="comment">// 所有包含文件共享同一常量</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> std::string_view API_URL = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>当静态类成员需要在类定义中直接初始化时<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> logLevel = <span class="number">1</span>;  <span class="comment">// 直接初始化静态成员</span></span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> std::mutex logMutex;  <span class="comment">// 甚至可用于线程安全控制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>需要在多个头文件中保持变量单一定义时</li>
<li>简化配置值或设置的管理时</li>
</ul>
</li>
<li>何时不使用内联变量<ul>
<li>避免对大型对象或占用大量内存的变量使用内联，可能导致不必要的内存占用</li>
<li>不要用于在每个翻译单元有独立实例的变量<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// counter.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> counter = <span class="number">0</span>;  <span class="comment">// 所有文件共享同一个计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; ++counter; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; ++counter; &#125;  <span class="comment">// 操作的是同一个全局变量</span></span><br></pre></td></tr></table></figure></li>
<li>谨慎对待运行时可能被修改的变量，可能导致意外的副作用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// config.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> debugMode = <span class="literal">false</span>;  <span class="comment">// 危险！所有修改会影响所有包含文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同.cpp文件可能产生竞争条件</span></span><br></pre></td></tr></table></figure>
<h3 id="8-6-Weak"><a href="#8-6-Weak" class="headerlink" title="8.6 Weak"></a>8.6 Weak</h3>弱符号(weak)与内联(inline)的区别</li>
</ul>
</li>
</ul>
<p>inline和weak是两个不同的关键字，用于不同的目的，主要涉及函数和变量的处理</p>
<ul>
<li>链接阶段作用：这两个关键字都与编译过程中链接阶段的符号管理有关</li>
<li>允许多重定义：在特定条件下，它们都允许多个定义存在而不会导致链接错误</li>
</ul>
<h2 id="9-Composition"><a href="#9-Composition" class="headerlink" title="9 Composition"></a>9 Composition</h2><ul>
<li>Composition:construct new object with existing objects.用已有的对象创建对象</li>
<li>对象可以用来构建其它对象</li>
<li>包含的方式<ul>
<li>对象内部有其它对象(Fully)</li>
<li>通过引用或指针访问其它对象(by reference)</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-32.png" alt="alt text"><br><img src="/2025/04/07/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1Object-Oriented-Programming/image-33.png" alt="alt text"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Currency</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SavingAccount</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SavingAccount</span>(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* name,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* address,</span><br><span class="line">        <span class="type">int</span> cents</span><br><span class="line">    );</span><br><span class="line">    ~<span class="built_in">SavingAccount</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person m_server;</span><br><span class="line">    Currency m_balance;</span><br><span class="line">&#125;</span><br><span class="line">SavingAccount::<span class="built_in">SavingAccount</span>(</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name,</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* address,</span><br><span class="line">    <span class="type">int</span> cents</span><br><span class="line">):<span class="built_in">m_saver</span>(name,address),<span class="built_in">m_balance</span>(<span class="number">0</span>,cents)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SavingAccount::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_saver.<span class="built_in">print</span>();</span><br><span class="line">    m_balance.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在类被初始化之前，子类先被初始化</p>
</blockquote>
<h3 id="Embedded-objects"><a href="#Embedded-objects" class="headerlink" title="Embedded objects"></a>Embedded objects</h3><ul>
<li>所有被嵌入的对象都要被初始化<ul>
<li>当没有提供参数并且有默认构造函数(或者可以自动生成一个)那么构造函数会被调用</li>
</ul>
</li>
<li>构造函数可以包含初始化列表<ul>
<li>可以包含多个对象，用逗号分隔</li>
<li>这时可选的</li>
<li>用于向子构造函数提供参数</li>
</ul>
</li>
<li>析构函数会被自动调用，先析构类自身，再析构子类</li>
</ul>
<h3 id="Remember"><a href="#Remember" class="headerlink" title="Remember"></a>Remember</h3><ul>
<li>如果我们这样编写构造函数(假设子对象有相应的set访问器)：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SavingsAccount::<span class="built_in">SavingsAccount</span>(</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name, </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* address, </span><br><span class="line">    <span class="type">int</span> cents) &#123;</span><br><span class="line">    m_saver.<span class="built_in">set_name</span>(name);</span><br><span class="line">    m_saver.<span class="built_in">set_address</span>(address);</span><br><span class="line">    m_balance.<span class="built_in">set_cents</span>(cents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种情况下，默认构造函数仍然会被调用</li>
</ul>
<p>这种写法会导致</p>
<ul>
<li>不必要的默认构造：先构造默认函数，然后立即覆盖</li>
<li>效率低下：对于复杂的对象，可能造成双重初始化</li>
</ul>
<p>推荐做法依然是使用初始化列表直接初始化</p>
<h3 id="public-vs-private"><a href="#public-vs-private" class="headerlink" title="public vs private"></a>public vs private</h3><ul>
<li>通常将嵌入对象设为私有<ul>
<li>它们是底层实现的一部分</li>
<li>新类只继承原类(嵌入式对象)的部分公共接口</li>
<li>具有封装性好(隐藏实现细节，只暴露必要的接口)，安全性高(防止外部直接修改内部状态)，灵活性(可以修改内部实现而不影响客户端代码)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person m_saver;  <span class="comment">// 私有嵌入式对象</span></span><br><span class="line">    Money m_balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSaverName</span><span class="params">(<span class="type">const</span> string&amp; name)</span> </span>&#123;</span><br><span class="line">        m_saver.<span class="built_in">set_name</span>(name);  <span class="comment">// 通过包装方法控制访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 其他接口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果需要在新对象中完全保留子对象的所有公共接口，可以将嵌入式对象设为public<ul>
<li>需要完全暴露子对象的所有功能</li>
<li>组合类只是子对象的简单容器</li>
<li>需要保持与子对象接口的完全兼容性<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person m_saver;  <span class="comment">// 公开的嵌入式对象</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设Person类有set_name()方法</span></span><br><span class="line">SavingsAccount account;</span><br><span class="line">account.m_saver.<span class="built_in">set_name</span>(<span class="string">&quot;Fred&quot;</span>);  <span class="comment">// 直接访问嵌入式对象的公共接口</span></span><br></pre></td></tr></table></figure>
<h3 id="Fully-vs-reference"><a href="#Fully-vs-reference" class="headerlink" title="Fully vs reference"></a>Fully vs reference</h3></li>
</ul>
</li>
<li>“Fully”表示”对象就在这里，作为对象的一部分”，而通过引用表示”对象在别处”</li>
<li>对于完全包含的对象，构造函数和析构函数会被自动调用，而通过引用则需要手动初始化和销毁对象</li>
<li>引用方式通常用于一下情况：<ul>
<li>逻辑上不属于”完全包含”关系</li>
<li>对象大小在开始时未知</li>
<li>资源需要在运行时分配/连接</li>
</ul>
</li>
<li>其它OOP语言只使用引用方式</li>
</ul>
<h4 id="Fully"><a href="#Fully" class="headerlink" title="Fully"></a>Fully</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;&#125;; <span class="comment">// 引擎类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Engine engine; <span class="comment">// 完全包含的引擎对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象内存作为父对象的一部分分配</li>
<li>生命周期管理：<ul>
<li>构造：父对象构造时自动构造</li>
<li>析构：父对象析构时自动析构</li>
</ul>
</li>
<li>访问速度快</li>
<li>大小固定(编译时确定)</li>
</ul>
<h4 id="By-reference"><a href="#By-reference" class="headerlink" title="By reference"></a>By reference</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Engine* engine; <span class="comment">// 通过指针引用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Car</span>() : <span class="built_in">engine</span>(<span class="keyword">new</span> <span class="built_in">Engine</span>()) &#123;&#125; <span class="comment">// 手动构造</span></span><br><span class="line">    ~<span class="built_in">Car</span>() &#123; <span class="keyword">delete</span> engine; &#125;      <span class="comment">// 手动析构</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>存储的是对象的指针/引用 </li>
<li>生命周期管理<ul>
<li>需要显式创建和销毁对象</li>
<li>可以使用只能指针简化管理</li>
</ul>
</li>
<li>更灵活<ul>
<li>可以延迟初始化</li>
<li>可以动态改变引用的对象</li>
<li>支持多态<h3 id="Clock-Display"><a href="#Clock-Display" class="headerlink" title="Clock Display"></a>Clock Display</h3></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机体系结构(Computer Architecture)</title>
    <url>/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/</url>
    <content><![CDATA[<h1 id="Chapter-1-Fundamentals-of-Computer-Design"><a href="#Chapter-1-Fundamentals-of-Computer-Design" class="headerlink" title="Chapter 1:Fundamentals of Computer Design"></a>Chapter 1:Fundamentals of Computer Design</h1><h2 id="Part-One-Introduction"><a href="#Part-One-Introduction" class="headerlink" title="Part One: Introduction"></a>Part One: Introduction</h2><ul>
<li>冯诺依曼架构：存算分离</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image.png" alt="alt text"></p>
<h3 id="计算机的分类（及关键的系统特征）"><a href="#计算机的分类（及关键的系统特征）" class="headerlink" title="计算机的分类（及关键的系统特征）"></a>计算机的分类（及关键的系统特征）</h3><ul>
<li>Personal Mobile Devices(个人移动设备)：成本、能耗、媒体性能、响应速度</li>
<li>Desktop Computers(桌面计算机)：性价比、能耗、图形性能</li>
<li>Servers Computers(服务器)：吞吐量、可用性、可扩展性（规模）、能耗</li>
<li>Embedded Computers(物联网/嵌入式计算机):价格、能耗、应用的特有性能</li>
<li>Supercomputers(超级计算机/集群、仓库计算机)：性价比、吞吐量、能耗均衡性</li>
</ul>
<h3 id="计算机并行"><a href="#计算机并行" class="headerlink" title="计算机并行"></a>计算机并行</h3><ul>
<li>数据集并行(DLP)：使某些数据选项可以同时操作</li>
<li><p>任务机并行(TLP): 创建的工作任务可以单独执行 并且主要采用并行方式执行</p>
</li>
<li><p>Flynn’s Class(根据数据流与指令流)</p>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-1.png" alt="alt text"></p>
<h2 id="Part-Two-Performance"><a href="#Part-Two-Performance" class="headerlink" title="Part Two: Performance"></a>Part Two: Performance</h2><ul>
<li>影响性能的因素：体系结构，硬件实现，编译器，OS等</li>
<li>衡量性能的方法<ul>
<li>Single users on a PC-&gt;响应时间的最小值</li>
<li>Large Data-&gt;吞吐量的最大值</li>
</ul>
</li>
<li>响应时间与吞吐量<ul>
<li>响应时间：response time或称为latency，一个事件开始到结束的时间，如一次访问需要多长时间</li>
<li>吞吐量：throughput，也称作(bandwith带宽)：给定时间范围内完成了多少的工作量</li>
</ul>
</li>
<li>体系结构的主要目标就是<strong><em>提升系统的性能</em></strong>，如每秒传输的字节数</li>
</ul>
<h2 id="Part-Three-Technology-Trend"><a href="#Part-Three-Technology-Trend" class="headerlink" title="Part Three: Technology Trend"></a>Part Three: Technology Trend</h2><p>The improvement of computer architecture </p>
<ul>
<li>输入输出的进步</li>
<li>内存组织结构的发展</li>
<li>指令集的发展方向<ul>
<li>CISC</li>
<li>RISC</li>
</ul>
</li>
<li>并行执行技术（不同层次（系统程序算法等）、粒度（任务的大小或复杂度）的并行）</li>
</ul>
<h2 id="Part-Four-Quantitive-Approaches"><a href="#Part-Four-Quantitive-Approaches" class="headerlink" title="Part Four:Quantitive Approaches"></a>Part Four:Quantitive Approaches</h2><ol>
<li>CPU Performance</li>
</ol>
<ul>
<li>$CPU Time=IC \times CPI \times clock cycle time$</li>
<li>$CPI=1+\sum_{i=1}^{n}P_i$<ul>
<li>CPI由硬件决定</li>
<li>不同的指令也会有不同的CPI，平均CPI取决于指令的组合方式</li>
<li>$CPU Cycles=IC \times CPI $</li>
</ul>
</li>
</ul>
<ol>
<li>Amdahl’s Law</li>
</ol>
<ul>
<li>使用某种快速执行模式获得的性能改进受限于可使用此种模式的时间比例。当提升系统性能时，可以计算出通过改进计算机某一部分而获得的性能增益</li>
<li>$T_{improved}=\dfrac{T_{affected}}{\text{improvement factor}}+T_{unaffected}$</li>
<li>加速比(SP)：改进前后执行时间正比或性能反比<script type="math/tex; mode=display">
\begin{align*}
\text{Speedup} & = \dfrac{\text{Performance for entire task}_\text{using Enhancement}}{\text{Performance for entire task}_\text{without Enhancement}} \\
& = \dfrac{\text{Total Execution Time}_\text{without Enhancement}}{\text{Total Execution Time}_\text{using Enhancement}}
\end{align*}</script></li>
<li>执行时间(f指改进部分所占的比例)<br>$T_{new} = T_{old}\times \left((1-f)+\dfrac{f}{Sp}\right)$</li>
<li>改进系数(f)：改进部分的执行时间占整个任务时间的比例<ul>
<li>其中Sp为被优化部分的加速比，$Sp_{overall}$为整体加速比，f为被优化部分所占的运行时间比例。<h2 id="Part-Five-Great-Architecture-Ideas"><a href="#Part-Five-Great-Architecture-Ideas" class="headerlink" title="Part Five:Great Architecture Ideas"></a>Part Five:Great Architecture Ideas</h2></li>
</ul>
</li>
<li>摩尔定律：每过 18-24 个月，集成电路的晶体管数量将增加一倍</li>
<li>使用抽象来简化设计</li>
<li>让最常见的情况更快</li>
<li>通过并行来提高性能</li>
<li>由很多级别的并行，比如指令集并行、进程并行等</li>
<li>通过流水线来提高性能<ul>
<li>将任务分为多段，让多个任务的不同阶段同时进行</li>
<li>通常用来提高指令吞吐量</li>
</ul>
</li>
<li>通过预测来提高性能</li>
<li>使用层次化的内存<ul>
<li>让最常访问的数据在更高层级，访问更快(Memory Hierarchy)<h2 id="Part-Six-Ideas"><a href="#Part-Six-Ideas" class="headerlink" title="Part Six:Ideas"></a>Part Six:Ideas</h2></li>
</ul>
</li>
<li>Instruction Set Architecture(ISA)<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-2.png" alt="alt text"></li>
</ul>
<p>Instruction Set Design Issues</p>
<ul>
<li>ISA分类</li>
<li>存储器寻址</li>
<li>寻址模式</li>
<li>操作数的类型和大小</li>
<li>操作指令</li>
<li>控制流指令</li>
<li>ISA的编码</li>
</ul>
<h2 id="Part-Seven-Trends-in-power-and-Energy-in-Integrated-circuits"><a href="#Part-Seven-Trends-in-power-and-Energy-in-Integrated-circuits" class="headerlink" title="Part Seven:Trends in power and Energy  in Integrated circuits"></a>Part Seven:Trends in power and Energy  in Integrated circuits</h2><ol>
<li>Trends in power</li>
</ol>
<ul>
<li>Challenges<ul>
<li>distributing the power</li>
<li>removing the heat</li>
<li>preventing hot spot</li>
</ul>
</li>
<li>节能的技术<ul>
<li>以逸待劳（Do nothing well）:关闭 非活动模块时钟</li>
<li>动态电压—频率调整(DVFS):活跃程度较低的时期不需要以最高始终频率和电压运转</li>
<li>针对典型情景的设计(Design for typical case):<ul>
<li>Lower power modes(LPM)-save power</li>
<li>Can not access DRAM or DISK when in LPM</li>
</ul>
</li>
<li>超频(Overclocking)：在执行单线程代码时，微处理器可以仅留下一个核，并使其以更高时钟频率运行而其他所有核均被关闭</li>
<li>竞相暂停(race-to-halt):由于处理器只是系统整体能耗的一部分，所以如果使用一个速度较快但能效较低的处理器，使系统其他部分能够进入睡眠模式，可能有助于降低整体能耗</li>
</ul>
</li>
</ul>
<ol>
<li>微处理器内部的能耗和功率</li>
</ol>
<ul>
<li><p>动态功率：开关晶体管的能耗</p>
<ul>
<li>逻辑转换脉冲0-&gt;1-&gt;0或者1-&gt;0-&gt;1的能耗：<script type="math/tex; mode=display">
Energy_{dynamic}=Capacity\ load \times Voltage^2</script></li>
<li>一次转换的功率为<script type="math/tex; mode=display">
Energy_{dynamic}=\frac12 \times Capacity\ load \times Voltage^2 \times Frequency\ switched</script></li>
<li>对于一项固定任务，降级时钟频率可以降低功率，但不会降低能耗</li>
</ul>
</li>
<li><p>静态功率：晶体管因漏电而关断时的功耗</p>
<script type="math/tex; mode=display">
Power_{static}=current\ static \times Voltage</script></li>
</ul>
<ol>
<li>Multiple core deliver more performance per watt</li>
</ol>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-3.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-4.png" alt="alt text"></p>
<ul>
<li>由于多核通讯，资源占用等问题，多核多线程会在达到峰值后回落<h2 id="Part-Seven-Cost-Trend"><a href="#Part-Seven-Cost-Trend" class="headerlink" title="Part Seven:Cost Trend"></a>Part Seven:Cost Trend</h2></li>
</ul>
<ol>
<li>Time,Volume and Commodification(时间、产量和大众化)</li>
</ol>
<ul>
<li>时间：即使基本的实现技术没有取得任何重大进步，计算机组件的制造成本也会随着时间的推移而降低<ul>
<li>成本下降的背后基本原理是学习曲线：制造成本随时间的推移而降低。学习曲线本身根据良率的变化预测（良率：成功通过测试的器件占所生产器件总数占总件数的百分比），良率翻倍的设计就能使成本减半</li>
</ul>
</li>
<li>产量：从两个方面影响成本<ul>
<li>产量的提高减少了完成学习曲线所需的时间，该时间在一定程度上与系统(或芯片)的制造数量成正比</li>
<li>产量的增加会提高购买与制造效率，所以会降低成本。<br>产量每增加一倍，成本会降低百分之十</li>
</ul>
</li>
</ul>
<ol>
<li>大众化：指多家供应商大量出售且基本相同的产品。市场的竞争会降低成本。</li>
</ol>
<ul>
<li>产量会提高，但是利润会被限制</li>
</ul>
<ul>
<li>Learning Curve：</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-5.png" alt="alt text"></p>
<h2 id="Part-Eight-Reliability-可信任度"><a href="#Part-Eight-Reliability-可信任度" class="headerlink" title="Part Eight:Reliability(可信任度)"></a>Part Eight:Reliability(可信任度)</h2><p>容错与系统可靠性领域</p>
<ul>
<li>Definition</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-6.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-7.png" alt="alt text"></p>
<ol>
<li>如何判断一个系统的运行是否正常，基础供应商开始提供服务等级协议（service level agreement,SLA）或服务等级目标（service level subject,SLO）</li>
</ol>
<ul>
<li>服务完成（service agreement）:提供了SLA的指定服务</li>
<li>服务中断(service interrution)：即所提供的服务与SLA不一致</li>
<li>两种状态之间的转换由故障（Failure）或恢复（Restoration）导致<ul>
<li>Failures:$S_{accomplishment}-&gt;S_{interruption}$</li>
<li>Restorations:$S_{interruption}-&gt;S_{accomplishment}$</li>
</ul>
</li>
</ul>
<ol>
<li>信任度的度量</li>
</ol>
<ul>
<li>Module Reliability:从参考初始时刻开始的连续的服务完成情况的度量（对发生故障之前的时间的度量）<ul>
<li>MTTF:平均无故障时间（Mean Time To Failure）</li>
<li>MTTR:平均故障恢复时间（Mean Time To Restoration）</li>
<li>FIT:故障发生频率（Failure Instance Time），MTTF的倒数以运行十亿小时发生的故障来表示</li>
<li>MTBF:平均故障间隔时间。MTBF=MTTF+MTTR</li>
</ul>
</li>
<li>Module availability:指在服务完成与服务中断两种状态之间切换时，对服务完成情况的度量<script type="math/tex; mode=display">
Mobile\ availability=\frac{MTTF}{MTTF+MTTR}</script></li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/80490de52ca29ff9f802330018d4b18.jpg" alt="alt text"></p>
<ol>
<li>解决故障的方法：冗余(Rebundancy)</li>
</ol>
<ul>
<li>时间冗余：重复操作，以查看是否仍然存在错误</li>
<li>资源冗余：当一个组件故障时，由其他组件接管<h2 id="Part-Nine-Measuring-Reporting-and-summerizing-Perf-性能的测量、报告和汇总"><a href="#Part-Nine-Measuring-Reporting-and-summerizing-Perf-性能的测量、报告和汇总" class="headerlink" title="Part Nine:Measuring,Reporting and summerizing Perf(性能的测量、报告和汇总)"></a>Part Nine:Measuring,Reporting and summerizing Perf(性能的测量、报告和汇总)</h2></li>
</ul>
<ol>
<li>性能的测量</li>
</ol>
<ul>
<li>机器之间的比较<ul>
<li>Execution Time(Latency)</li>
<li>Throughout</li>
<li>MIPS:millions of instructions per second</li>
</ul>
</li>
<li>使用程序进行机器之间的比较<ul>
<li>选择程序来评估性能<ul>
<li>Benchmark Suites</li>
</ul>
</li>
<li>Different Means:Arithmetic,Harmonic,and Geometric Means</li>
</ul>
</li>
<li><p>对于不同的使用者和设计者性能评估的标准是不同的</p>
</li>
<li><p>执行时间的定义方式（根据测量内容的不同）</p>
<ul>
<li>挂钟时间（Wall-clock time）,也叫做响应时间(response time)或者已用时间(elapsed time):完成一项任务的延迟时间，包括外存访问、输入输出活动、操作系统开销等所有相关时间。</li>
<li>在多个程序同时运行多个程序的情况下，处理器等待I/O时处理另一个程序不一定使挂钟时间缩小至最短</li>
<li>CPU时间：处理器执行计算的时间而不包括等待I/O计算或运行其他程序的时间<ul>
<li>User Time:用户模式下的执行时间</li>
<li>System Time:操作系统的执行时间</li>
</ul>
</li>
<li>用户观测到的响应时间是程序的挂钟时间而不是CPU Time</li>
</ul>
</li>
<li>管理员衡量系统性能的视角：给定时间内完成的工作数量</li>
<li>我们通常使用吞吐量进行测量：单位时间内完成的工作数量</li>
<li><p>通常使用相对延迟来反映系统的性能</p>
</li>
<li><p>如果想要改进response time，通常使用改进吞吐率的方法</p>
<ul>
<li>使用速度更快版本的计算机的处理器</li>
</ul>
</li>
<li><p>提升系统的吞吐率可以不改进response Time</p>
<ul>
<li>对于分立的任务在多核处理系统中增加额外的处理器</li>
</ul>
</li>
<li><p>MIPS：Millions of Instructions Per Second</p>
<script type="math/tex; mode=display">
MIPS = \frac{\frac{\text{number of instructions}}{\text{benchmark}} \times \frac{\text{benchmark}}{\text{total run time}}}{1000000}</script></li>
<li><p>不同视角使用的不同测量方法</p>
<ul>
<li>Execution time<ul>
<li>用户视角</li>
<li>系统性能</li>
<li>唯一的不容置疑的</li>
</ul>
</li>
<li>CPU Time<ul>
<li>设计者视角</li>
<li>CPU性能</li>
</ul>
</li>
<li>吞吐量<ul>
<li>管理者视角</li>
</ul>
</li>
<li>MIPS<ul>
<li>供应商视角</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>基准测试<br>使用远比实际应用程序简单的程序</li>
</ol>
<ul>
<li>程序内核(Kernal):即实际应用程序中短小、关键的部分</li>
<li>玩具程序：即为了完成编程入门作业而编写的小程序，通常不超过100行，比如快速排序</li>
<li>合成基准测试程序(Sythentic Benchmark):即为了匹配实际应用程序的特征和行为而编写的虚拟程序，比如Dhrystone</li>
</ul>
<blockquote>
<p>现在三种方法都受到了质疑，主要是因为编译器的编写人员和架构师可以串通起来使计算机在执行这些替代程序的时候显得比运行时及应用程序时更快。</p>
<ul>
<li>为了避免太多鸡蛋放在同一个篮子里所带来的问题，一种流行的做法是基准测试应用程序集（称为基准测试套件）：套件的准确率不会超过组成该套件的各个基准测试。<ul>
<li>不过，这种套件的主要优势在于，任何一个基准测试的弱点都会因为其他基准测试的存在而淡化。基准测试套件的目的是描述两台计算机的实际相对性能，特别是对于客户可能会运行的不在该套件中的程序</li>
</ul>
</li>
</ul>
<ol>
<li>Total Execution Time</li>
</ol>
<ul>
<li>Arithmetic mean(算术平均)：$\frac1n \Sigma_{i=1}^n Time_i$ </li>
<li>如果性能以rate的形式表达，那么平均总时间是harmonic mean(调和平均)：$\frac{n}{\Sigma_{i=1}^n \frac{1}{Rate_i}}$</li>
<li>当我们很那知道具体的比例时，我们可以进行以一个程序为标准进行转换</li>
</ul>
</blockquote>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-8.png" alt="alt text"></p>
<p>权重的计算</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-9.png" alt="alt text"></p>
<blockquote>
<p>不同程序跑单位时间程序的执行次数作为权重</p>
<blockquote>
<p>这时不同参考基得到的权值是不同的</p>
</blockquote>
</blockquote>
<ul>
<li>Geometric mean(几何平均)：$\sqrt[n]{\prod_{i=1}^n Relative_Rate_i}$=$\frac{\sqrt[n]{\prod_{i=1}^n Rate_i}}{Rate_{ref}}$<blockquote>
<p>几何平均的=得到的权值与参考基的选择是无关的</p>
<blockquote>
<p>本身没有物理意义，不能预测运行时间</p>
<script type="math/tex; mode=display">
\frac{Geometric\ mean(X_i)}{Geometric\ mean(Y_i)}=Geometric\ mean(\frac{X_i}{Y_i})</script></blockquote>
</blockquote>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-11.png" alt="alt text"></p>
<h2 id="Part-Ten-Quantitive-Principles-量化设计原理"><a href="#Part-Ten-Quantitive-Principles-量化设计原理" class="headerlink" title="Part Ten:Quantitive Principles(量化设计原理)"></a>Part Ten:Quantitive Principles(量化设计原理)</h2><ol>
<li>充分利用并行</li>
</ol>
<ul>
<li>系统级并行(system)：使用多个处理器 </li>
<li>指令级并行(Instruction)：使用流水线技术</li>
<li>操作级并行(operation)：<ul>
<li>组相联cache</li>
<li>流水线功能单元(如ALU等)</li>
</ul>
</li>
</ul>
<ol>
<li>局部性原理</li>
</ol>
<ul>
<li>程序原理：程序会趋向于再次使用最近使用过的数据和指令</li>
<li>Rule of Thumb(经验法则):a program spends 90% of its execution time in only 10% of the code(程序的大部分时间都集中在少数关键代码段上，其余大部分代码对整体性能的影响较小)</li>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
<ol>
<li>重点关注常见情形</li>
<li>Amdahl Law(阿姆达尔公式)</li>
</ol>
<ul>
<li>原计算机计算时间中可改进部分所占的比例</li>
<li>通过改进执行模式得到的改进，也就是说在为整个程序使用这一执行模式时，任务的运行速度会提高多少倍</li>
<li>部件的加速比的极限值是$\frac{1}{1-F}$</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-12.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-13.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-14.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-15.png" alt="alt text"></p>
<ul>
<li>注意时间比(fraction)不能按照IC的比例，而是要按照时间的比例(CPU Time)<h1 id="Chapter-2-Pipeline"><a href="#Chapter-2-Pipeline" class="headerlink" title="Chapter 2:Pipeline"></a>Chapter 2:Pipeline</h1><h2 id="1-What-is-pipeline"><a href="#1-What-is-pipeline" class="headerlink" title="1. What is pipeline"></a>1. What is pipeline</h2>从两个角度进行加速：对每一条指令进行加速；对一段程序的执行进行加速</li>
</ul>
<p>机制上，先进行分段，每一段用不同的部件，就可以并行执行。我们用buffer存放各个阶段的中间结果</p>
<p>执行的模式有三种</p>
<ul>
<li>Sequential execution</li>
<li>Single overlapping execution</li>
<li>Twice overlapping execution</li>
</ul>
<h3 id="1-1-Sequential-execution"><a href="#1-1-Sequential-execution" class="headerlink" title="1.1 Sequential execution"></a>1.1 Sequential execution</h3><p>没有流水线的时候每一条指令顺序执行，执行时间就是每一条指令的每个阶段时间求和</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-16.png" alt="alt text"></p>
<p>时间就是所有指令时间之和</p>
<h3 id="1-2-Overlapping-execution"><a href="#1-2-Overlapping-execution" class="headerlink" title="1.2 Overlapping execution"></a>1.2 Overlapping execution</h3><p>重叠执行，如果不同阶段时间不一致，如ID阶段时间较长，那么需要等待浪费资源；如果EX阶段时间较长，那么产生冲突，执行部件不够。</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-17.png" alt="alt text"></p>
<ul>
<li>ID阶段的时间较长，那么其他阶段的执行单元会等待，资源就会浪费</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-18.png" alt="alt text"></p>
<ul>
<li>EX阶段时间较长，可能会出现执行单元不够用的情况，导致流水线堵塞</li>
</ul>
<p>理想情况下是让三个阶段的时间相等</p>
<ul>
<li><p>Single Overlapping</p>
<ul>
<li>相较于顺序执行，时间缩短$\frac13$，同时功能部件的利用率得到明显改善</li>
<li>提高了硬件开销(增加功能单元以用来调度流水线)，而且有冒险(由于指令之间存在依赖关系可能产生冲突)</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-19.png" alt="alt text"></p>
<ul>
<li><p>Twice Overlapping</p>
<ul>
<li>时间可以减少近$\frac23$，部件利用率更高<br>需要更复杂的硬件，而且需要单独的Fetch Decode EXE部件</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-20.png" alt="alt text"></p>
<h3 id="1-3-如何实现重叠？-buffer"><a href="#1-3-如何实现重叠？-buffer" class="headerlink" title="1.3 如何实现重叠？- buffer"></a>1.3 如何实现重叠？- buffer</h3><p>Adding instruction buffer between memory and instruction decode unit.直接在buffer中取指，大大缩短取指时间。</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-21.png" alt="alt text"></p>
<ul>
<li>使取数、存数、传输等操作的时间大大缩短，使所有执行时间都集中在ALU无法缩短</li>
</ul>
<p>The structure of processor with advanced control</p>
<p>添加 buffer 之后，IF 阶段时间变得很短，此时可以和 ID 阶段合并（把二次重叠变为了一次重叠）。</p>
<ul>
<li>时间接近变为原来的一半</li>
</ul>
<p>如果合并之后IFID和EX阶段时间不一致，也会有执行部件的浪费。</p>
<ul>
<li>我们的目标是使ALU计算单元在较长时间内处于工作状态也就是EX阶段尽量不等待</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-22.png" alt="alt text"></p>
<p>Common features: They work by FIFO, and are composed of a group of several storage units that can be accessed quickly and related control logic.</p>
<p>可以看到，添加 buffer 之后，ID 阶段不用等待 EX 阶段技术才能进行下一条的译码，因为 ID 阶段的结果已经存放在 buffer 中了。这给ID创造了能够读取下一条指令的机会</p>
<h4 id="1-buffer的引入"><a href="#1-buffer的引入" class="headerlink" title="1. buffer的引入"></a>1. buffer的引入</h4><ul>
<li>存放阶段间的中间结果，避免由于下一阶段的执行时间较长而导致前一个阶段需要等待</li>
<li>当IF阶段完成取指后，立即将指令放入buffer中，而不需要等待ID阶段完全解码完成。这样IF阶段可以尽快开始下一条指令的取指，增加了流水线的并行度</li>
</ul>
<h4 id="2-buffer优化流水线"><a href="#2-buffer优化流水线" class="headerlink" title="2. buffer优化流水线"></a>2. buffer优化流水线</h4><ul>
<li><strong>减少等待时间</strong>：即使EX阶段耗时较长，ID阶段也不需要等待EX阶段完全执行完毕，因为ID阶段可以将解码结果暂时存放在buffer中</li>
<li><strong>提高吞吐量</strong>：通过buffer来存储各个阶段的临时结果，允许流水线继续向前推进，减少了各阶段之间的执行时间差异对流水线效率的影响</li>
<li><strong>缓冲区机制(FIFO)</strong>：确保数据按照正确的顺序传递到下一个阶段。FIFO的硬件实现不仅包括存储单元，还需要一些控制逻辑来管理数据的读取和写入<blockquote>
<p>添加buffer之后，IF阶段时间变得很短，此时可以和ID阶段合并(把二次重叠变为了一次重叠)</p>
</blockquote>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-67.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-66.png" alt="alt text"></p>
<ul>
<li>添加buffer之后ID不用等待EX阶段结束之后才进行下一条指令的译码，因为ID阶段的结果已经存放在buffer中了<h2 id="2-Classes-of-poplining"><a href="#2-Classes-of-poplining" class="headerlink" title="2. Classes of poplining"></a>2. Classes of poplining</h2></li>
</ul>
<p>Charasteristics of pipelining:</p>
<ul>
<li>单功能流水线：只有一个固定功能的流水线。涉及仅针对单一类型的运算</li>
<li>多功能流水线：流水线的每个部分以不同的方式连接(不同阶段进行灵活组合)可以实现不同的功能<ul>
<li>使处理器能够更灵活地分配计算资源</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-23.png" alt="alt text"></p>
<p>针对多功能流水线的划分</p>
<ul>
<li>静态流水线：同一个时刻流水线只能做一个功能。<strong>流水线的功能同一时刻是固定的</strong></li>
</ul>
<blockquote>
<p>例如在刚刚的例子中，流水线要么做浮点加法要么做乘法</p>
</blockquote>
<ul>
<li>动态流水线：同一个时刻可以做多个功能。可以不用等待浮点加法第n条结束(即某一任务完全排空)，就可以开始乘法</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-24.png" alt="alt text"></p>
<p>从不同的粒度分类：</p>
<ul>
<li>Component level pipelining (in component - operation pipelining)：处理器内部组件内进行的流水线操作。例如，在同个ALU钟可以通过流水线技术让不同操作的各个阶段并行进行</li>
<li>Processor level pipelining (inter component - instruction pipelining):跨多个处理器组件的流水线操作，通常是指指令集的流水线。不同的指令在不同组件中进行取指、解码、执行等操作</li>
<li>Inter processor pipelining (inter processor - macro pipelining)：更大规模的流水线设计，涉及多处理器或多核系统。在这种架构下，不同的处理器(或核)处理不同部分的任务</li>
</ul>
<p>还可以分为线性或者非线性：</p>
<ul>
<li>Linear pipelining:不存在功能部件的回路，指令一依次在流水线的各个阶段中处理，每个阶段只进行一次运算，数据不会返回到之前的阶段。指令从一端流入，处理完毕后从另一端流出。</li>
<li>Nonlinear pipelining:功能部件可能多次使用，造成回路</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-25.png" alt="alt text"></p>
<p>还可以分为顺序/乱序：</p>
<ul>
<li>ordered pipelining：指令进出流水线的顺序相同，指令的执行顺序和完成是确定视为</li>
<li>disordered pipelining</li>
</ul>
<p>进来和流出的顺序不一样。后面的指令与前面的指令无关，则可以先出来，不能则要等待。</p>
<ul>
<li>乱序执行但是最后通过某些机制进行顺序调整</li>
<li>当流水线因为某一条指令堵塞时，处理器可以执行后续的指令</li>
</ul>
<p>还可以分为向量/标量处理器</p>
<ul>
<li><p>scalar processor：每次只能处理单一的数据元素。它的指令处理数据都是标量，意味着每条指令处理一个数据值。</p>
</li>
<li><p>vector processor：The processor has vector data representation and vector instructions. It is the combination of vector data representation and pipelining technology.采用向量指令处理多个数据元素(即一个向量)而不是单个标量。向量流水线的设计结合了向量数据表示与流水线技术，每次执行一条指令时处理的数据量非常大</p>
</li>
</ul>
<h2 id="3-Performance-evaluation-of-pipelining"><a href="#3-Performance-evaluation-of-pipelining" class="headerlink" title="3. Performance evaluation of pipelining"></a>3. Performance evaluation of pipelining</h2><h3 id="3-1-Throughput"><a href="#3-1-Throughput" class="headerlink" title="3.1 Throughput"></a>3.1 Throughput</h3><p>流水线希望我们提高单位时间内处理的任务越多越好，即提高吞吐率</p>
<ul>
<li>目的是提高处理的任务数，而不是减少时间</li>
</ul>
<p>Throughput(TP) </p>
<script type="math/tex; mode=display">
TP=\dfrac{n}{T_K}<TP_{max}</script><p>(实际上TP会有损耗)</p>
<ul>
<li>n是指令数</li>
<li>$T_k$是流水线总的执行时间</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-26.png" alt="alt text"></p>
<script type="math/tex; mode=display">
TP=\dfrac{n}{n+m-1}TP_{max}</script><ul>
<li>$$n&gt;&gt;m, TP\approx TP_{max}</li>
</ul>
<p>Suppose the time of segments are different in pipelining, then the longest segment in the pipelining is called the bottleneck segment.</p>
<blockquote>
<p>Example<br>Time of S1,S3,S4:$\Delta t$<br>Time of S2:$\Delta 3t$(Bottleneck)<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-27.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-28.png" alt="alt text"><br>$TP_{max}$只和瓶颈段的时间有关</p>
<h4 id="3-1-1-Common-methods-to-solve-pipeline-bottleneck"><a href="#3-1-1-Common-methods-to-solve-pipeline-bottleneck" class="headerlink" title="3.1.1 Common methods to solve pipeline bottleneck"></a>3.1.1 Common methods to solve pipeline bottleneck</h4><ul>
<li>Subdivision 把瓶颈分成若干段执行</li>
</ul>
</blockquote>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-29.png" alt="alt text"></p>
<ul>
<li>Repetition 在瓶颈段多使用几个部件</li>
</ul>
<h3 id="3-2-Speedup"><a href="#3-2-Speedup" class="headerlink" title="3.2 Speedup"></a>3.2 Speedup</h3><script type="math/tex; mode=display">
SP=\frac{n \times m}{m+n-1}</script><ul>
<li>if $n&gt;&gt;m,Sp_{max} \approx m$</li>
</ul>
<h3 id="3-3-Efficiency"><a href="#3-3-Efficiency" class="headerlink" title="3.3 Efficiency"></a>3.3 Efficiency</h3><p>效率，从计算机部件的角度：纵轴代表使用的不同的功能部件。效率指的是我们真正使用这个部件占整个时空的百分比。</p>
<ul>
<li>流水线中硬件资源的利用率</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-30.png" alt="alt text"></p>
<script type="math/tex; mode=display">
η=\frac{n \times m \times \Delta t_0}{m \times(n+m-1) \times \Delta t_0}=\frac{n}{m+n-1}</script><ul>
<li>注意效率得到的结果应该是百分比，之前是吞吐量、加速比都是没有量纲的数</li>
<li>if $n&gt;&gt;m, η\approx 1$ 实际上不可能为1，流水线进入和排空的时间是不可以忽略的</li>
</ul>
<h3 id="3-4-Pipeline-Performance"><a href="#3-4-Pipeline-Performance" class="headerlink" title="3.4 Pipeline Performance"></a>3.4 Pipeline Performance</h3><ul>
<li>vector Calculation in static Pipeline</li>
</ul>
<p>现在有两个向量 A 和 B，我们要计算 A 点乘 B，通过下面的动态双功能流水线运算。</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-31.png" alt="alt text"></p>
<p>注意到这里是静态流水线，同一时刻只能做一类事情，需要先完成一种操作再完成另一种。这里我们需要先做乘法，排空，再做加法。做加法时，第三个乘法的结果需要等前两个乘法的结果相加后，再计算。</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-32.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-33.png" alt="alt text"></p>
<ul>
<li>vector Calculation in dynamic Pipeline</li>
</ul>
<p>动态流水线，可以在前一个功能还没有做完的时候执行另一个功能，不需要排空。</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-34.png" alt="alt text"></p>
<p>这里当两个乘法的结果算出来之后，就可以执行对应的加法。</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-35.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-36.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-37.png" alt="alt text"></p>
<ul>
<li>如果各个阶段是完全平衡的，每条指令的执行时间就是每个阶段所需要的时间，所以理想情况下的加速比也就是流水线的阶段数</li>
<li>Too many stages<ul>
<li>Lots of complications：流水线调度复杂，控制逻辑复杂</li>
<li>Should take care of possible dependencies among in-flight instructions</li>
<li>Control logic is huge</li>
<li>导致性能瓶颈的产生</li>
<li>硬件要求提高<br>流水线的性能有关：动态（不需要排空，但需要硬件支持）还是静态，流水线段数，代码质量（冒险）</li>
</ul>
</li>
</ul>
<h2 id="4-Hazards-of-Pipeline"><a href="#4-Hazards-of-Pipeline" class="headerlink" title="4. Hazards of Pipeline"></a>4. Hazards of Pipeline</h2><ul>
<li>structure hazards:A required resource is busy</li>
<li>data hazard:need to wait for previous instruction to complete its data read/write.</li>
<li>control hazard: Deciding on control action depends on previous instruction.</li>
</ul>
<h3 id="4-1-structure-hazards"><a href="#4-1-structure-hazards" class="headerlink" title="4.1 structure hazards"></a>4.1 structure hazards</h3><p>对结构的争用,资源存在冲突</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-38.png" alt="alt text"></p>
<ul>
<li>一般通过加bubble或者加硬件进行解决（满足需求），或者同一块memory区分不同的cache</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-39.png" alt="alt text"></p>
<h3 id="4-2-data-hazard"><a href="#4-2-data-hazard" class="headerlink" title="4.2 data hazard"></a>4.2 data hazard</h3><p>一条指令的执行依赖于前面指令对于数据访问的完成</p>
<p>可以加 bubble, 或者通过 forwarding 前递数据，但并不是所有的情况都可以解决。</p>
<ul>
<li>Read After Write (RAW) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FADD.D F6,F0,F12</span><br><span class="line">FSUB.D F8,F6,F14</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>Forwarding解决这种类型的冒险</p>
</blockquote>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-40.png" alt="alt text"></p>
<ul>
<li>Write After Read (WAR)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FDIV.D F2,F6,F4</span><br><span class="line">FADD.D F6,F0,F12</span><br></pre></td></tr></table></figure></li>
<li>可以更换F2对应的寄存器</li>
</ul>
<blockquote>
<p>Name Dependences（在乱序流水线中可能出现冒险）</p>
</blockquote>
<ul>
<li><p>Write After Write (WAW)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FDIV.D F2，F0，F4</span><br><span class="line">FSUB.D F2，F6，F14</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能更换F2对应的寄存器，存在写入顺序的问题</p>
</li>
</ul>
<p>Name Dependence,顺序流水线不会引起数据的冒险，但在乱序流水线会发生冒险的问题</p>
<ul>
<li>code scheduling to avoid stalls</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-41.png" alt="alt text"></p>
<ul>
<li>静态调度：程序还没有运行，编译器在程序编译阶段重新排列指令顺序，减少等待时间</li>
<li>动态调度：程序运行时，处理器为我们优化了代码</li>
</ul>
<h3 id="4-3-control-hazard"><a href="#4-3-control-hazard" class="headerlink" title="4.3 control hazard"></a>4.3 control hazard</h3><ul>
<li>定义：控制冒险发生在流水线遇到分支指令时，必须等待分支指令的结果才能确定下一步的执行路径。如果分支预测错误，流水线必须丢弃错误路径上的指令</li>
</ul>
<p>为了减少分支指令带来的stall，我们使用分支预测的技术</p>
<ul>
<li>static branch prediction<ul>
<li>基于经典的分支行为<ul>
<li>branch-taken</li>
<li>branch-not-taken</li>
</ul>
</li>
</ul>
</li>
<li>dynamic branch prediction<ul>
<li>Hardware measures actual branch behavior<ul>
<li>根据历史记录(如上一次分支结果)，预测下一次分支</li>
</ul>
</li>
<li>我们认为未来的行为将会延续现在的趋势</li>
</ul>
</li>
</ul>
<h3 id="5-Data-Hazards-4-2"><a href="#5-Data-Hazards-4-2" class="headerlink" title="5. Data Hazards(4.2)"></a>5. Data Hazards(4.2)</h3><h3 id="6-Control-Hazards"><a href="#6-Control-Hazards" class="headerlink" title="6. Control Hazards"></a>6. Control Hazards</h3><p>在RISC-V中，有无条件跳转<code>jal</code>,<code>jalr</code>和有条件跳转<code>beq</code>,<code>bne</code>,<code>blt</code>,<code>bge</code>,<code>bltu</code>,<code>bgeu</code></p>
<p>可以在ID阶段就<strong>算出要跳转的目标地址</strong>，同时进行分支预测。只有预测错误时才需要stall来flush掉之前的结果，预测成功不需要stall</p>
<h4 id="6-1-Static-Branch-Prediction"><a href="#6-1-Static-Branch-Prediction" class="headerlink" title="6.1 Static Branch Prediction"></a>6.1 Static Branch Prediction</h4><ol>
<li>Predict-not-taken</li>
</ol>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-42.png" alt="alt text"></p>
<ul>
<li>预测错误停顿一个周期，预测正确不停顿</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-43.png" alt="alt text"></p>
<ol>
<li><p>Predict-taken</p>
</li>
<li><p>Data Hazards for branches</p>
</li>
</ol>
<ul>
<li>If a comparison register is a destination of 2nd or 3rd preceding ALU instruction<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add x1,x2,x3</span><br><span class="line">add x4,x5,x6</span><br><span class="line">beq x1,x4,target</span><br></pre></td></tr></table></figure></li>
<li>Can solve using forwarding</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-44.png" alt="alt text"></p>
<ul>
<li>If a comparison register is a destination  of preceding ALU instruction or 2nd preceding load instruction<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lw x1,0(x2)</span><br><span class="line">add x4,x5,x6</span><br><span class="line">beq x1,x4,target</span><br></pre></td></tr></table></figure>
<img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-45.png" alt="alt text"></li>
<li>If a comparison register is a destination of immediately preceding load instruction<ul>
<li>Need 2 stall cycles <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lw x1,0(x2)</span><br><span class="line">beq x1,x0,target</span><br></pre></td></tr></table></figure>
<img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-52.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h4 id="6-2-Dynamic-Branch-Prediction"><a href="#6-2-Dynamic-Branch-Prediction" class="headerlink" title="6.2 Dynamic Branch Prediction"></a>6.2 Dynamic Branch Prediction</h4><ul>
<li>In deeper and superscalar pipelines, branch penalty is more significant</li>
<li><p>Use dynamic prediction</p>
<ul>
<li>Branch prediction buffer(branch history table)</li>
<li>Indexed by recent branch instruction address</li>
<li>Stores outcome(taken or not taken)</li>
<li>To execute a branch</li>
<li>Look up the branch prediction buffer<ul>
<li>Check table,expect the same outcome</li>
<li>Start fetching from fall-through or target</li>
<li>If wrong,flush pipeline and flip prediction</li>
</ul>
</li>
</ul>
</li>
<li><p>Branch history</p>
<ul>
<li>1-bit predictor<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-46.png" alt="alt text"></li>
<li>Inner loop branches mispredicted twice</li>
<li>容易在分支频繁变化的时候产生错误预测<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-47.png" alt="alt text"></li>
<li>Mispredict as taken on last iteration of inner loop</li>
<li>Then mispredict as not taken on first iteration of inner loop next time around</li>
<li>2-bit predictor<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-48.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-49.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="6-3-Advanced-Techniques-for-instruction-Delivery-and-Speculation"><a href="#6-3-Advanced-Techniques-for-instruction-Delivery-and-Speculation" class="headerlink" title="6.3 Advanced Techniques for instruction Delivery and Speculation"></a>6.3 Advanced Techniques for instruction Delivery and Speculation</h3><ul>
<li>Increasing Instruction Fetch Bandwith <ul>
<li>Branch-Target Buffers(BTB):放预测的PC值，取指时在buffer中取。与TLB表类似，在未找到对应PC的情况下更新表的内容</li>
<li>BTB是一个基于分支指令地址索引的表，存储了分支指令之前的执行结果。<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-50.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-51.png" alt="alt text"></li>
<li>BTB存储了分支指令和目标地址</li>
<li>如果在表中找到了对应的项，那么立即取出对应的目标地址，作为下一个时钟周期IF阶段的PC，也就是说，如果表中有对应项，我们采取的预测方式是Assume Branch Taken <ul>
<li>分支预测正确：处理器从BTB获取目标地址，并直接预取目标位置的指令。这大大提高了分支跳转的速度，减少了处理器在预测正确时的延迟</li>
<li>分支预测错误：如果分支预测错误，则需要清空流水线并更新BTB，将该PC对应的表项从目标地址缓存表中删除</li>
</ul>
</li>
<li>如果在表中没有找到对应的项，那么我们采取的预测方式是<code>Assume Branch Not Taken</code><ul>
<li>预测错误，清空已经执行的指令，并且下一个时钟周期使得目标地址进入IF阶段。与此同时，将这条分支指令的PC值以及对应的目标地址填入目标地址缓存表中，在表中新增一项</li>
<li>如果分支没有执行正常情况，继续执行指令流即可</li>
</ul>
</li>
</ul>
</li>
<li>Specialized Branch Predictors:Predicting Procedure Returns,Indirect Jump and Loops Branches<ul>
<li>Integretd Instruction Fetch Units(集成指令提取单元):从内存中提取指令并将其传递给处理器的执行单元<ul>
<li>集成指令预测</li>
<li>指令的提前取指</li>
<li>指令内存的访问和缓存</li>
</ul>
</li>
<li>在现代多发射处理器架构中，指令提取不再是一个简单的单级流水线阶段，而是需要更复杂的实现</li>
</ul>
</li>
</ul>
<h4 id="Calculating-the-Branch-Target"><a href="#Calculating-the-Branch-Target" class="headerlink" title="Calculating the Branch Target"></a>Calculating the Branch Target</h4><ul>
<li>即使有了复制预测模块，仍然需要计算目标地址<ul>
<li>taken branch需要有一个周期的penalty</li>
</ul>
</li>
<li><p>Branch Target Buffer</p>
<ul>
<li>Cache or target address</li>
<li><p>Indexed by PC when instruction fetched</p>
<ul>
<li>If hit and instruction is branch predicted taken, can fetch target immediately</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-54.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-53.png" alt="alt text"></p>
</li>
</ul>
</li>
<li>BTB的更新与维护<ul>
<li>表加入机制：当一个新的分支指令出现其目标地址不在BTB中时，处理器会将这个分支指令和它的目标地址存入表中</li>
<li>表移除机制：如果一个分支指令不再跳转(即不被执行)，处理器会从BTB中移除该条指令的条目，以腾出空间给其他分支指令</li>
</ul>
</li>
</ul>
<h3 id="7-Schedule-of-Nonlinear-pipelining"><a href="#7-Schedule-of-Nonlinear-pipelining" class="headerlink" title="7. Schedule of Nonlinear pipelining"></a>7. Schedule of Nonlinear pipelining</h3><p>对于非线性流水线，功能部件可能经历多次，有调度问题</p>
<ul>
<li>纵轴代表不同的功能部件，横坐标表示拍数。即每一拍需要用到的功能部件</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-55.png" alt="alt text"></p>
<h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong><em>算法步骤</em></strong>：</h4><ul>
<li>Initial conflict vector:使用二进制表示，各个位置取每一拍存在冲突的并集。如果是1，则从图存在，否则冲突不存在<ul>
<li>第一个部件，隔8拍会产生冲突；第二个部件：1.5.6；第三个部件：无；第四、五个部件：1</li>
<li>将对应八位二进制数的1.5.6.8位设为1，其他为0，得到了初始的冲突向量10110001</li>
</ul>
</li>
<li>conflict vector</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-57.png" alt="alt text"></p>
<p>对于第三列，隔两排进下一条指令，我们就把冲突向量向右移动两位(高位补0)，得到了新的冲突向量，并和本来的冲突向量做或运算得到CCV。(注意这里最左侧一列表示向右移动了多少次)</p>
<p>找到了一个循环调度：2-2-7</p>
<ul>
<li>State transition graph<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-58.png" alt="alt text"></li>
<li>Circular queue：只要形成回路即可，没有一定规定需要从初始状态回到初始状态</li>
<li>Shortest average interval：做的总移动数除以移动次数</li>
</ul>
<h1 id="Chapter-3-Memory-Hierarchy"><a href="#Chapter-3-Memory-Hierarchy" class="headerlink" title="Chapter 3: Memory Hierarchy"></a>Chapter 3: Memory Hierarchy</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><h3 id="1-1-Memory"><a href="#1-1-Memory" class="headerlink" title="1.1 Memory"></a>1.1 Memory</h3><p>内存层次</p>
<ul>
<li>Register </li>
<li>Cache</li>
<li>Memory</li>
<li>Storage </li>
</ul>
<p>存储技术</p>
<ul>
<li>Mehanical Memory</li>
<li>Electronic Memory<ul>
<li>SRAM(做Cache)</li>
<li>DRAM(做Memory)<ul>
<li>SDRAM</li>
<li>DDR</li>
</ul>
</li>
<li>GDRAM<ul>
<li>GDDR</li>
</ul>
</li>
<li>HBM</li>
<li>EPPROM<ul>
<li>NAND</li>
<li>NOR</li>
</ul>
</li>
</ul>
</li>
<li>Optical Memory </li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-68.png" alt="alt text"></p>
<h3 id="1-2-Cache-Memory"><a href="#1-2-Cache-Memory" class="headerlink" title="1.2 Cache Memory"></a>1.2 Cache Memory</h3><p>Cache:a safe place for hiding or storing things. （现在也不安全）</p>
<ul>
<li>Cache <strong>Hit/Miss</strong>:When the processor can/cannot find a requested data item in the cache <ul>
<li>Cache miss会到来额外的开销：由延迟和带宽决定</li>
</ul>
</li>
<li>Cache <strong>Block/Line</strong>:A fixed-size collection of the data containing the requested word,retrieved from the main memory and placed into the cache</li>
<li><p>Cache <strong>Locality</strong>:</p>
<ul>
<li>Temporal locality:need the requested word again soon访问过这个数据，之后很可能再次访问</li>
<li><p>Spatial locality:likely need other data in the block soon访问了这个位置 ，之后很可能再次访问附近的位置的数据</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-59.png" alt="alt text"></p>
<h2 id="2-Four-Question-for-Cache-Designers"><a href="#2-Four-Question-for-Cache-Designers" class="headerlink" title="2. Four Question for Cache Designers"></a>2. Four Question for Cache Designers</h2></li>
</ul>
</li>
</ul>
<p>Caching is a general concept used in processors,operating systems,file systems,and applications</p>
<ul>
<li>Q1:Where can a block be placed in the upper level/main memory? (Block placement)<ul>
<li>Fully Associative,Set Associative,Direct Mapped</li>
</ul>
</li>
<li>Q2:How is a block found if it is in the upper level/main memory?(Block identification)<ul>
<li>Tag/Block</li>
</ul>
</li>
<li>Q3:Which block should be replaced on a Cache/main memory miss?(Block replacement)<ul>
<li>Random,LRU,FIFO</li>
</ul>
</li>
<li>Q4:What happens on a write?(Write strategy)<ul>
<li>Write back or Write through(with write buffer)</li>
</ul>
</li>
</ul>
<h3 id="2-1-Block-Placement"><a href="#2-1-Block-Placement" class="headerlink" title="2.1 Block Placement"></a>2.1 Block Placement</h3><ul>
<li>Direct Mapped:一个块在cache中有一个固定的位置(通常通过取模得到，冲突多)<ul>
<li>找方便，易冲突<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-61.png" alt="alt text"></li>
</ul>
</li>
<li>Fully Associative:块可以放在cache里的位置<ul>
<li>不好找，冲突少</li>
</ul>
</li>
<li>Set Associative<ul>
<li>块可以放在一个组里的任何位置，组里可以放若干个块</li>
<li>直接映射相当于一路组相联，全相联相当于n路组相联(n是cache的块数)</li>
<li>A set is a group of blocks in the cache<script type="math/tex; mode=display">
  Set Index=Block Address MOD Number of sets in the chache</script></li>
</ul>
</li>
</ul>
<h3 id="2-2-Block-Identification"><a href="#2-2-Block-Identification" class="headerlink" title="2.2 Block Identification"></a>2.2 Block Identification</h3><p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-62.png" alt="alt text"></p>
<ul>
<li>address tag存储了存储在block中的数据的主存地址</li>
<li>当检查cache时，处理器会比较我们需要的memory address和cache tag，如果二者是相等的，那么将会cache hit并且数据现在已经在cache中</li>
<li>通常情况下，每一个block都会有一个<code>valid bit</code>来判断cache block中的内容是否有效</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-74.png" alt="alt text"></p>
<h3 id="2-3-Block-Replacement"><a href="#2-3-Block-Replacement" class="headerlink" title="2.3 Block Replacement"></a>2.3 Block Replacement</h3><ul>
<li>Random replacement:randomly pick any block<ul>
<li>硬件上容易实现，只需要随机数发生器即可</li>
<li>在缓存中均匀分配</li>
<li>可能会驱逐一个即将被访问的块</li>
</ul>
</li>
<li>Least-Recently Used(LRU):pick the block in the set which was least recently accessed<ul>
<li>认为刚刚访问过的数据接下来还有可能被访问</li>
<li>需要额外的位数来记录访问的时间。一般我们用的是近似的LRU</li>
</ul>
</li>
<li>First in,First Out(FIFO):Choose a block from the set which was first came into the cache</li>
</ul>
<blockquote>
<p>Suppose：Cache blocck size is 3, and access sequence is shown as follows.2,3,2,1,5,2,4,5,3,4</p>
</blockquote>
<ul>
<li>FIFO<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-63.png" alt="alt text"></li>
<li>LRU<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-64.png" alt="alt text"></li>
<li>OPT<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-65.png" alt="alt text"></li>
</ul>
<p>Hit rate is related to the replacement algorithm, the access sequence, the cache block size.</p>
<h4 id="2-3-1-Stack-Replacement-algorithm"><a href="#2-3-1-Stack-Replacement-algorithm" class="headerlink" title="2.3.1 Stack Replacement algorithm"></a>2.3.1 Stack Replacement algorithm</h4><p>有些算法随着N增大命中率非下降，有些算法随着N增大命中率反而会下降</p>
<p>我们把随着N增大命中率非下降的算法称为 stack replacement algorithm</p>
<p>$B_t(n)$ 在t时间cache的block大小为n的一组被包含的访问序列</p>
<ul>
<li>$B_t(n)$是$B_t(n+1)$的子集是堆栈型替换算法的条件：随着n的增大，先前能命中的也一定能命中</li>
</ul>
<p>LRU replacement algorithm is a stack replacement algorithm, while FIFO is not.</p>
<p>For LRU algorithm, the hit ratio always increases with the increase of cache block.</p>
<blockquote>
<p>用栈来模拟LRU，栈顶是最近访问的，栈底是最久未访问的，每次要替换的时候，替换栈底元素。通过下面的图可以看到栈大小为n时的命中率<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-69.png" alt="alt text"></p>
</blockquote>
<h4 id="2-3-2-LRU-Implementation-Comparison-Pair-Method"><a href="#2-3-2-LRU-Implementation-Comparison-Pair-Method" class="headerlink" title="2.3.2 LRU Implementation - Comparison Pair Method"></a>2.3.2 LRU Implementation - Comparison Pair Method</h4><p>如何只通过门和触发器来实现LRU算法？—-Comparison Pair Method</p>
<ul>
<li>基本思想：让任何两个cache块之间两两结对，用一个触发器的状态代表两个块的先后顺序(比如1表示A刚刚被访问过，0表示B刚被访问过)。通过门电路对触发器的状态进行逻辑组合，找到最久未被访问的块</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-70.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-71.png" alt="alt text"></p>
<ul>
<li><p>Hardware usage analysis</p>
<ul>
<li><p>假设有p个cache blocks，我们需要$C_p^2= \frac{p(p-1)}{2}$</p>
</li>
<li><p>当p超过8时，需要的触发器过多，这个算法就不适用了</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-4-Write-Strategy"><a href="#2-4-Write-Strategy" class="headerlink" title="2.4 Write Strategy"></a>2.4 Write Strategy</h3><ul>
<li><p>Write Hit</p>
<ul>
<li><p>Write Through:同时写回cache和内存。写到内存的时间较长，这个过程需要Write Stall，或者使用Write buffer(当buffer填满时无法避免使用Write Stall)</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-72.png" alt="alt text"></p>
</li>
<li>Write Back:在cache中写，同时通过一个额外的dirty bit表示这个块已经被修改,先用cache临时存储，最后一起写回内存</li>
</ul>
</li>
<li>Write Miss<ul>
<li>Write Allocate:将要写的块先读到cache中，再写进主存</li>
<li>Write Around:直接写到内存，数据不会在cache中进行存储</li>
</ul>
</li>
<li>In general, write-back caches use write-allocate , and write-through caches use write-around.</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-73.png" alt="alt text"></p>
<h2 id="3-Memory-System-Performs"><a href="#3-Memory-System-Performs" class="headerlink" title="3. Memory System Performs"></a>3. Memory System Performs</h2><ul>
<li>$CPU\ Execution\ time=(CPU\ clock\ cycles + Memory\ stall\ cycles) \times CPU\ clock\ cycle\ time$</li>
<li>$Memory\ stall\ cycles = IC\times MemAccess refs per instructions \times Miss rate \times Miss Penalty$</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-75.png" alt="alt text"></p>
<ul>
<li>CPI Execution includes ALU and Memory instructions</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-76.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-83.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-84.png" alt=" "></p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-85.png" alt="alt text"></p>
<p>How to improve</p>
<ul>
<li>Reduce the miss penalty</li>
<li>Reduce the miss rate</li>
<li>Reduce the time to hit in the cache</li>
<li>Reduce the miss penalty and miss rate via parallelism</li>
</ul>
<h2 id="4-Virtual-Memory"><a href="#4-Virtual-Memory" class="headerlink" title="4. Virtual Memory"></a>4. Virtual Memory</h2><p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-86.png" alt="alt text"></p>
<p>物理内存是有限的，虚拟内存让用户体验到一个抽象的更大的内存</p>
<ul>
<li>Why virtual memory?<ul>
<li>可以让进程使用不连续的物理内存空间(虚拟地址上是连续的)；更好地隔离不同进程</li>
</ul>
</li>
<li>virtual-physical address translation</li>
<li>memory protection/sharing among multi-program</li>
<li>easier/flexible memory management</li>
<li>share a smaller amount of physical memory among many processes(隔离：每个进程都有一个相对独立的空间，不会访问其他程序的空间。一种安全机制)</li>
<li>Introduces another level of secondary storage</li>
</ul>
<p><strong>Virtual Memory = Main Memory + Secondary Storage</strong><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-87.png" alt="alt text"></p>
<ul>
<li>Virtual Memory Allocation<ul>
<li>Paged virtual memory<ul>
<li><code>page</code>:fixed-size block(the block conception in virtual memory)</li>
<li>page address:page number||offset</li>
</ul>
</li>
<li>Segmented virtual memory<ul>
<li><code>segment</code>:variable-size block</li>
<li>segment address:segment number||offset</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-77.png" alt="alt text"></p>
<blockquote>
<p>分页式的易于实现，方便替换。现在常用段页式结合或者纯页式</p>
</blockquote>
<h3 id="4-1-How-virtual-memory-works"><a href="#4-1-How-virtual-memory-works" class="headerlink" title="4.1 How virtual memory works?"></a>4.1 How virtual memory works?</h3><p>Cache 的四个问题在虚拟内存中都有对应</p>
<ul>
<li>Q1. Where can a block be placed in main memory?<ul>
<li>缺失代价很高，因此我们采用全相联的方式，以降低 miss rate。</li>
</ul>
</li>
<li>Q2. How is a block found if it is in main memory?<ul>
<li>虚拟地址分两部分，偏移量和页号。页号是页表的索引<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-78.png" alt="alt text"></li>
</ul>
</li>
<li>Q3. Which block should be replaced on a virtual memory miss?<ul>
<li>Least Recently Used (LRU) block, with use/reference bit.</li>
</ul>
</li>
<li>Q4. What happens on a write?<ul>
<li>Write-back strategy（如果向disk写的代价太大）, with diry bit(数据即将被占用的时候再写入).</li>
</ul>
</li>
</ul>
<h3 id="4-2-Page-Table"><a href="#4-2-Page-Table" class="headerlink" title="4.2 Page Table"></a>4.2 Page Table</h3><ul>
<li>Page tables are often large</li>
<li><p>页表是被存储在主存中的</p>
<blockquote>
<p>e.g. 32-bit virtual address, 4KB pages, 4 bytes per page table entry.</p>
<p>page table size=$(2^{32}/2^{12})\times 2^2=2^{22}bytes= 4MB$</p>
</blockquote>
</li>
<li><p>Logically two memory accesses for data access:</p>
<ul>
<li>从页表中获取物理地址</li>
<li>从物理地址中得到数据</li>
<li>通过offset找到page中的具体位置</li>
</ul>
</li>
</ul>
<p>正常来说页表需要两次访问内存，访问效率低下</p>
<ul>
<li>页表被存储在主存中，要先访问主存寻找对应的页表从而获得物理地址</li>
<li>然后根据得到的物理地址<br>访问主存拿到数据</li>
</ul>
<p>因此我们需要cache page table,即TLB</p>
<p><strong>Translation lookaside buffer (TLB)</strong></p>
<blockquote>
<p>避免了进行两次访问操作，节省访问时间 </p>
</blockquote>
<ul>
<li><p>TLB Entry:</p>
<ul>
<li>tag:portions of the virtual address (VPN);</li>
<li>data:a physical page frame number (PPN), protection field, valid bit, use bit, dirty bit;</li>
<li>不包含偏移量<blockquote>
<p>发送 tag (VPN) 尝试匹配，并看访问类型是否违规。如果匹配成功，就把对应的 PPN 送到 Mux，将偏移量加上 PPN 得到物理地址。<br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-79.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-80.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-81.png" alt="alt text"><br>最后一步合并页内偏移才能访问真正的物理地址。如果TLB未找到对应的页，则需要更新TLB，采用LRU策略进行更新。</p>
<h3 id="4-3-Page-Size-Selectiq"><a href="#4-3-Page-Size-Selectiq" class="headerlink" title="4.3 Page Size Selectiq"></a>4.3 Page Size Selectiq</h3></blockquote>
</li>
</ul>
</li>
<li>Pros of larger page size<ul>
<li>Smaller page table, less memory (or other resources used for the memory map);页更少，所以页表更小。</li>
<li>Larger cache with fast cache hit;页更大，所以cache命中的时间更短(因为我们需要遍历的页更少)</li>
<li>Transferring larger pages to or from secondary storage is more efficient than transferring smaller pages;一次搬运更多的数据，所以更高效，小页可能需要搬运多次。</li>
<li>Map more memory, reduce the number of TLB misses;TLB miss 次数更少。</li>
</ul>
</li>
<li>Pros of smaller page size<ul>
<li>Conserve storage:When a contiguous region of virtual memory is not equal in size to a multiple of the page size, a small page size results in less wasted storage.减少对内存的使用，内部碎片更少。</li>
</ul>
</li>
</ul>
<h4 id="1-更大页大小的优点（Pros-of-larger-page-size）"><a href="#1-更大页大小的优点（Pros-of-larger-page-size）" class="headerlink" title="1. 更大页大小的优点（Pros of larger page size）"></a><strong>1. 更大页大小的优点（Pros of larger page size）</strong></h4><h5 id="1-页表更小（Smaller-page-table-less-memory）"><a href="#1-页表更小（Smaller-page-table-less-memory）" class="headerlink" title="(1) 页表更小（Smaller page table, less memory）"></a><strong>(1) 页表更小（Smaller page table, less memory）</strong></h5><ul>
<li><p><strong>解释</strong>：</p>
<ul>
<li>页表（Page Table）是操作系统用来管理虚拟内存和物理内存映射的数据结构。</li>
<li>如果页大小较大，那么相同的内存空间需要的页数会更少，因此页表会更小。</li>
<li>较小的页表占用更少的内存资源，同时也减少了页表查找的开销。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>假设内存大小为 4GB，页大小为 4KB，则需要 (2^{20}) 个页表项。</li>
<li>如果页大小为 2MB，则只需要 (2^{11}) 个页表项。</li>
</ul>
</li>
</ul>
<h5 id="2-缓存命中更快（Larger-cache-with-fast-cache-hit）"><a href="#2-缓存命中更快（Larger-cache-with-fast-cache-hit）" class="headerlink" title="(2) 缓存命中更快（Larger cache with fast cache hit）"></a><strong>(2) 缓存命中更快（Larger cache with fast cache hit）</strong></h5><ul>
<li><p><strong>解释</strong>：</p>
<ul>
<li>页大小较大时，单个页可以容纳更多的数据。</li>
<li>当程序访问内存时，如果数据在同一个页中，可以减少页表查找的次数，从而提高缓存命中率。</li>
<li>缓存命中更快，因为需要遍历的页更少。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>如果程序需要访问连续的内存区域，较大的页可以减少页表查找的次数。</li>
</ul>
</li>
</ul>
<h5 id="3-数据传输更高效（Transferring-larger-pages-is-more-efficient）"><a href="#3-数据传输更高效（Transferring-larger-pages-is-more-efficient）" class="headerlink" title="(3) 数据传输更高效（Transferring larger pages is more efficient）"></a><strong>(3) 数据传输更高效（Transferring larger pages is more efficient）</strong></h5><ul>
<li><p><strong>解释</strong>：</p>
<ul>
<li>当内存页需要从磁盘（或其他辅助存储设备）加载到内存时，较大的页可以一次性传输更多的数据。</li>
<li>相比于多次传输小页，传输大页的效率更高。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>如果页大小为 4KB，加载 1MB 数据需要 256 次传输。</li>
<li>如果页大小为 2MB，加载 1MB 数据只需要 1 次传输。</li>
</ul>
</li>
</ul>
<h5 id="4-减少-TLB-未命中次数（Reduce-the-number-of-TLB-misses）"><a href="#4-减少-TLB-未命中次数（Reduce-the-number-of-TLB-misses）" class="headerlink" title="(4) 减少 TLB 未命中次数（Reduce the number of TLB misses）"></a><strong>(4) 减少 TLB 未命中次数（Reduce the number of TLB misses）</strong></h5><ul>
<li><p><strong>解释</strong>：</p>
<ul>
<li>TLB（Translation Lookaside Buffer）是用于加速虚拟地址到物理地址转换的硬件缓存。</li>
<li>较大的页可以映射更多的内存，因此 TLB 可以覆盖更多的内存区域，从而减少 TLB 未命中的次数。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>如果 TLB 可以缓存 64 个页表项，页大小为 4KB 时，TLB 只能覆盖 256KB 的内存。</li>
<li>如果页大小为 2MB，TLB 可以覆盖 128MB 的内存。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-更小页大小的优点（Pros-of-smaller-page-size）"><a href="#2-更小页大小的优点（Pros-of-smaller-page-size）" class="headerlink" title="2. 更小页大小的优点（Pros of smaller page size）"></a><strong>2. 更小页大小的优点（Pros of smaller page size）</strong></h4><h5 id="1-节省存储空间（Conserve-storage）"><a href="#1-节省存储空间（Conserve-storage）" class="headerlink" title="(1) 节省存储空间（Conserve storage）"></a><strong>(1) 节省存储空间（Conserve storage）</strong></h5><ul>
<li><p><strong>解释</strong>：</p>
<ul>
<li>当程序需要的内存区域不是页大小的整数倍时，较小的页可以减少内存浪费（内部碎片）。</li>
<li>较小的页可以更灵活地分配内存，减少未使用的内存空间。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
<ul>
<li>如果页大小为 4KB，程序需要 5KB 内存，则会分配 2 个页（8KB），浪费 3KB。</li>
<li>如果页大小为 1KB，程序需要 5KB 内存，则会分配 5 个页（5KB），没有浪费。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li><p><strong>更大页大小的优点</strong>：</p>
<ul>
<li>页表更小，减少内存占用。</li>
<li>缓存命中更快，减少页表查找次数。</li>
<li>数据传输更高效，减少 I/O 操作次数。</li>
<li>减少 TLB 未命中次数，提高地址转换效率。</li>
</ul>
</li>
<li><p><strong>更小页大小的优点</strong>：</p>
<ul>
<li>减少内存浪费，提高内存利用率。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="实际应用中的权衡"><a href="#实际应用中的权衡" class="headerlink" title="实际应用中的权衡"></a><strong>实际应用中的权衡</strong></h4><p>在实际操作系统中，页大小的选择需要根据具体应用场景和硬件特性进行权衡：</p>
<ul>
<li><strong>大页</strong>：适合需要大量连续内存访问的应用（如数据库、科学计算）。</li>
<li><strong>小页</strong>：适合内存需求较小且不连续的应用（如桌面应用程序）。</li>
</ul>
<p><strong>Use both</strong>:multiple page sizes</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-82.png" alt="alt text"></p>
<h3 id="4-4-Mem-Protection-amp-amp-Sharing-Among-Programs"><a href="#4-4-Mem-Protection-amp-amp-Sharing-Among-Programs" class="headerlink" title="4.4 Mem Protection&amp;&amp;Sharing Among Programs"></a>4.4 Mem Protection&amp;&amp;Sharing Among Programs</h3><h4 id="4-4-1-Multiprogramming"><a href="#4-4-1-Multiprogramming" class="headerlink" title="4.4.1 Multiprogramming"></a>4.4.1 Multiprogramming</h4><ul>
<li>允许计算机被多个并发执行的程序共享</li>
<li>需要保护并且在程序中共享</li>
</ul>
<h4 id="4-4-2-Process"><a href="#4-4-2-Process" class="headerlink" title="4.4.2 Process"></a>4.4.2 Process</h4><ul>
<li>Maintain correct process behavior保持正确的进程行为<ul>
<li>computer designer必须确保the processor portion of the process state（进程状态的处理器部分）能够被保存和重新存储</li>
<li>OS designer必须确保进程之间的计算不会彼此影响</li>
</ul>
</li>
<li>将主存划分从而使得多个不同的进程在内存中同一时刻都拥有它们的状态</li>
</ul>
<p>这部分内容主要涉及计算机体系结构中的 <strong>存储层次结构（Memory Hierarchy）</strong>、<strong>缓存（Cache）</strong> 和 <strong>虚拟内存（Virtual Memory）</strong>。以下是详细的解释：</p>
<hr>
<h3 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5 Summary"></a>5 Summary</h3><h4 id="1-存储层次结构（Memory-Hierarchy）"><a href="#1-存储层次结构（Memory-Hierarchy）" class="headerlink" title="1. 存储层次结构（Memory Hierarchy）"></a><strong>1. 存储层次结构（Memory Hierarchy）</strong></h4><h5 id="从单级到多级（From-single-level-to-multi-level）"><a href="#从单级到多级（From-single-level-to-multi-level）" class="headerlink" title="从单级到多级（From single level to multi level）"></a><strong>从单级到多级（From single level to multi level）</strong></h5><ul>
<li><strong>单级存储</strong>：早期的计算机系统只有一种存储设备（如磁鼓存储器），速度慢且容量有限。</li>
<li><p><strong>多级存储</strong>：现代计算机系统采用多级存储层次结构，将存储设备分为多个层次，每个层次在速度、容量和成本之间进行权衡。</p>
<ul>
<li><strong>层次结构</strong>：<ol>
<li><strong>寄存器（Registers）</strong>：速度最快，容量最小，成本最高。</li>
<li><strong>缓存（Cache）</strong>：速度较快，容量较小，成本较高。</li>
<li><strong>主存（Main Memory）</strong>：速度中等，容量较大，成本中等。</li>
<li><strong>辅助存储（Secondary Storage）</strong>：速度较慢，容量最大，成本最低（如硬盘、SSD）。</li>
<li><strong>三级存储（Tertiary Storage）</strong>：速度最慢，容量极大，成本最低（如磁带、光盘）。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>目的</strong>：通过多级存储层次结构，平衡速度、容量和成本，提高系统整体性能。</p>
</li>
</ul>
<h5 id="存储系统的性能参数（Evaluate-the-performance-parameters）"><a href="#存储系统的性能参数（Evaluate-the-performance-parameters）" class="headerlink" title="存储系统的性能参数（Evaluate the performance parameters）"></a><strong>存储系统的性能参数（Evaluate the performance parameters）</strong></h5><ul>
<li><p><strong>平均每比特成本（Average price per bit, C）</strong>：</p>
<ul>
<li>存储层次中，越靠近顶层的存储设备（如寄存器、缓存）成本越高，越靠近底层的存储设备（如硬盘）成本越低。</li>
<li>通过多级存储层次结构，可以在保证性能的同时降低整体成本。</li>
</ul>
</li>
<li><p><strong>命中率（Hit rate, H）</strong>：</p>
<ul>
<li>命中率是指访问数据时，数据在某一级存储中找到的概率。</li>
<li>命中率越高，系统性能越好。</li>
</ul>
</li>
<li><p><strong>平均内存访问时间（Average memory access time, T）</strong>：</p>
<ul>
<li>平均内存访问时间是访问数据所需的平均时间。</li>
<li>计算公式：$T = H \times T_{\text{hit}} + (1 - H) \times T_{\text{miss}}$<ul>
<li>$T_{\text{hit}}$：命中时的访问时间。</li>
<li>$T_{\text{miss}}$：未命中时的访问时间（需要从下一级存储中加载数据）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-缓存基础知识（Cache-Basic-Knowledge）"><a href="#2-缓存基础知识（Cache-Basic-Knowledge）" class="headerlink" title="2. 缓存基础知识（Cache Basic Knowledge）"></a><strong>2. 缓存基础知识（Cache Basic Knowledge）</strong></h4><h5 id="映射规则（Mapping-Rules）"><a href="#映射规则（Mapping-Rules）" class="headerlink" title="映射规则（Mapping Rules）"></a><strong>映射规则（Mapping Rules）</strong></h5><ul>
<li>缓存将主存中的数据映射到缓存中，常见的映射规则包括：<ol>
<li><strong>直接映射（Direct Mapping）</strong>：<ul>
<li>主存中的每个块只能映射到缓存中的一个特定位置。</li>
<li>优点：实现简单。</li>
<li>缺点：容易发生冲突，导致缓存命中率降低。</li>
</ul>
</li>
<li><strong>全相联映射（Fully Associative Mapping）</strong>：<ul>
<li>主存中的每个块可以映射到缓存中的任意位置。</li>
<li>优点：冲突少，缓存命中率高。</li>
<li>缺点：实现复杂，查找速度慢。</li>
</ul>
</li>
<li><strong>组相联映射（Set Associative Mapping）</strong>：<ul>
<li>主存中的每个块可以映射到缓存中的一组位置。</li>
<li>优点：平衡了直接映射和全相联映射的优点。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="访问方法（Access-Method）"><a href="#访问方法（Access-Method）" class="headerlink" title="访问方法（Access Method）"></a><strong>访问方法（Access Method）</strong></h5><ul>
<li><strong>顺序访问（Sequential Access）</strong>：<ul>
<li>按顺序访问数据，适合连续存储的数据。</li>
</ul>
</li>
<li><strong>随机访问（Random Access）</strong>：<ul>
<li>可以任意访问数据，适合非连续存储的数据。</li>
</ul>
</li>
</ul>
<h5 id="替换算法（Replacement-Algorithm）"><a href="#替换算法（Replacement-Algorithm）" class="headerlink" title="替换算法（Replacement Algorithm）"></a><strong>替换算法（Replacement Algorithm）</strong></h5><ul>
<li>当缓存已满时，需要替换掉某个缓存块，常见的替换算法包括：<ol>
<li><strong>最近最少使用（LRU, Least Recently Used）</strong>：<ul>
<li>替换最近最少使用的缓存块。</li>
</ul>
</li>
<li><strong>先进先出（FIFO, First In First Out）</strong>：<ul>
<li>替换最早进入缓存的缓存块。</li>
</ul>
</li>
<li><strong>随机替换（Random Replacement）</strong>：<ul>
<li>随机选择一个缓存块进行替换。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="写策略（Write-Strategy）"><a href="#写策略（Write-Strategy）" class="headerlink" title="写策略（Write Strategy）"></a><strong>写策略（Write Strategy）</strong></h5><ul>
<li><strong>写直达（Write Through）</strong>：<ul>
<li>每次写操作同时更新缓存和主存。</li>
<li>优点：数据一致性高。</li>
<li>缺点：写操作速度慢。</li>
</ul>
</li>
<li><strong>写回（Write Back）</strong>：<ul>
<li>写操作只更新缓存，当缓存块被替换时才写回主存。</li>
<li>优点：写操作速度快。</li>
<li>缺点：数据一致性较低。</li>
</ul>
</li>
</ul>
<h5 id="缓存性能分析（Cache-Performance-Analysis）"><a href="#缓存性能分析（Cache-Performance-Analysis）" class="headerlink" title="缓存性能分析（Cache Performance Analysis）"></a><strong>缓存性能分析（Cache Performance Analysis）</strong></h5><ul>
<li>缓存的性能主要取决于命中率和访问时间。</li>
<li>提高缓存性能的方法：<ul>
<li>增加缓存容量。</li>
<li>优化映射规则和替换算法。</li>
<li>提高缓存访问速度。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-虚拟内存（Virtual-Memory）"><a href="#3-虚拟内存（Virtual-Memory）" class="headerlink" title="3. 虚拟内存（Virtual Memory）"></a><strong>3. 虚拟内存（Virtual Memory）</strong></h4><h5 id="内存组织结构对缓存未命中率的影响（The-influence-of-memory-organization-structure-on-Cache-failure-rate）"><a href="#内存组织结构对缓存未命中率的影响（The-influence-of-memory-organization-structure-on-Cache-failure-rate）" class="headerlink" title="内存组织结构对缓存未命中率的影响（The influence of memory organization structure on Cache failure rate）"></a><strong>内存组织结构对缓存未命中率的影响（The influence of memory organization structure on Cache failure rate）</strong></h5><ul>
<li>虚拟内存通过将主存和辅助存储结合，扩展了程序的可用内存空间。</li>
<li>虚拟内存的组织结构（如页大小、页表设计）会影响缓存的未命中率：<ol>
<li><strong>页大小</strong>：<ul>
<li>较大的页可以减少页表大小和 TLB 未命中次数，但可能增加内部碎片。</li>
<li>较小的页可以减少内部碎片，但可能增加页表大小和 TLB 未命中次数。</li>
</ul>
</li>
<li><strong>页表设计</strong>：<ul>
<li>多级页表可以减少页表占用的内存空间，但可能增加地址转换时间。</li>
</ul>
</li>
<li><strong>TLB（Translation Lookaside Buffer）</strong>：<ul>
<li>TLB 是用于加速虚拟地址到物理地址转换的硬件缓存。</li>
<li>TLB 的命中率直接影响缓存性能。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="Chapter-4-Instruction-Level-Parallelism"><a href="#Chapter-4-Instruction-Level-Parallelism" class="headerlink" title="Chapter 4 Instruction-Level Parallelism"></a>Chapter 4 Instruction-Level Parallelism</h1><p><strong>RISC处理器的经典五级流水线</strong></p>
<ul>
<li>Dependences are a property of programs 依赖性是程序的一种性质</li>
<li>Hazards are properties of pipeline organization 冒险是流水线组织的一种特性</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-88.png" alt="alt text"></p>
<h2 id="4-1-Dynamic-Scheduling"><a href="#4-1-Dynamic-Scheduling" class="headerlink" title="4.1 Dynamic Scheduling"></a>4.1 Dynamic Scheduling</h2><p>简单的流水线技术的主要限制是</p>
<ul>
<li>指令顺序发布并执行</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-89.png" alt="alt text"></p>
<p>前两条指令存在数据依赖，DIV语句的执行时间一般很长。那么前两条指令就会等待除法完成，顺序执行里面后面的指令也会跟着等(但其实和除法没有关系)，这样就造成了浪费</p>
<ul>
<li><strong>Idea</strong>：动态调度</li>
<li><strong>Method</strong>：out-of-order execution</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/计算机体系结构(Computer%20Architecture" alt="alt text">/image-90.png)</p>
<blockquote>
<p>乘法的运算时间长，同时出现的频率高</p>
</blockquote>
<ul>
<li>load/store属于整数运算部件</li>
<li>scoreboard记录当前系统所有的状态(指令进行到什么状态，功能部件当前被那条指令使用，寄存器组，指令用了哪些寄存器)</li>
</ul>
<p>在之前的顺序流水线视线中，ID阶段 我们会检测结构冒险和数据冒险。如果都不发生，那么将会将这条指令放到下一阶段EX</p>
<p>我们现在希望减弱检测条件，只要没有结构冒险(结构冒险是无法解决)，就允许进入到下一阶段，具体分成两个阶段分别检测结构和数据冒险</p>
<ul>
<li><code>Issue(IS)</code>:解码指令，检测结构冒险(顺序读入)</li>
<li><code>Read Operands(RO)</code>:等待至没有数据冒险，接下来读取操作数，乱序执行(接收数据过程中只要没有数据冒险就可以执行)</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-91.png" alt="alt text"></p>
<p>IS一定是顺序取，RO不一定顺序(只要没有数据冒险就可以执行，有冒险的等待，没有冒险的执行，这就会导致乱序的出现)</p>
<ul>
<li><strong>Scoreboard algorithm</strong>是一种调度指令的算法</li>
<li>Robert Tomasulo introduces register <strong>renaming</strong> in hardware to minimize WAW and WAR hazards, named Tomasulo’s Approach.</li>
</ul>
<h3 id="4-1-1-Scoreboard-Algorithm"><a href="#4-1-1-Scoreboard-Algorithm" class="headerlink" title="4.1.1 Scoreboard Algorithm"></a>4.1.1 Scoreboard Algorithm</h3><p>计分板算法的基本结构</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-92.png" alt="alt text"></p>
<p>表是实时更新的。当指令流出(结束WB阶段)，scoreboard上就不会有其相关的信息</p>
<ul>
<li>Instruction Status记录每条指令执行到哪一步</li>
<li>Function Component Status</li>
<li>Register Status</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLD F6, 34(R2)</span><br><span class="line">FLD F2, 45(R3)</span><br><span class="line">FMUL.D F0, F2, F4</span><br><span class="line">FSUB.D F8, F2, F6</span><br><span class="line">FDIV.D F10, F0, F6</span><br><span class="line">FADD.D F6, F8, F2 </span><br></pre></td></tr></table></figure>
<ul>
<li>Instruction Status</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-93.png" alt="alt text"></p>
<p>此时指令1结束，scoreboard上没有其相关的信息。指令2还没有WB，后面的3、4需要用到2的结果F2，因此指令3、4只是完成了IS阶段，还没有执行RO阶段(存在数据冒险)。指令5用到3的结果，也不能进入RO。指令6是ADD加法操作，此时指令4是SUB，也会用到加法运算范媛，因此产生结构冒险，无法进入IS。</p>
<ul>
<li>Function Component Status</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-94.png" alt="alt text"></p>
<ul>
<li>busy代表当前这个单元是否有指令正在使用。op表示这个单元正在被哪类指令使用</li>
<li>$F_i,F_j,F_k$代表目标操作数和源操作数($F_i$是目标操作数，$F_j,F_k$是源操作数)</li>
<li>$Q_j,Q_k$代表源操作数来自哪个部件<ul>
<li>如Mult1的Qj=integer说明来自整数部件(此时正在执行Load指令)</li>
</ul>
</li>
<li>$R_j,R_k$代表源操作数的状态<ul>
<li>yes-operands is ready but no ready没读是因为其他的操作数还没有read</li>
<li>$no\&amp;Q_j=null$:operand is ready</li>
<li>$no\&amp;Q_j \neq null$:operand is not ready其他指令会修改这个操作数，而且还没有执行完毕</li>
</ul>
</li>
<li>Register Status</li>
</ul>
<p>$F_i$这一列加上op这一列组合成了这张表，表示这个寄存器将被什么指令修改</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-95.png" alt="alt text"><br><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-96.png" alt="alt text"></p>
<blockquote>
<p>注意到在这之后，最后一条ADD指令必须等到DIV指令RO之后才能WB(否则会修改F6)</p>
</blockquote>
<p>Scoreboard算法可以检测出冲突，但是不能解决冲突，还是通过阻塞的方法来解决，scoreboard上面的信息页比较复杂，效率不高</p>
<h3 id="4-1-2-Tomasulo’s-Approach"><a href="#4-1-2-Tomasulo’s-Approach" class="headerlink" title="4.1.2 Tomasulo’s Approach"></a>4.1.2 Tomasulo’s Approach</h3><p>These name dependences can all be eliminated by register renaming</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-97.png" alt="alt text"></p>
<p>The basic structure of a floating-point unit using Tomasulo’s approach :</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-98.png" alt="alt text"></p>
<p>指令从指令队列出来(顺序)，先进入绿色的buffer，随后再进行操作。如果buffer已经满了还有指令要进入就需要等待(阻塞)。</p>
<p>这里Reservation Station的目的是为了一次性放进来多条指令，然后再buffer内完成乱序，即buffer内哪条指令操作数ready了就执行</p>
<p>此外在保留站内部还要进行rename，有可能依赖的是另一个保留站里的指令。每个保留站有唯一的命名</p>
<ul>
<li><p>It tracks when operands for instructions are available to minimize RAW hazards;</p>
</li>
<li><p>It introduces register renaming in hardware to minimize WAW and WAR hazards.</p>
</li>
</ul>
<h4 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h4><ul>
<li><code>Issue</code>(发射):从指令队列的头部取出下一条指令(FIFO)</li>
</ul>
<p>从队列中顺序取出指令，并放入对应的保留站，进入保留站后，就会进行重命名，消除了WAR和WAW冒险</p>
<ul>
<li>如果保留站有空位，就将指令放到保留站中<ul>
<li>如果操作数就绪(在寄存器中)直接加在到保留站</li>
<li>若操作数未就绪，记录该操作数产生的功能单元(即等待其他指令的结果)</li>
</ul>
</li>
<li><p>如果保留站没有空位，就等待阻塞(即保留站的空闲情况决定了指令是否流出，而不是由功能部件的情况决定)</p>
</li>
<li><p><code>Execute</code>:</p>
<ul>
<li>保留站里的指令操作数都就就绪了，就可以执行。这一步实现了乱序</li>
<li>load and store需要两步执行操作<ul>
<li>计算有效地址：当指令的基址寄存器的值就绪时，计算内存地址：<code>有效地址=基地址+偏移量</code>，将计算出的有效地址存入load/store buffer。(避免因内存延迟阻塞流水线)</li>
<li>当内存单元就绪时，进行load/store操作</li>
</ul>
</li>
</ul>
</li>
<li><code>Write Results</code><ul>
<li>通过 CDB 总线将结果写回到寄存器的同时，将结果发到其他所有标记了的（先前寄存器中没有值被标记值来源，计算得到之后需要被赋值）保留站里。（因此 CDB 也会影响 CPU 的效率，因此现在用多条总线保证效率）</li>
<li>只有当要写入的值和要写入的地址都准备就绪且内存单元空闲时，才会将数据从Store Buffer写入内存</li>
</ul>
</li>
</ul>
<h2 id="4-2-Hardware-Based-Speculation"><a href="#4-2-Hardware-Based-Speculation" class="headerlink" title="4.2 Hardware-Based Speculation"></a>4.2 Hardware-Based Speculation</h2><p>为了让指令执行完成的顺序也是顺序的，我们添加了一个reorder buffer</p>
<p>结果先写到reorder buffer,在buffer里按照指令流出的顺序依次协会寄存器。因此我们再每个指令后面加上一个commit状态，当前面的指令都commit之后才能commit</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-99.png" alt="alt text"></p>
<p>The basic structure of a FP unit using Tomasulo’s algorithm and extended to handle speculation:</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-100.png" alt="alt text"></p>
<ul>
<li>Issue:从指令队列中取出指令</li>
<li>Execution:operand on operands(EX)</li>
<li>Write Result:finish execution(WB)</li>
<li>Commit:update register with reorder result</li>
</ul>
<p>Hardware-based speculation包含三个关键的思想 ：</p>
<ul>
<li>动态分支预测来选择执行的指令</li>
<li>利用推测，可以在解决控制依赖问题之前执行命令(能够撤销错误推测指令序列的影响)</li>
<li>进行动态调度，以应对不同组合方式的基本模块调度(与之相对，没有推测的动态调度只能部分重叠基本模块，因为它要求先解析一个分支，然后才能实际执行后续基本模块中的指令)</li>
</ul>
<p><strong>执行程序的方法实质</strong>：数据流执行，也就是操作数一旦可用就立即执行</p>
<p>前面的IS和EX阶段与Tomasulo算法一样只是WB阶段增加了一个commit状态，只有当指令commit之后才能写回寄存器</p>
<ul>
<li>WB<ul>
<li>当结果可用时，将结果写在CDB上(还有在发射指令时发送的ROB标签，也就是指令写回时对应的顺序)，并从CDB写到ROB以及任何等待这一结果的保留站。</li>
<li>将保留站(刚刚写在CDB上的指令所使用的保留站)标记为可用</li>
<li>对于存储器指令(load and store)需要执行一些额外的操作。 <ul>
<li>如果要存储的值已经准备就绪，则将它写到ROB条目的值字段来等待访问存储器</li>
<li>如果要存储的值还不可用，则必须监视CDB，直到该数值被广播，再更新该存储指令ROB条目的值字段</li>
</ul>
</li>
</ul>
</li>
<li>Instruction Commit:根据要提交的指令是预测错误的分支指令、存储指令还是任意其他指令(可以正常提交的指令)有三种不同的操作模式<ul>
<li><strong>正常提交</strong>：当一个指令到达ROB的头部而且其结果出现在缓冲区中时，进行正常提交，此时处理器用结果更新寄存器，并从ROB中清除该指令</li>
<li><strong>存储指令提交</strong>：具体步骤与正常提交相似，但是更新的是存储器而不是结果寄存器。</li>
<li><strong>预测错误的分支提交</strong>：当指令到达ROB的头部时<ul>
<li>如果推测是错误的<strong>ROB被清空</strong>，执行过程从该分支的正确后续指令重新开始。</li>
<li>如果推测是正确的，则该分支完成提交</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>指令一旦提交完毕，它在ROB中的相应项被收回，寄存器或存储器目的地址将被更新，并且不再需要ROB项。</p>
<p>如果ROB填满，则停止发射指令，直到有空闲条目为止。</p>
<p>!!! example Example</p>
<pre><code>The status tables when `FMUL.D` is ready to commit:

- **Dest**: 这里是保留站的名称（一个字段）,在这里可以是即将进入到ROB中的标号，而不是寄存器的名称,也就是这个保留站条目所生成结果的目的地

- **Example Table**:

![FMUL.D Status](image-101.png)

- **Busy**标识标识当前正在执行的指令，也就是尚未commit的指令
</code></pre><p>!!! Practice<br>    <img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-102.png" alt="alt text"></p>
<pre><code>- 发射阶段需要两个周期，由发射和解码两部分组成
- `commit`部分与CPU的运算不冲突，CPU的运行效率并不会受到影响。**相当于整个过程中只是多了commit部分的等待过程，但是运算部分的周期与commit所需要花费的周期没有直接关系，write back之后就可以直接使用对应的数据**
- 实际上加上ROB之后，前面的执行和Tomasulo算法是一样的，只是多了一个commit状态，需要加一列按照流出顺序提交，必要的时候需要等待
</code></pre><ul>
<li>Instructions are finished in order according to ROB经过ROB处理的指令是有序输出的</li>
<li>It can be precise exception.处理中断时，提供精确异常</li>
<li>It is easily extended to integer register and integer function unit.</li>
<li>But the hardware is too complex.</li>
</ul>
<h2 id="4-3-Exploiting-ILP-Using-Multiple-Issue-and-Static-Scheduling"><a href="#4-3-Exploiting-ILP-Using-Multiple-Issue-and-Static-Scheduling" class="headerlink" title="4.3 Exploiting ILP Using Multiple Issue and Static Scheduling"></a>4.3 Exploiting ILP Using Multiple Issue and Static Scheduling</h2><p>多流出，也就是一拍可以流出多条指令</p>
<ul>
<li>Superscalar:</li>
</ul>
<p>可以分为静态调度超标量和动态调度超标量。静态调度是通过编译器来完成的，动态调度是通过硬件来完成的</p>
<p>每个时钟周期发射的指令条数可能不一样</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/207e3c9786995a81e32055536a6aee3.jpg" alt="alt text"></p>
<ul>
<li><p>VLIW (Very Long Instruction Word)：将多条指令包装在一条指令中</p>
<p>超长指令字也是通过编译器完成的</p>
<p>每个时钟周期发射的指令条数是固定的。它们组成一条长指令或者一个指令包</p>
<p>!!!example<br>  我们考虑一个VLIW处理器，在上面包含5种运算的指令，包括一个整数运算、两个浮点运算和两个存储器访问。这些指令可能拥有与每个功能单元相对应的一组字段</p>
<p>  这些指令可能拥有与每个功能单元相对应的一组字段，每个单元可能为16~24位，得到的指令长度介于80~120位之间</p>
</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-103.png" alt="alt text"></p>
<h3 id="4-3-1-Based-on-static-scheduling"><a href="#4-3-1-Based-on-static-scheduling" class="headerlink" title="4.3.1 Based on static scheduling"></a>4.3.1 Based on static scheduling</h3><p>In a typical superscalar processor, 1 to 8 instructions can be issued per clock cycle.</p>
<p>我们要进行结构冒险和数据冒险的检测。需要注意的是，如果遇到了分支跳转指令，那么只流出这一条，不能和其他指令一起流出。如果处理器有分支预测，那么下一个周期就可以根据预测结果进行发射；如果不带预测，我们就需要等待分支结果，然后再发射。</p>
<p>!!!example</p>
<pre><code>- Assumption: Two instructions flow out every clock cycle:
    - 1 integer instruction + 1 floating-point operation instruction
- Among them, load, store and branch instructions are classified as integer instructions.
![alt text](image-104.png)
</code></pre><h3 id="4-3-2-Based-on-dynamic-scheduling"><a href="#4-3-2-Based-on-dynamic-scheduling" class="headerlink" title="4.3.2 Based on dynamic scheduling"></a>4.3.2 Based on dynamic scheduling</h3><p>Extended Tomasuloalgorithm: supports two-way superscalar</p>
<p>指令顺序进入保留站，分开处理</p>
<p>!!!example<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Loop:</span><br><span class="line">FLD    F0, 0 (R1)   // Take an array element and put it into F0</span><br><span class="line">FADD.D F4, F0, F2   // add the scalar in F2</span><br><span class="line">FSD    F4, 0 (R1)   // storeresult</span><br><span class="line">ADDI   R1, R1, 8    // increment pointer by 8 //(each data occupies 8 bytes)</span><br><span class="line">BNE    R1, R2, Loop // If R1 is not equal to R2, it means it is not over yet, move to Loop to continue</span><br></pre></td></tr></table></figure></p>
<pre><code>对于没有分支预测的情况：可以看到分支后面的一条指令，在周期7才能执行(即周期6分支指令执行结束)

![alt text](image-105.png)

- The program can basically reach 3 beats and 5 instructions
    - IPC＝5/3＝1.67 items/beat
- the execution efficiency is not very high.
    - A total of 15 instructions were executed in 16 beats.
    - The average command execution speed is 15/16=0.94 per beat.
</code></pre><h3 id="4-3-3-Very-long-instruction-word-technology-VLIW"><a href="#4-3-3-Very-long-instruction-word-technology-VLIW" class="headerlink" title="4.3.3 Very long instruction word technology(VLIW)"></a>4.3.3 Very long instruction word technology(VLIW)</h3><p>Assemble multiple instructions that can be executed in parallel into a very long instruction.</p>
<p>At compile time, multiple unrelated or unrelated operations that can be executed in parallel are combined to form a very long instruction word with multiple operation segments.</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/e4e748c50758ddb671ba1682c750622.jpg" alt="alt text"></p>
<blockquote>
<p>相当于只在EX阶段进行了并行操作</p>
</blockquote>
<h3 id="4-3-4-Superpipeline-processor"><a href="#4-3-4-Superpipeline-processor" class="headerlink" title="4.3.4 Superpipeline processor"></a>4.3.4 Superpipeline processor</h3><p>A pipeline processor with 8 or more instruction pipeline stages is called a superpipelining processor.</p>
<p>在一个很小的$\Delta t$时间(小于一个阶段的用时)后就发射下一条指令</p>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-106.png" alt="alt text"></p>
<ul>
<li>本质就是流水线的细分</li>
</ul>
<p><img src="/2025/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84(Computer%20Architecture)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Computer-Architecture/image-107.png" alt="alt text"></p>
<h1 id="Chapter-5-DLP-and-TLP"><a href="#Chapter-5-DLP-and-TLP" class="headerlink" title="Chapter 5: DLP and TLP"></a>Chapter 5: DLP and TLP</h1><h2 id="5-1-SIMD-vector-processor"><a href="#5-1-SIMD-vector-processor" class="headerlink" title="5.1 SIMD:vector processor"></a>5.1 SIMD:vector processor</h2><ul>
<li>SIMD架构可以利用重要的data-level parallelism<ul>
<li>Matrix-oriented(矩阵导向)的科学计算</li>
<li>Media-oriented image and sound processors（面向媒体的图像和声音处理器 ）</li>
</ul>
</li>
<li>SIMD在功耗效率上优于MIMD</li>
<li>SIMD允许程序员按顺序思考</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据库系统 Database System</title>
    <url>/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/</url>
    <content><![CDATA[<h1 id="Chapter-1-Introduction"><a href="#Chapter-1-Introduction" class="headerlink" title="Chapter 1: Introduction"></a>Chapter 1: Introduction</h1><h2 id="1-Database-Systems"><a href="#1-Database-Systems" class="headerlink" title="1. Database Systems"></a>1. Database Systems</h2><p>DBMS(Database Management System)</p>
<ul>
<li>数据库定义</li>
<li>数据组织、存储和管理</li>
<li>数据操作</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护</li>
<li>不同数据库之间的交互</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-20.png" alt="alt text"></p>
<ul>
<li>数据库系统是一些管理互相关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合<h2 id="2-数据库系统的目标"><a href="#2-数据库系统的目标" class="headerlink" title="2. 数据库系统的目标"></a>2. 数据库系统的目标</h2>相比于File-Processing System，数据库系统可以解决下面的问题</li>
</ul>
<p><strong><em>两者一个巨大的区别是文件系统是操作系统的重要组成部分，DBMS是独立于操作系统的软件。DBMS的实现与操作系统中的文件系统是紧密相关的</em></strong></p>
<ul>
<li>数据冗余(rebundancy)和不一致性(inconsistency):相同的信息可能在不同的文件中重复存储；不同文件中的信息在修改后可能会出现不一致的现象</li>
<li>数据访问困难：对于有特定要求的数据，传统的文件管理系统需要写大量的访问应用程序保证能够按照要求访问数据。</li>
<li>数据孤立：数据分散在不同文件中，文件可能不具有相同的文件格式，编写应用程序来检索适当数据是很困难的</li>
<li>完整性问题(integrity problems):数据库中存储的数据值需要满足一些特定的约束条件(constraint)，比如银行账户余额必须非负，学生ID的位数必须相同等等。</li>
<li>原子性问题(atomicity problems):一个原子的操作要么全部发生要么根本不发生</li>
<li>并发访问异常(Concurrent access anomalies):并发的更新操作可能相互影响，有可能导致数据的不一致。eg.学生选课，教学班容量差一人，两名学生同事抢课就会存在计数异常的情况导致两名同学都可以选到这门课</li>
<li>安全性问题：数据库系统有明确的访问权限，并非每一个用户都可以访问所有数据<h2 id="3-数据库的特征"><a href="#3-数据库的特征" class="headerlink" title="3. 数据库的特征"></a>3. 数据库的特征</h2></li>
<li>数据持久性</li>
<li>数据访问便利</li>
<li>数据完整性</li>
<li>多用户并发控制</li>
<li>故障恢复</li>
<li>安全控制<h2 id="4-数据视图"><a href="#4-数据视图" class="headerlink" title="4. 数据视图"></a>4. 数据视图</h2>数据库的主要目的是给用户提供数据的抽象视图，我们对数据库进行三级的抽象。</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-21.png" alt="alt text"></p>
<ul>
<li>Physical Level:描述数据实际上是怎样存储的。物理层详细描述复杂的底层数据结构。</li>
<li>Logical Level:比物理层层次稍高的抽象，描述数据库中存储什么数据以及这些数据间存在什么联系。<ul>
<li>物理数据独立性：虽然逻辑层的简单数据结构的实现可能涉及复杂的物理层结构，但是逻辑层的用户不比意识到这样的复杂性。</li>
</ul>
</li>
<li>View Level:最高层次的抽象。只描述数据库的某个部分。尽管在逻辑层使用了相对简单的结构，但是由于一个大型数据库中所存储的信息的多样性仍存在一定程度的复杂性。但是用户不需要所有的这些信息，而只需要访问数据库的一部分。视图层抽象的存在正是为了使这些用户与系统之间的交互更加简单。<ul>
<li><strong><em>系统可以为统一数据库提供多个视图</em></strong></li>
</ul>
</li>
</ul>
<p><strong>Advantages</strong></p>
<ul>
<li>隐藏了复杂性</li>
<li>对变化的适应得到增强<ul>
<li>硬件变化(physical level)，可以通过调整逻辑关系和映射来适应新的硬件环境。</li>
<li>逻辑环境变化(logical level),可以通过视图层和logic的映射使得view尽量少变化。<h3 id="4-1-模式-schema-与实例-Instance"><a href="#4-1-模式-schema-与实例-Instance" class="headerlink" title="4.1 模式(schema)与实例(Instance)"></a>4.1 模式(schema)与实例(Instance)</h3>与编程语言中的类型和变量概念相似：</li>
</ul>
</li>
<li>模式(schema)-数据库的逻辑结构(physical/logical)</li>
<li>实例(instance)-在<strong><em>某一个特定的时间点</em></strong>数据库中的真实内容<h3 id="4-2-数据独立性-指数据和程序相互不依赖，把数据的定义从程序中分离出来"><a href="#4-2-数据独立性-指数据和程序相互不依赖，把数据的定义从程序中分离出来" class="headerlink" title="4.2 数据独立性(指数据和程序相互不依赖，把数据的定义从程序中分离出来)"></a>4.2 数据独立性(指数据和程序相互不依赖，把数据的定义从程序中分离出来)</h3></li>
</ul>
<p>DBMS负责数据的存储，从而简化应用程序</p>
<ul>
<li><strong>物理数据独立性</strong>：the ability to modify the physical schema without changing the logical schema，需要修改内模式与概念模式之间的映射关系</li>
<li><strong>逻辑数据独立性</strong>：the ability to modify the logical schema without changing the user view schema，需要修改外模式与概念模式之间的映射关系</li>
</ul>
<p>映射修改，但不用修改schema</p>
<h2 id="5-Data-Models"><a href="#5-Data-Models" class="headerlink" title="5. Data Models"></a>5. Data Models</h2><p>Data models is a collection of tools for describing data, data relationships, data semantics(数据的语义), data constraints.</p>
<ul>
<li><p>三要素</p>
<ul>
<li>数据结构 </li>
<li>数据操作 </li>
<li>数据约束条件<blockquote>
<p>模型就是对现实世界特征的抽象，数据模型是对现实世界数据特征的抽象</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Relational model(关系模型)：（表格）数据库系统层面</p>
</li>
<li>Entity-Relationship(实体-联系) data model：需求分析层面</li>
<li>Object-based data models<ul>
<li>Object-oriented (面向对象数据模型)</li>
<li>Object-relational (对象-关系模型模型)</li>
</ul>
</li>
<li>Semistructured data model (XML)(半结构化数据模型)</li>
<li>Other older models:<ul>
<li>Network model (网状模型)</li>
<li>Hierarchical model(层次模型)</li>
</ul>
</li>
</ul>
<ul>
<li>概念数据模型：按照用户的观点对数据和信息建模，是现实世界到信息世界的第一层抽象<ul>
<li>ER模型：接近于人类的思考方式，容易理解并且与计算机无关。只能说明实体之间的语义练习，不能进一步地详细说明数据结构</li>
</ul>
</li>
<li>基本数据模型：按计算机系统的关键对数据建模，，是现实数据特征的抽象<ul>
<li>层次模型</li>
<li>网状模型</li>
<li>关系模型：用二维表格结构表达实体集以及实体集之间的联系。最大的特征就是<strong>描述的一致性</strong></li>
<li>面向对象数据模型<h2 id="6-数据库语言"><a href="#6-数据库语言" class="headerlink" title="6. 数据库语言"></a>6. 数据库语言</h2><h3 id="6-1-数据定义语言（Data-Definition-Language-DDL）"><a href="#6-1-数据定义语言（Data-Definition-Language-DDL）" class="headerlink" title="6.1 数据定义语言（Data Definition Language,DDL）"></a>6.1 数据定义语言（Data Definition Language,DDL）</h3><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-22.png" alt="alt text"><br>数据字典包含元数据(metadata)</li>
</ul>
</li>
<li>描述数据属性、结构、关系等的数据</li>
<li>DDL编译器生成一系列table templates并存储在数据字典（数据字典是一系列表，包含一系列元数据）</li>
<li>Authorization(权限)</li>
<li>Integrity constraints (完整性约束) Primary key (ID uniquely identifies instructors, 主键) Referential integrity (references constraint in SQL, 参照完整性) e.g. dept_name value in any instructor tuple must appear in department relational<h3 id="6-2-Data-Manipulation-Language-DML-数据操作语言"><a href="#6-2-Data-Manipulation-Language-DML-数据操作语言" class="headerlink" title="6.2 Data Manipulation Language (DML, 数据操作语言)"></a>6.2 Data Manipulation Language (DML, 数据操作语言)</h3></li>
<li>Procedural(过程式):用户确定需要什么数据和如何获取这些数据eg.C</li>
<li>Declarative(声明式):用户只描述需要什么数据(陈述式，非过程式nonprocedural):用户确定需要什么数据但是不需要确定如何获取这些数据eg.SQL</li>
</ul>
<h3 id="6-3-SQL-Query-Language"><a href="#6-3-SQL-Query-Language" class="headerlink" title="6.3 SQL Query Language"></a>6.3 SQL Query Language</h3><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-23.png" alt="alt text"></p>
<h3 id="6-4-Database-Access-from-Application-Program"><a href="#6-4-Database-Access-from-Application-Program" class="headerlink" title="6.4 Database Access from Application Program"></a>6.4 Database Access from Application Program</h3><ul>
<li>数据库必须由过程式语言编写</li>
<li>Application programs generally access databases through one of <strong>Language extensions to allow embedded SQL e.g. 通过预处理器，将 select 语句识别出来，翻译成 C 语言的函数调用。</strong> API (Application program interface) e.g. ODBC/JDBC which allow SQL queries to be sent to a database.<h2 id="7-数据库设计"><a href="#7-数据库设计" class="headerlink" title="7. 数据库设计"></a>7. 数据库设计</h2></li>
<li>解决的问题：如何组织这些属性到各个表中</li>
<li>实体-联系模型：Entity Relationship Model一对一/一对多/多对一/多对多</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-24.png" alt="alt text"></p>
<ul>
<li>Normalization Theory (规范化理论):Formalize what designs are bad, and test for them。将所有的属性集作为输入，生成一组关系表<blockquote>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-25.png" alt="alt text"></p>
<blockquote>
<p>这个表存在冗余, department 有重复，应该拆分为两个表（前四列和后三列）然后通过外键进行表的关联</p>
<h2 id="8-数据库引擎"><a href="#8-数据库引擎" class="headerlink" title="8. 数据库引擎"></a>8. 数据库引擎</h2><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-26.png" alt="alt text"></p>
</blockquote>
</blockquote>
</li>
<li>存储管理器</li>
<li>查询处理器</li>
<li>事务管理<blockquote>
<p>数据库系统的功能部件</p>
<h3 id="8-1-存储管理器"><a href="#8-1-存储管理器" class="headerlink" title="8.1 存储管理器"></a>8.1 存储管理器</h3></blockquote>
</li>
<li>权限及完整性管理器</li>
<li>事务管理器：保证一旦发生故障，数据库的一致性状态</li>
<li>文件管理器：管理用于表示磁盘所有信息的数据结构</li>
<li>缓冲管理器：负责将数据从磁盘放入内存，并决定哪些数据应被缓冲放入内存</li>
</ul>
<p>负责数据库中数据的<strong>存储、检索和更新</strong></p>
<ul>
<li>在数据库中存储的<strong>底层数据与应用程序</strong>以及向系统提交的查询之间提供接口的部件。</li>
<li>与文件管理器进行交互，原始数据通过系统提供的文件系统存储在磁盘上</li>
<li><p>将各种DML语句翻译为底层文件系统命令</p>
</li>
<li><p>作为数据库系统物理实现的一部分，存储管理器实现了以下几种数据结构</p>
<ul>
<li>数据文件：存储数据库自身</li>
<li>数据字典：存储关于数据库结构的元数据，特别是数据库模式</li>
<li>索引：存储关于数据库中数据的索引，提供对数据项的快速访问<h3 id="8-2-查询处理器"><a href="#8-2-查询处理器" class="headerlink" title="8.2 查询处理器"></a>8.2 查询处理器</h3>查询处理器组件包括：</li>
</ul>
</li>
<li>DDL解释器：解释DDL语句并将这些定义记录在数据字典中</li>
<li>DML解释器：将查询语言中的<strong>DML语句</strong>翻译成<strong>查询执行引擎能够理解的低级指令的执行方案</strong><ul>
<li>查询优化：从几个有相同结果的候选执行计划中选出代价最小的那个执行计划。（执行计划会根据统计数据的改变而改变）</li>
</ul>
</li>
<li>查询执行引擎(query evaluation engine)：执行由DML编译器产生的低级指令</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-27.png" alt="alt text"></p>
<h3 id="8-3-事务管理-Transaction-Management"><a href="#8-3-事务管理-Transaction-Management" class="headerlink" title="8.3 事务管理(Transaction Management)"></a>8.3 事务管理(Transaction Management)</h3><p>银行转账，A 转账到 B, A 余额减掉 B 余额加上。 要有隔离性，延迟写回</p>
<ul>
<li>事务:数据库应用中完成单一逻辑功能的操作集合。每一个事务既具有原子性又具有一致性</li>
<li>恢复管理器(Recover Manager)：当故障发生时，为保证原子性，数据库必须被恢复到该事务开始执行以前的状态。</li>
<li>并发控制器(Concurrency-control manager):控制并发事务间的相互影响，保证数据库的一致性<h2 id="9-Database-Users"><a href="#9-Database-Users" class="headerlink" title="9. Database Users"></a>9. Database Users</h2><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-29.png" alt="alt text"></li>
</ul>
<h1 id="Chapter-2-Introduction-to-Relational-Model"><a href="#Chapter-2-Introduction-to-Relational-Model" class="headerlink" title="Chapter 2:Introduction to Relational Model"></a>Chapter 2:Introduction to Relational Model</h1><blockquote>
<p>你和你的宠物狗属于relationship的概念；足球队所有的成员属于relation的概念</p>
<h2 id="1-Structure-of-Relational-Databases"><a href="#1-Structure-of-Relational-Databases" class="headerlink" title="1. Structure of Relational Databases"></a>1. Structure of Relational Databases</h2><h3 id="1-1-Concepts"><a href="#1-1-Concepts" class="headerlink" title="1.1 Concepts"></a>1.1 Concepts</h3><p>Formally, given set $D_1,D_2,…,D_n$(一系列单元素的集合).</p>
<ul>
<li>A relation r is a subset of $D_1\times D_2 \times D_n$.Thus a relation is a set of n-tuple $(a_1,a_2,…a_n)$ where each $a_i\in D_i$</li>
</ul>
</blockquote>
<ul>
<li>$A_1,A_2,…,A_n$都是attributes(属性)。$R=(A_1,A_2,…,A_n)$是一个关系模型</li>
<li>关系实例r根据关系实例定义为r(R)</li>
<li>因为关系是一个集合，所以关系都是无序的</li>
<li>关系中的元组不存在重复的情况</li>
<li>属性的值是原子的<h3 id="1-2-Attributes"><a href="#1-2-Attributes" class="headerlink" title="1.2 Attributes"></a>1.2 Attributes</h3></li>
<li>The set of allowed values for each attribute is called the domain (域)of the attribute</li>
<li>Attribute values are (normally) required to be atomic (原子的); that is, indivisible<ul>
<li>Strictly indivisible example:存储姓名时将姓和名分开。如果不需要查询姓和名可以将姓名作为一个属性，名字这个属性就是不可拆分的整体</li>
<li>Non-atomic example:两个电话号码存储在了一个属性中；一本书的所有信息存储在一个属性中</li>
</ul>
</li>
<li>The special value null (空值) is a member of every domain.<ul>
<li>不存在的信息</li>
<li>存在但是未知的信息</li>
</ul>
</li>
</ul>
<h2 id="2-Database-Schema"><a href="#2-Database-Schema" class="headerlink" title="2. Database Schema"></a>2. Database Schema</h2><ul>
<li>Bad design:把所有信息储存在一个属性中<ul>
<li>信息的重复(如两名同学有相同的导师)导致了不一致和信息冗余</li>
<li>空值的需求(一个学生没有导师)，需要额外处理</li>
</ul>
</li>
<li>Database schema:is the logical structure of the database.-抽象的定义，database中所有的schema</li>
<li>Database instance:is a snapshot of the data in the database at a given instant in time.-具体的实例，database中所有的instance<blockquote>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-30.png" alt="alt text"></p>
<h2 id="3-Keys"><a href="#3-Keys" class="headerlink" title="3. Keys"></a>3. Keys</h2><p>Let $K \subseteq R$</p>
</blockquote>
</li>
<li>K is a superkey (超键) of R if values for K are sufficient to identify (唯一确定) a unique tuple of each possible relation r(R)<ul>
<li>可以唯一确定一行，但是可能会存在冗余的属性</li>
<li>e.g.{ID}和{ID,name}都是superkey</li>
</ul>
</li>
<li>Superkey K is a candidate key (候选键) if K is minimal.<ul>
<li>K可以确定唯一一行且没有冗余属性.也就是K没有子集可以是超键</li>
<li>候选键可以由多个元素组成</li>
</ul>
</li>
<li>侯选建中的一个可以给选作primary key（主键）<ul>
<li>选择的主键往往是相对稳定的</li>
<li>往往手动确定</li>
</ul>
</li>
<li><p>Foreign key（外键）限制：关系r1引用的主键必须在关系r2中出现。类似于指针</p>
<ul>
<li>引入的意义：实现完整性约束</li>
<li>Referenced Relation是被引用的表（被引用的属性往往都是primary key），Referencing是外键所在的表</li>
<li>为什么需要外键限制：数据库是支持由完整约束条件定义出来的，并维护完整性约束条件。则当我们定义外键后，上述例子中黄色条目是不会出现的。</li>
<li><p>外码的值可以是空值：避免在数据不完整时插入无效的外码值<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-31.png" alt="alt text"></p>
<p>Referential Integrity(参照完整性)：类似于外键限制，但是不限制于主键</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-33.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-32.png" alt="alt text"></p>
<ul>
<li>course 指课程信息，无论是否开课，都会有其定义。</li>
<li>section 表示教学班，真正开课时就有相应的实例。（类比于高铁的列车号，和每天对应的班次）</li>
<li>teachers 具体教哪个教学班的老师</li>
<li>takes 表示学生注册课程</li>
<li>time_slot 表示一门课的具体上课时间段，如数据库在周一 3, 4, 5 节; 周一 7, 8 节。</li>
<li>上图中红线表示引用完整性的约束；黑线表示外键约束。<h2 id="4-Relational-Algebra"><a href="#4-Relational-Algebra" class="headerlink" title="4. Relational Algebra"></a>4. Relational Algebra</h2></li>
</ul>
<blockquote>
<p>关系运算最基本的特点就是操作的对象和操作结果都是集合</p>
</blockquote>
<p>是一种过程语言，但不是编程语言</p>
<p>Input and output are all relations</p>
<p>Six basic operators</p>
<ul>
<li>For one relation:<ul>
<li>select:$\sigma$</li>
<li>project:$\Pi$</li>
<li>rename:$\rho$</li>
</ul>
</li>
<li>For two relations:<ul>
<li>union:$\cup$</li>
<li>Cartesian product:$\times$</li>
<li>difference:$-$</li>
</ul>
</li>
</ul>
<h3 id="4-1-Select"><a href="#4-1-Select" class="headerlink" title="4.1 Select"></a>4.1 Select</h3><ul>
<li>在表中找符合条件的tuple然后返回一张表<br>$σ_p(r)= \{t∣t∈r and p(t)\}$,p被称为selection predicate<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-34.png" alt="alt text"></li>
</ul>
<h3 id="4-2-Project"><a href="#4-2-Project" class="headerlink" title="4.2 Project"></a>4.2 Project</h3><p>The project operation is a unary operation that returns its argument relation, with certain attributes left out.</p>
<ul>
<li>目的：隐藏某些属性<br>$∏_{A_1,A_2,…,A_ k}(r)$ 其中$A_i$是属性的名称，r是关系的名字</li>
</ul>
<p>The result is defined as the relation of k columns obtained by erasing the columns that are not listed. 会对结果进行去重。<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-35.png" alt="alt text"></p>
<h3 id="4-3-Union"><a href="#4-3-Union" class="headerlink" title="4.3 Union"></a>4.3 Union</h3><p>The union operation allows us to combine two relations.</p>
<p>$r \cup s= \{ t|t\in r or t \in s \}$</p>
<ul>
<li>r and s must have the same arity (元数) (same number f attributes)</li>
<li>The attribute domains must be compatible</li>
<li>使用条件：等目（拥有的attribute数量一致）同源（attribute的值域相同）<blockquote>
<p>eg.Find all customers with either an account or a loan:两张表中的属性不可能完全相同，所以要先进行投影操作<br>当属性有关联类型时，对于每个输入i, 两个输入关系的第i个属性的类型必须相同。<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-36.png" alt="alt text"></p>
</blockquote>
</li>
</ul>
<h3 id="4-4-Set-Difference"><a href="#4-4-Set-Difference" class="headerlink" title="4.4 Set Difference"></a>4.4 Set Difference</h3><p>The set-difference operation allows us to find tuples that are in one relation but are not in another.<br>$r-s=\{t|t\in r and t\notin s\}$</p>
<p>Set differences must be taken between compatible relations.</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-37.png" alt="alt text"></p>
<h3 id="4-5-Cartesian-Product"><a href="#4-5-Cartesian-Product" class="headerlink" title="4.5 Cartesian Product"></a>4.5 Cartesian Product</h3><p>The Cartesian-product operation (denoted by ×) allows us to combine information from any two relations.<br>$r \times s= \{ (t,u)|t\in r and u\in s \}$</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-38.png" alt="alt text"></p>
<ul>
<li>笛卡尔积操作没有任何限制</li>
<li>如果进行笛卡尔积的两个relation中有名字相同的属性，我们也要将他们视为不同的属性进行操作。<h3 id="4-6-Rename"><a href="#4-6-Rename" class="headerlink" title="4.6 Rename"></a>4.6 Rename</h3>Allows us to refer to a relation by more than one name.</li>
<li><p>往往是在产生临时表的过程中产生的操作<br>$\rho_x (E)$ 表达式E的名称为x<br>$\rho_{x(A_1,A_2,…,A_n)} (E)$返回表达式E的名称为x，同时将属性重新命名为$A_1,A_2,…,A_n$</p>
</li>
<li><p>Composition of Operations 1:Find the names of all instructors in the Physics department, along with the course_id of all courses they have taught.<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-40.png" alt="alt text"></p>
<blockquote>
<p>两条语句语义是相同的，但第二种先select，笛卡尔积操作代价小，更高效<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-41.png" alt="alt text"></p>
<h3 id="4-7-Additional-Operators"><a href="#4-7-Additional-Operators" class="headerlink" title="4.7 Additional Operators"></a>4.7 Additional Operators</h3></blockquote>
</li>
<li>set intersection:$r \cap s$</li>
<li>natural join:$r \bowtie s$</li>
<li>assignment:$r \leftarrow s$</li>
<li>outer join:$r \rtimes s$,$r \ltimes s$,$r⟗s$</li>
<li>division operator:$r \div s$<h4 id="4-7-1-set-intersection-operation"><a href="#4-7-1-set-intersection-operation" class="headerlink" title="4.7.1 set-intersection operation"></a>4.7.1 set-intersection operation</h4></li>
<li>Notation:$r \cap s$</li>
<li>Defined as:$r \cap s= \{ t|t\in r and t\in s \}$</li>
<li>r和s有相同的arity</li>
<li>r和s的属性是兼容的，也就是值域是相同的</li>
<li>等目同源-与union操作的限制条件是相同的</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-42.png" alt="alt text"></p>
<h4 id="4-7-2-Natural-Join-Operation"><a href="#4-7-2-Natural-Join-Operation" class="headerlink" title="4.7.2 Natural Join Operation"></a>4.7.2 Natural Join Operation</h4><ul>
<li>Notation:$r \bowtie s$</li>
<li>Example:R=(A,B,C,D),S=(B,D,E)<ul>
<li>natural join 得到的 result schema是(A,B,C,D,E)</li>
<li>$r \bowtie s= \Pi_{r.A,r.B,r.C,r.D,s.E}(\sigma_{r.B=s.B ∧ r.D=s.D}(r \times s))$</li>
</ul>
</li>
</ul>
<p>Let r and s be relations on schemas R and S respectively. Then, $r \bowtie s$<br> is a relation on schema $R \cup S$<br> obtained as follows:</p>
<ul>
<li>Consider each pair of tuples $t_r$ from r and $t_s$ from s</li>
<li>如果$t_r$和$t_s$在$R \cap S$中每一个相同的属性都有相同的值，在结果relation中加上这样的元组<ul>
<li>t有与r中的$t_r$相同的值</li>
<li>t有与s中的$t_s$相同的值<blockquote>
<p>对乘法的扩展，相当于先做笛卡尔积<br>再 select, 最后 project.</p>
<ul>
<li>使用条件：</li>
</ul>
</blockquote>
</li>
<li>r，s必须有共同属性(名和域都对应相同)</li>
<li>连接两个关系中同名属性值相等的元组</li>
<li>结果属性是二者属性集的并集，但<strong>消去重名属性</strong></li>
</ul>
</li>
</ul>
<h4 id="Theta-Join-Operation-Formalization"><a href="#Theta-Join-Operation-Formalization" class="headerlink" title="Theta Join Operation Formalization"></a>Theta Join Operation Formalization</h4><ul>
<li>Notation:$r \bowtie_{\theta} s$<ul>
<li>$\theta$是模式中对于属性的predicate</li>
<li>Theta Join:$r \bowtie_{\theta}(r \times s)$</li>
</ul>
</li>
<li>Theta Join is the extension to the Natural Join</li>
</ul>
<h4 id="4-7-3-Division-Operation"><a href="#4-7-3-Division-Operation" class="headerlink" title="4.7.3 Division Operation"></a>4.7.3 Division Operation</h4><p>题目中要找<code>all</code>就要使用division operation</p>
<ul>
<li>Notation:$r \div s$</li>
<li>认为r和s分别是模式R和S下的关系，其中$R=(A_1,…,A_m,B_1,…,B_n),S=(B_1,…B_n)$<ul>
<li>result relation的模式是$R-S=(A_1,A_2,…,A_n)$</li>
<li>$r \div s = \{t|t \in \Pi_{R-S}(r)∧ \forall u \in s(t \times u \in r)\}$</li>
</ul>
</li>
<li>商来自于$\Pi_{R-S}$，并且其元组t与s所有元组的拼接被r覆盖（是r的一个子集）<script type="math/tex; mode=display">
\begin{align*}
  temp1 & \leftarrow \Pi_{R-S}(r)\\
  temp2 & \leftarrow \Pi_{R-S}((temp1 \times s)- \Pi_{R-S,S}(r))\\
  result & = temp1 - temp2
\end{align*}</script></li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-45.png" alt="alt text"></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-46.png" alt="alt text"></p>
<h4 id="4-7-4-Assignment-Operation"><a href="#4-7-4-Assignment-Operation" class="headerlink" title="4.7.4 Assignment Operation"></a>4.7.4 Assignment Operation</h4><p>The assignment operation &lt;- provides a convenient way to express complex queries.</p>
<ul>
<li>将查询表达式写成一系列包含下列内容的程序<ul>
<li>A series of assignments</li>
<li>Followed by an expression whose value is displayed as a result of the query</li>
</ul>
</li>
<li>assignment的结果是一个临时表<h3 id="4-8-操作符的优先级"><a href="#4-8-操作符的优先级" class="headerlink" title="4.8 操作符的优先级"></a>4.8 操作符的优先级</h3></li>
<li>Project</li>
<li>Select</li>
<li>Cartesian product</li>
<li>Join,division</li>
<li>Intersection</li>
<li>Union,difference<h3 id="4-9-Extended-Relational-Algebra-Operations"><a href="#4-9-Extended-Relational-Algebra-Operations" class="headerlink" title="4.9 Extended Relational-Algebra Operations"></a>4.9 Extended Relational-Algebra Operations</h3></li>
<li>Generalized Projection</li>
<li>Aggregate Functions</li>
<li>Outer Join<h4 id="4-9-1-Aggregate-Functions"><a href="#4-9-1-Aggregate-Functions" class="headerlink" title="4.9.1 Aggregate Functions"></a>4.9.1 Aggregate Functions</h4>Aggregation function（聚合函数）takes a collection of values and returns a single value as a result.</li>
<li>avg: average value</li>
<li>min: minimum value</li>
<li>max: maximum value</li>
<li>sum: sum of values</li>
<li><p>count: number of values</p>
</li>
<li><p>聚合函数会接受一组值，返回单个值</p>
</li>
</ul>
<p>Aggregate operation in relational algebra: $G_1,G_2,\ldots,G_n \mathcal{G}_{F_1(A_1),\ldots F_n(A_n)}(E)$</p>
<ul>
<li>E是任意一个关系代数表达式</li>
<li>$G_1,…$是分组的属性清单，对同一组是具有相同value的tuple，对每一组进行对应的聚合函数操作</li>
<li>$F_i$是聚合函数</li>
<li>$A_i$是属性的名称</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-43.png" alt="alt text"></p>
<ul>
<li><p>聚合的结果是没有名称的</p>
<ul>
<li>可以使用重命名操作进行命名</li>
<li>为了方便我们提供了<code>as</code>语句作为聚合操作的一部分从而进行重命名<script type="math/tex; mode=display">
branch-name \mathcal{G}_{sum(balance) as sum-balance}(account)</script><h4 id="4-9-2-Outer-Join"><a href="#4-9-2-Outer-Join" class="headerlink" title="4.9.2 Outer Join"></a>4.9.2 Outer Join</h4>Natural Join操作会造成一部分数据的丢失，这时我们对natural join进行扩展操作可以有效避免信息的丢失</li>
</ul>
</li>
<li><p>计算出自然连接，然后加上某一个关系中没有在另一个关系中匹配的元组加入自然连接的结果</p>
<ul>
<li>一些属性存在空值情况，我们使用<code>null</code>作为value的值</li>
</ul>
</li>
<li>$r\rtimes s$ 保留r关系中的元组</li>
<li>$r\ltimes s$ 保留s关系中的元组</li>
<li>$r⟗s$ </li>
</ul>
<h4 id="4-9-3-Null-values"><a href="#4-9-3-Null-values" class="headerlink" title="4.9.3 Null values"></a>4.9.3 Null values</h4><ul>
<li>null值可以是一个未知的值或者是不存在的值</li>
<li>一切包含null的算数表达式的结果一定是null</li>
<li>聚合函数计算时忽略null值(除了count以外，count时null被视为一个正常值)</li>
<li>对于去重删除和分组操作时，null被视作与正常值一样的值，两个null被看做相等的值</li>
<li>比较时引入除了<code>true</code>和<code>false</code>以外的第三个值<code>unknown</code></li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-44.png" alt="alt text"></p>
<ul>
<li><p>P is unknown可以作为谓词，对应值上是unknown时返回true</p>
</li>
<li><p>完整性约束</p>
<ul>
<li>实体完整性（Entity Integrity）：数据库中的每个表都必须有一个主键且主键不能为NULL</li>
<li>参照完整性(Referential Integrity)：外键的值必须是空值或者被引用表中主键的有效值</li>
<li>用户定义完整性（User defined Integrity）：根据具体业务需求定义的约束条件,由应用的环境决定<br>、<h1 id="Chapter-3-Introduction-to-SQL"><a href="#Chapter-3-Introduction-to-SQL" class="headerlink" title="Chapter 3 Introduction to SQL"></a>Chapter 3 Introduction to SQL</h1><h2 id="1-Data-Definition"><a href="#1-Data-Definition" class="headerlink" title="1 Data Definition"></a>1 Data Definition</h2><h3 id="1-1-Domain-Types-in-SQL"><a href="#1-1-Domain-Types-in-SQL" class="headerlink" title="1.1 Domain Types in SQL"></a>1.1 Domain Types in SQL</h3></li>
</ul>
</li>
<li><code>char(n)</code>.Fixed length character string, with user-specified length n.</li>
</ul>
<p>定长字符串，C语言里字符串结尾有<code>\0</code>，但是数据库中没有，长度由定义而得</p>
<ul>
<li><code>varchar(n)</code>.Variable length character string, with user-specified <code>maximum</code> length n.</li>
</ul>
<p>不定长字符串(可变长字符串)。不同的数据类型比较可能有问题(比如定长和不定长的字符串)</p>
<ul>
<li><p><code>int</code>.Integer (a finite subset of the integers that is machine-dependent).</p>
</li>
<li><p><code>smallint</code>Small integer (a machine-dependent subset of the integer domain type).</p>
</li>
</ul>
<p>往往是int长度的一半</p>
<ul>
<li><code>numeric(p,d)</code>. Fixed point number, with user-specified precision of p digits, with d digits to the right of decimal point.<br>p 表示有效数字位数, d 表示小数点后多少位。 e.g. number(3,1) allows 44.5 to be store exactly, but neither 444.5 or 0.32</li>
<li><code>real</code>, double precision. Floating point and double-precision floating point numbers, with machine-dependent precision.</li>
<li><code>float(n)</code>. Floating point number, with user-specified precision of at least n digits.</li>
</ul>
<h3 id="1-2-Built-in-Data-Types-in-SQL"><a href="#1-2-Built-in-Data-Types-in-SQL" class="headerlink" title="1.2 Built-in Data Types in SQL"></a>1.2 Built-in Data Types in SQL</h3><ul>
<li>date: Dates, containing a (4 digit) year, month and date</li>
</ul>
<p>e.g. date ‘2005-7-27’</p>
<ul>
<li>time: Time of day, in hours, minutes and seconds. e.g. time ‘09:00:30’ time ‘09:00:30.75’</li>
<li>timestamp: date plus time of day e.g. timestamp ‘2005-7-27 09:00:30.75’</li>
<li>interval: period of time e.g. interval ‘1’ day<ul>
<li>Subtracting a date/time/timestamp value from another gives an interval value.</li>
<li>Interval values can be added to date/time/timestamp values</li>
<li>built-in date, time functions: current_date(), current_time(), year(x), month(x), day(x), hour(x), minute(x), second(x)</li>
</ul>
</li>
</ul>
<h3 id="1-3-Create-Table-Consrtuct"><a href="#1-3-Create-Table-Consrtuct" class="headerlink" title="1.3 Create Table Consrtuct"></a>1.3 Create Table Consrtuct</h3><p>An SQL relation is defined using the create table command:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> r (A1 D1, A2 D2, ..., An Dn,           (integrity<span class="operator">-</span>constraint1),            </span><br><span class="line">..,         </span><br><span class="line">(integrity<span class="operator">-</span>constraintk))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>r is the name of the relation</li>
<li>each $A_i$ is an attribute name in the schema of relation r</li>
<li>$D_i$ is the data type of values in the domain of attribute $D_i$</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> instructor(</span><br><span class="line">    ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>not null</code></li>
<li>primary key $(A_1,…,A_n)$</li>
</ul>
<p>不能为空：表内不能有相同的</p>
<ul>
<li>foreign key $(A_1,…,A_n)$ references r</li>
</ul>
<p>隐含：引用对应表的主键，外键是空值就是没有连接到任何值</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-47.png" alt="alt text"></p>
<p>可以给一个缺省值，比如<code>default 0</code></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-48.png" alt="alt text"></p>
<p><code>sec_id</code> can not be dropped from primary key above, to ensure a student cannot be registered for two sections of the same course in the same semester</p>
<p>如果引用的表中有条目被删除，可能会破坏完整性约束条件。有下面的方法：</p>
<ul>
<li><code>restrict</code>:如果有条目是被引用的，那么不允许被删除</li>
<li><code>cascade</code>:引用的条目被删了之后，引用者也一并被删除</li>
<li><code>set null</code>:引用者的指针设为null</li>
<li><code>set default</code>:引用者的指针设为默认值</li>
</ul>
<p>如果引用的表中有更新，也有类似上面的四种方法</p>
<h3 id="1-4-Drop-and-Alter-Table-Constructs"><a href="#1-4-Drop-and-Alter-Table-Constructs" class="headerlink" title="1.4 Drop and Alter Table Constructs"></a>1.4 Drop and Alter Table Constructs</h3><ul>
<li>drop:将表和内容同时删除</li>
<li>delete：删除表中的所有内容，但是始终保留表结构</li>
<li>alter table：可以动态修改表的定义<ul>
<li><code>alter table r add A D</code><ul>
<li>A是被添加到表中的属性名</li>
<li>D是A的domain</li>
<li>所有关系中的元组的新属性都被置为空值</li>
<li>还可以增加外键的约束条件，也可以删掉<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter table</span> Employees <span class="keyword">add</span> Email <span class="type">varchar</span>(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>alter table r drop A</code><ul>
<li>A是r表中的一个属性</li>
<li>drop操作在很多数据库系统中是被禁用的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Basic-Query-Structure"><a href="#2-Basic-Query-Structure" class="headerlink" title="2 Basic Query Structure"></a>2 Basic Query Structure</h2><p>typical SQL query structure:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> R1, ..., Rm</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL查询的结果是一个relation</li>
<li>SQL查询的结果是多重集，有重复的记录是允许的<h3 id="2-1-The-select-Clause"><a href="#2-1-The-select-Clause" class="headerlink" title="2.1 The select Clause"></a>2.1 The select Clause</h3></li>
</ul>
<p>The select clause list the attributes desired in the result of a query.</p>
<ul>
<li>为了强制消除掉重复元素，在select的后面加上关键词<code>distinct</code></li>
</ul>
<blockquote>
<p>eg <code>select distinct dept_name from instructor</code>可以加all表示不去重，加不加无所谓</p>
</blockquote>
<ul>
<li><p>An asterisk in the select clause denotes “all attributes”<br>e.g. select * from instructor</p>
</li>
<li><p>The select clause can contain arithmetic expressions involving the operation,$+, -, \times<br>, and \div$, and operating on constants or attributes of tuples.<br>可以有加减乘除运算 e.g. select ID, name, salary/12 from instructor</p>
<blockquote>
<p>泛化投影,即可以在投影属性中引入运算</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-The-where-clause"><a href="#2-2-The-where-clause" class="headerlink" title="2.2 The where clause"></a>2.2 The where clause</h3><p>The where clause specifies conditions that the result must satisfy.<br>Corresponds to the selection predicate of the relational algebra.</p>
<ul>
<li>SQL includes a between comparison operator e.g. select name from instructor where salary between 90000 and 100000</li>
<li>tuple comparison 元组相等等价于各个元素相等</li>
</ul>
<h3 id="2-3-The-from-clause"><a href="#2-3-The-from-clause" class="headerlink" title="2.3 The from clause"></a>2.3 The from clause</h3><p>The from clause lists the relations involved in the query.</p>
<p>Corresponds to the Cartesian product operation of the relational algebra.</p>
<h3 id="2-4-Natural-Join"><a href="#2-4-Natural-Join" class="headerlink" title="2.4 Natural Join"></a>2.4 Natural Join</h3><ul>
<li><p><code>select name, course_id from instructor, teaches where instructor.ID = teaches.ID;</code><br><code>select name, course_id from instructor natural join teaches;</code><br>上面两条语句是等价的。</p>
</li>
<li><p>注意：自然连接的问题是如果两个表有相同的属性名但是有不同的含义不能使用自然连接，否则会造成内容的缺省</p>
</li>
</ul>
<blockquote>
<p>Example:course(course_id,title, dept_name,credits）, teaches(ID, course_id,sec_id,semester, year), instructor(ID, name, dept_name,salary） 这里的 department 含义各有不同，不能直接自然连接。<br>教师所在的学院不一定与课程所在的学院相同<br>可以人为规定连接的属性，对应于$\sigma_{\theta}$<br>Find students who takes courses across his/her department.</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> student.id</span><br><span class="line">    <span class="keyword">from</span> (student <span class="keyword">natural</span> <span class="keyword">join</span> takes) </span><br><span class="line">           <span class="keyword">join</span> course <span class="keyword">using</span> (course_id)</span><br><span class="line">    <span class="keyword">where</span> student.dept_name <span class="operator">=</span> course.dept_name</span><br></pre></td></tr></table></figure>
<h3 id="2-5-The-Rename-Operation"><a href="#2-5-The-Rename-Operation" class="headerlink" title="2.5 The Rename Operation"></a>2.5 The Rename Operation</h3><p>The SQL allows renaming relations and attributes using the <code>as</code> clause.</p>
<p><code>old_name as new_name</code></p>
<p><strong>eg</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary<span class="operator">&gt;</span>S.salary <span class="keyword">and</span> S.dept_name<span class="operator">=</span><span class="string">&#x27;Comp.Sci&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Keyword as is optional and may be omitted</p>
<blockquote>
<p>eg.<code>instructor as T</code>与<code>instructor T</code>是完全等价的</p>
</blockquote>
</li>
<li><p>使用aggregate function和表的自身比较时往往需要使用重命名操作</p>
<h3 id="2-6-String-Operations"><a href="#2-6-String-Operations" class="headerlink" title="2.6 String Operations"></a>2.6 String Operations</h3></li>
</ul>
<p>SQL includes a string-matching operator for comparisons on character strings. The operator <code>like</code> uses patterns that are described using two special characters.</p>
<ul>
<li><p>注意单引号表示字符串</p>
</li>
<li><p>percent(%):The % character matches any substring.</p>
<blockquote>
<p>eg. <code>select name from instructor where name like &#39;%dar%&#39;</code>找名字里含有<code>dar</code>的字符串</p>
</blockquote>
</li>
<li><p>underscore(_):The _ character matches any character.</p>
<blockquote>
<p>eg. <code>select name from instructor where name like &#39;_ar%&#39;</code>找名字里第二个字母是<code>ar</code>的字符串</p>
</blockquote>
</li>
<li><p>‘—-‘matches any string of exactly three characters</p>
</li>
<li><p>‘—-%’matches any string of at least three characters.</p>
</li>
<li><p>Match the string </p>
<ul>
<li>匹配字符串<code>100%</code>但是<code>%</code>符号被我们作为了通配符，这里我们需要用到转义符<code>\</code>.<code>\%</code>即将<code>%</code>作为正常字符匹配</li>
<li><code>\</code>也可以是一个基本符号，我们需要在后面写出<code>escape</code>表示其在这里作为转义符。类似地我们还可以将转义字符定义为<code>#</code></li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">like</span> `<span class="number">100</span> \<span class="operator">%</span><span class="string">&#x27;  escape  &#x27;</span>\<span class="string">&#x27; </span></span><br><span class="line"><span class="string">like `100 \%&#x27;</span>  </span><br><span class="line"><span class="keyword">like</span> `<span class="number">100</span>  #<span class="operator">%</span><span class="string">&#x27;  escape  `#&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>SQL supports a variety of string operations such as</p>
<ul>
<li><p>concatenation(using ||)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;客户名=&#x27;</span><span class="operator">||</span> customer.name</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原本name这个属性对应的值显示为客户名=name</p>
</blockquote>
</li>
<li><p>converting from upper to lower case(and vie versa)</p>
</li>
<li><p>finding string length,extracting substrings</p>
</li>
</ul>
<h3 id="2-7-Ordering-the-Display-of-Tuples"><a href="#2-7-Ordering-the-Display-of-Tuples" class="headerlink" title="2.7 Ordering the Display of Tuples"></a>2.7 Ordering the Display of Tuples</h3><p>关系是无序的，但是我们可以规定显示出来的顺序</p>
<ul>
<li>对于某一个属性，我们定义降序为<code>desc</code>，升序为<code>asc</code><blockquote>
<p>eg.<code>order by name desc</code>可以排序的类型，如字符串、数字</p>
</blockquote>
</li>
<li>可以对多个属性进行排序<blockquote>
<p>eg. <code>order by dept_name,name</code>先按dept_name排序，如果该属性相同再按照name排序</p>
</blockquote>
</li>
</ul>
<h3 id="2-8-The-limit-Clause"><a href="#2-8-The-limit-Clause" class="headerlink" title="2.8 The limit Clause"></a>2.8 The <code>limit</code> Clause</h3><p>The <code>limit</code> clause can be used to constrain the number of rowa returned by the select statement.</p>
<p>limit clause takes one or two numeric arguments,which must both be nonnegative integer constants:</p>
<blockquote>
<p>eg. <code>select name from instructor limit 2</code>限制最多返回两行</p>
</blockquote>
<h3 id="2-9-Set-Operations"><a href="#2-9-Set-Operations" class="headerlink" title="2.9 Set Operations"></a>2.9 Set Operations</h3><ul>
<li><p><code>union</code>,<code>intersect</code>,<code>except</code>是严格的集合操作，会对结果去重</p>
</li>
<li><p><code>union all</code>,<code>intersect all</code>,<code>except all</code>保持多重集可以存在重复的记录</p>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-49.png" alt="alt text"></p>
<h3 id="2-10-Null-Values"><a href="#2-10-Null-Values" class="headerlink" title="2.10 Null Values"></a>2.10 Null Values</h3><p>null提供的是一个存在但是未知的值或不存在的值</p>
<ul>
<li><p>The result of any arithmetic expression involving null is null.<br>e.g. 5 + null returns null</p>
</li>
<li><p>The predicate is null can be used to check for null values.<br>e.g. Find all instructors whose salary is null.<br>select name from instructor where salary is null</p>
</li>
<li><p>Comparisons with null values return the special truth value: unknown.</p>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-50.png" alt="alt text"></p>
<ul>
<li>如果where子句中结果为unknown被当做false处理。理解UNKNOWN被当作FALSE处理有助于编写更精确的查询，避免意外地排除或包含某些数据。</li>
</ul>
<h3 id="2-11-Aggregate-Functions"><a href="#2-11-Aggregate-Functions" class="headerlink" title="2.11 Aggregate Functions"></a>2.11 Aggregate Functions</h3><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-51.png" alt="alt text"></p>
<p>注意在<code>select</code>里出现的属性，除了统计函数以外，一定要是分组属性里面出现过的</p>
<h4 id="2-11-1-Having-Clause"><a href="#2-11-1-Having-Clause" class="headerlink" title="2.11.1 Having Clause"></a>2.11.1 Having Clause</h4><p>对分组后的组进行筛选</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">count</span> (<span class="operator">*</span>) <span class="keyword">as</span> cnt</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span>  salary <span class="operator">&gt;=</span><span class="number">100000</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span>  <span class="built_in">count</span> (<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> cnt;</span><br></pre></td></tr></table></figure>
<p>having clause中的谓词在分组完成之后应用，而where子句中的谓词在组形成前应用</p>
<ul>
<li>having子句是对aggregate function的约束</li>
<li>如果group语句中存在多个属性，则需要将多个属性按照出现的顺序形成一个组合值，然后进行分组。只有当所有属性的值完全相同时才可以作为同一组</li>
<li>执行顺序为:from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order by <h4 id="2-11-2-Null-Values-and-Aggregates"><a href="#2-11-2-Null-Values-and-Aggregates" class="headerlink" title="2.11.2 Null Values and Aggregates"></a>2.11.2 Null Values and Aggregates</h4></li>
</ul>
<p><code>select sum(salary) from instructor</code></p>
<ul>
<li>上述语句中计算sum时会忽略掉null值</li>
<li>如果没有non-null值那么结果为null，只有count会返回0</li>
<li>所有aggregate操作除了<code>count(*)</code>都会忽略元组中的null值</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-52.png" alt="alt text"> </p>
<p>第二个表示重名率小于千分之一</p>
<h3 id="2-12-Nested-Subqueries"><a href="#2-12-Nested-Subqueries" class="headerlink" title="2.12 Nested Subqueries"></a>2.12 Nested Subqueries</h3><p>A subquery is a select-from-where expression that is nested within another query.</p>
<h4 id="2-12-1-Set-Membership"><a href="#2-12-1-Set-Membership" class="headerlink" title="2.12.1 Set Membership"></a>2.12.1 Set Membership</h4><p><code>in</code>,<code>not in</code></p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-53.png" alt="alt text"></p>
<p>除了单个元素外，元组也可以使用 in, not in</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> (customer_id, product_id) <span class="keyword">IN</span> (<span class="keyword">select</span> customer_id,product_id <span class="keyword">from</span> info <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-12-2-Set-Comparison"><a href="#2-12-2-Set-Comparison" class="headerlink" title="2.12.2 Set Comparison"></a>2.12.2 Set Comparison</h4><ul>
<li><code>some</code> 某些成员</li>
<li><code>all</code> 所有成员</li>
</ul>
<blockquote>
<p>eg 工资大于生物系中的某些老师的老师</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (<span class="keyword">select</span> salary</span><br><span class="line">                                    <span class="keyword">from</span> instructor</span><br><span class="line">                                    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="2-12-3-Scalar-Subquery"><a href="#2-12-3-Scalar-Subquery" class="headerlink" title="2.12.3 Scalar Subquery"></a>2.12.3 Scalar Subquery</h3><p><strong>Scalar(标量) Subquery</strong> is one which is used where a single value is expected.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span>  salary <span class="operator">*</span> <span class="number">10</span> <span class="operator">&gt;</span> </span><br><span class="line">    (<span class="keyword">select</span> budget  <span class="keyword">from</span> department </span><br><span class="line">    <span class="keyword">where</span> department.dept_name <span class="operator">=</span> instructor.dept_name)</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 dept_name 是这个表的主键，只返回一个元组，这种情况下是可以不用 some, all 的。</li>
</ul>
<h4 id="2-12-4-Test-for-Empty-Relations"><a href="#2-12-4-Test-for-Empty-Relations" class="headerlink" title="2.12.4 Test for Empty Relations"></a>2.12.4 Test for Empty Relations</h4><p>The exists construct returns the value true if the argument subquery is nonempty.</p>
<ul>
<li><code>exists r</code>&lt;=&gt; $r \neq \emptyset$</li>
<li><code>not exists r</code>&lt;=&gt; $r = \emptyset$</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span> <span class="number">2009</span> <span class="keyword">and</span>                </span><br><span class="line">    <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span>                            </span><br><span class="line">    <span class="keyword">from</span> section <span class="keyword">as</span> T                      </span><br><span class="line">    <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span><span class="operator">=</span> <span class="number">2010</span> <span class="keyword">and</span> S.course_id<span class="operator">=</span> T.course_id);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Find all students who have taken all courses offered in the Biology department.<br>SQL 语句往往需要逆向考虑，即找到这样的学生，不存在他没选过的生物系的课。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( (<span class="keyword">select</span> course_id</span><br><span class="line">                        <span class="keyword">from</span> course</span><br><span class="line">                        <span class="keyword">where</span> dept_name <span class="operator">=</span> ’Biology’)</span><br><span class="line">                <span class="keyword">except</span></span><br><span class="line">                    (<span class="keyword">select</span> T.course_id</span><br><span class="line">                        <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">                        <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID));</span><br></pre></td></tr></table></figure>
<h4 id="2-12-5-Test-for-Absence-of-Duplicate-Tuples"><a href="#2-12-5-Test-for-Absence-of-Duplicate-Tuples" class="headerlink" title="2.12.5 Test for Absence of Duplicate Tuples"></a>2.12.5 Test for Absence of Duplicate Tuples</h4><p>The unique construct tests whether a subquery has any duplicate tuples in its result.<br>验证一个集合是否是集合，而非多重集</p>
<ul>
<li>Evaluates to “true” on an empty set.可以将 unique 理解为 at most once.</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-54.png" alt="alt text"></p>
<ul>
<li>not unique一般题目中会描述为<code>at least two</code></li>
</ul>
<h3 id="2-13-With-Clause"><a href="#2-13-With-Clause" class="headerlink" title="2.13 With Clause"></a>2.13 With Clause</h3><p>The <code>with</code> clause提供了一个定义relation definition只对with子句发生的查询开放的临时表</p>
<ul>
<li><p>只是一个临时表，随着查询的结束自动消除</p>
<blockquote>
<p>Find all departments with the maximum budget</p>
</blockquote>
</li>
<li><p>一般可以在选择一个具有特定性质的值的时候使用</p>
</li>
</ul>
<h1 id="Chapter-4-Intermediate-SQL"><a href="#Chapter-4-Intermediate-SQL" class="headerlink" title="Chapter 4 Intermediate SQL"></a>Chapter 4 Intermediate SQL</h1><h2 id="4-1-Joined-Relations"><a href="#4-1-Joined-Relations" class="headerlink" title="4.1 Joined Relations"></a>4.1 Joined Relations</h2><ul>
<li>连接操作输入两个关系，并返回另一个关系</li>
<li>连接操作通常用作from子句中的子查询表达式</li>
<li>连接条件(Join Condition):定义两个关系中的哪些元组匹配，以及链接结果中存在哪些属性</li>
<li>连接类型(Join Type):定义如何处理另一个关系中的任何元组不匹配的元组(基于连接条件)</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-62.png" alt="alt text"></p>
<h3 id="4-1-1-Natural-Join"><a href="#4-1-1-Natural-Join" class="headerlink" title="4.1.1 Natural Join"></a>4.1.1 Natural Join</h3><ul>
<li>from子句获得的是求解好后的新关系，因此有些实现不支持再用原来的关系名访问原属性</li>
<li>可以用多个<code>natural join</code>来连接多个关系</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> r1 <span class="keyword">natural</span> <span class="keyword">join</span> r2 <span class="keyword">natural</span> <span class="keyword">join</span> ... <span class="keyword">natural</span> <span class="keyword">join</span> rm</span><br><span class="line"><span class="keyword">where</span> P;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外，使用<code>join...using</code>子句可以从两个关系的同名属性中选择指定的属性作为连接的依据，更加灵活<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, title</span><br><span class="line"><span class="keyword">from</span> (student <span class="keyword">natural</span> <span class="keyword">join</span> takes) <span class="keyword">join</span> course <span class="keyword">using</span> (course_id);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-1-2-Join-Conditions"><a href="#4-1-2-Join-Conditions" class="headerlink" title="4.1.2 Join Conditions"></a>4.1.2 Join Conditions</h3><ul>
<li>除了<code>joing using</code>以外，还有更加通用的<code>join...on</code>运算。只要<code>where</code>支持的谓词，<code>on</code>条件均支持，因此能够表达更为丰富的连接条件<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">join</span> takes <span class="keyword">on</span> student.ID <span class="operator">=</span> takes.ID;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-Outer-Join"><a href="#4-1-3-Outer-Join" class="headerlink" title="4.1.3 Outer Join"></a>4.1.3 Outer Join</h3><blockquote>
<p>自然连接仅仅保留那些同名属性值相等的元组，那些不相等的元组都会被抛弃，但是有时我们需要保留这些不相等的元组。这个时候，就需要用到外连接(Outer Join)</p>
</blockquote>
</li>
</ul>
<p>外连接的作用类似于自然连接，区别在于<strong>外连接会保留那些两个关系中同名属性值不相等的属性，设为null</strong>。SQL提供了三种不同形式的外连接：</p>
<ul>
<li>左外连接(Left Outer Join):使用 <code>left outer join</code> 运算符，仅保留第一个关系的所有元组</li>
<li>右外连接(Right Outer Join):使用 <code>right outer join</code> 运算符，仅保留第二个关系的所有元组</li>
<li>全外连接(Full Outer Join):使用 <code>full outer join</code> 运算符，保留两个关系的所有元组<ul>
<li>可以将其结果看作左外连接与右外连接结果的并集</li>
<li>有些数据库系统不支持全外连接</li>
</ul>
</li>
</ul>
<p>对应地，前面介绍的哪些没有保留不匹配元组的连接方式称为<strong>内连接(Inner Join)</strong></p>
<ul>
<li>在 SQL 语法中可以显式指出 inner join，但可以省略 inner，因为 join 子句默认是内连接的</li>
</ul>
<p>在外连接中，<code>on</code>和<code>where</code>子句的区别在于:</p>
<ul>
<li><code>on</code>子句会保留那些不符合条件的元组</li>
<li><code>where</code>子句会丢掉那些不符合条件的元组</li>
</ul>
<p>eg.现在有两张表<code>student</code>和<code>score</code></p>
<ul>
<li>student表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Alice</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Scores表</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>85</td>
</tr>
<tr>
<td>4</td>
<td>95</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Students.StudentID, Students.Name, Scores.Score</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Scores</span><br><span class="line"><span class="keyword">ON</span> Students.StudentID <span class="operator">=</span> Scores.StudentID;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果为</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>StudentID</th>
<th>Name</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Alice</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>85</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
<td>NULL</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>结果表明<code>on</code>只是按照条件将两张表进行连接但不会去除未能连接的表</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-63.png" alt="alt text"></p>
<p>可以发现课程CS-315对应的prereq不存在，以及CS-437的课程信息不存在</p>
<ul>
<li><p>如果我们使用<code>course natural left outer join prereq</code>,这将<code>prereq</code>的结果保存下来，没有信息的课程CS-315结果设为NULL<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-64.png" alt="alt text"></p>
</li>
<li><p>如果我们使用 <code>course natural right outer join prereq</code>，这将 course 的结果保存下来，没有信息的课程 CS-437 结果设为 NULL：<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-65.png" alt="alt text"></p>
</li>
<li><p>如果我们使用<code>course natural full outer join prereq</code>,这将 course 和 prereq 的结果保存下来，没有信息的课程 CS-315 和 CS-437 结果设为 NULL：<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-67.png" alt="alt text"></p>
</li>
</ul>
<h2 id="4-2-SQL-Data-Types-and-Schemas"><a href="#4-2-SQL-Data-Types-and-Schemas" class="headerlink" title="4.2 SQL Data Types and Schemas"></a>4.2 SQL Data Types and Schemas</h2><h3 id="4-2-1-User-Defined-Types"><a href="#4-2-1-User-Defined-Types" class="headerlink" title="4.2.1 User-Defined Types"></a>4.2.1 User-Defined Types</h3><ul>
<li>SQL支持两种形式的用户定义数据类型(User-Defined Data Types):<ul>
<li>区分类型 （Distinct Types）：基于现有类型创建的新类型<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE MONEY <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">CREATE</span> TYPE PERCENTAGE <span class="keyword">AS</span> <span class="type">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li>结构化数据类型（Structured Data Types）：复杂的数据类型，包括嵌套记录结构、数组、多重集<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE Address <span class="keyword">AS</span> (</span><br><span class="line">    street <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    city <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    zipcode <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> Customers (</span><br><span class="line">    id <span class="type">INTEGER</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    address Address</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>不同的属性可能有相同的类型，但有时我们希望将这些属性的类型区分开来，我们使用 create type 语句来定义用户定义数据类型中的区分类型<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> type Dollars <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>, <span class="number">2</span>) <span class="keyword">final</span>;</span><br><span class="line"><span class="keyword">create</span> type Pounds <span class="keyword">as</span> <span class="type">numeric</span>(<span class="number">12</span>, <span class="number">2</span>) <span class="keyword">final</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>定义了<code>dollars</code>和<code>pounds</code>类型后，就可以把它们作为元类使用：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> department  </span><br><span class="line">(dept_name <span class="type">varchar</span> (<span class="number">20</span>),  </span><br><span class="line">building <span class="type">varchar</span> (<span class="number">15</span>),  </span><br><span class="line">budget Dollars);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>用户定义的这两个类型 Dollars 和 Pounds，虽然底层类型相同，但会被视为不同的类型。因此这两种类型不能直接进行运算，甚至不能与 numeric 类型运算，这时就需要用 cast 子句进行强制类型转换<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误：不能直接对 Dollars 和 Pounds 进行运算</span></span><br><span class="line"><span class="keyword">SELECT</span> US_Sales.amount <span class="operator">+</span> UK_Sales.amount</span><br><span class="line"><span class="keyword">FROM</span> US_Sales, UK_Sales;</span><br><span class="line"><span class="comment">-- 将 Pounds 转换为 Dollars 进行运算</span></span><br><span class="line"><span class="keyword">SELECT</span> US_Sales.amount <span class="operator">+</span> <span class="built_in">CAST</span>(UK_Sales.amount <span class="keyword">AS</span> Dollars)</span><br><span class="line"><span class="keyword">FROM</span> US_Sales, UK_Sales;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-Domains"><a href="#4-2-2-Domains" class="headerlink" title="4.2.2 Domains"></a>4.2.2 Domains</h3></li>
<li>SQL的<code>domain</code>关键字提供了与<code>type</code>类似的功能，用于为底层类型添加完整性约束<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> domain person_name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not null</span></span><br></pre></td></tr></table></figure></li>
<li>我们还可以使用<code>check</code>子句来添加额外的约束条件<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> domain degree_level <span class="type">varchar</span>(<span class="number">10</span>)  </span><br><span class="line"><span class="comment">--- degree_level_test是约束条件的名称</span></span><br><span class="line"><span class="keyword">constraint</span> degree_level_test  </span><br><span class="line"><span class="keyword">check</span> (<span class="keyword">value</span> <span class="keyword">in</span> (’Bachelors’, ’Masters’, ’Doctorate’));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>type</code>和<code>domain</code>之间的区别</strong></p>
<ul>
<li>域可以有约束，并且可以使用域类型的默认值</li>
<li>域并没有强制的类型要求。因此，只要底层类型是可兼容的，在某个域的值就可以被赋予另一个域类型的值<ul>
<li>例如，如果两个域都是基于字符串类型定义的，即使它们的约束不同，也可以相互赋值。</li>
</ul>
</li>
</ul>
<h3 id="4-2-3-Large-Object-Types"><a href="#4-2-3-Large-Object-Types" class="headerlink" title="4.2.3 Large-Object Types"></a>4.2.3 Large-Object Types</h3><blockquote>
<p>很多数据库系统需要存储包含大数据项的属性，比如照片、高分辨率的图像或视频等。因此 SQL 为字符数据（CLOB）和二进制数据（BLOB）提供了大对象数据类型（Large-Object Data Types）</p>
<ul>
<li>BLOB：二进制大对象（Binary Large Object）——对象是未解释的二进制数据的大型集合（其解释由数据库系统之外的应用程序定义）<ul>
<li>在 MySQL 中，BLOB 数据类型有：<ul>
<li>TinyBlob：0～255 字节</li>
<li>Blob：0～64K 字节</li>
<li>MediumBlob：0～16M 字节</li>
<li>LargeBlob：0～4G 字节</li>
</ul>
</li>
</ul>
</li>
<li>CLOB：字符大对象（Character Large Object）——对象是大型字符数据的集合</li>
<li>当查询返回大型对象时，将返回指针，而不是大型对象本身。</li>
</ul>
</blockquote>
<h2 id="4-3-Integrity-Constraints"><a href="#4-3-Integrity-Constraints" class="headerlink" title="4.3 Integrity Constraints"></a>4.3 Integrity Constraints</h2><ul>
<li>完整性约束通过确保对数据库的授权更改不会导致数据一致性的丢失，来访时数据库的以外损坏。对于一个关系来说，有以下几种<ul>
<li><code>not null</code>:定义键值不允许为空</li>
<li><code>primary key</code></li>
<li><code>unique</code><ul>
<li><code>unique(A1, A2, ..., Am)</code> 指出属性 A1、A2、…Am 形成一个超级键（不一定是一个候选键）</li>
<li><strong>候选键允许为null</strong></li>
</ul>
</li>
<li><code>check(P)</code>其中P是一个谓词<ul>
<li>也可以有复杂查询，但许多数据库不支持</li>
<li>eg. e.g. <code>check ((course_id, sec_id, semester, year) in (select course_id, sec_id, semester, year from teaches))</code></li>
</ul>
</li>
<li>foreign key</li>
</ul>
</li>
</ul>
<p>确保每个课程的学期为春夏秋冬其中之一<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> section (</span><br><span class="line">    course_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">    sec_id <span class="type">varchar</span> (<span class="number">8</span>),</span><br><span class="line">    semester <span class="type">varchar</span> (<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">numeric</span> (<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">    building <span class="type">varchar</span> (<span class="number">15</span>),</span><br><span class="line">    room_number <span class="type">varchar</span> (<span class="number">7</span>),</span><br><span class="line">    <span class="type">time</span> slot id <span class="type">varchar</span> (<span class="number">4</span>),</span><br><span class="line">    <span class="keyword">primary key</span> (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">check</span> (semester <span class="keyword">in</span> (’Fall’, ’Winter’, ’Spring’, ’Summer’))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-1-Referential-Integrity"><a href="#4-3-1-Referential-Integrity" class="headerlink" title="4.3.1 Referential Integrity"></a>4.3.1 Referential Integrity</h3><ul>
<li>参照完整性(Referential Integrity)确保在给定属性集的一个关系中出现的值，也出现在另一个关系中的特定属性集中<ul>
<li>例如，如果 “Biology” 是出现在关系 instructor 的某个元组中的部门名称，则 “Biology” 的关系 department 中存在一个元组</li>
</ul>
</li>
<li>在SQL中，参照完整性约束由<strong>外键</strong>实现，语法为<code>FOREIGN KEY (dept_name) REFERENCES department</code><ul>
<li>设 A 为一组属性。 设 R 和 S 是包含属性 A 的两个关系，其中 A 是 S 的主键。如果 A 的任何值出现在 R 中，这些值也出现在 S 中，则称 A 是 R 的外键</li>
</ul>
</li>
<li>执行违反参照完整性约束的语句时会被拒绝。然而，对于在被参照关系上的更新和删除行为，如果违反约束，系统必须采取行动来改变参照关系的元组，以恢复约束。对于以下语句:<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create table</span> course (</span><br><span class="line">    <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> cascade</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以删除操作为例，如果要删除 department 里的元组，那么就会违背参照完整性约束，不过系统不会拒绝这个操作，而是通过级联（Cascade）删除的方式删除在 course 中参照在 department 中被删除元组的元组。更新操作与之同理 - 除了 cascade 关键字外，还可以设置 set null 或 set default，当违反约束时会触发这些操作</p>
<h1 id="Chapter-5-Advanced-SQL"><a href="#Chapter-5-Advanced-SQL" class="headerlink" title="Chapter 5 Advanced SQL"></a>Chapter 5 Advanced SQL</h1><h2 id="5-1-Accessing-SQL-from-Programming-Languages"><a href="#5-1-Accessing-SQL-from-Programming-Languages" class="headerlink" title="5.1 Accessing SQL from Programming Languages"></a>5.1 Accessing SQL from Programming Languages</h2><p>数据库程序员必须能够掌握通用编程语言，至少有两个原因</p>
<ul>
<li>并非所有查询都可以用SQL表示，因为SQL不能提供通用语言的全部表达能力</li>
<li>非声明性操作(比如打印报告、与用户交互或将查询结果发送到图形用户界面)不能在SQL中完成</li>
</ul>
<p>有两种方法可以从通用编程语言访问数据库：</p>
<ul>
<li>API(应用程序接口)：通用程序可以使用函数集合连接到数据库服务器并与之通信，程序可以在运行时(RunTime)用字符串构造SQL查询，提交查询，并且将检索的结果放到程序变量中(一次仅能存储一个元组)，动态SQL有以下标准<ul>
<li>JDBC:JAVA用于连接数据库的API</li>
<li>ODBC:原来为C写的用于连接数据库的API，现在也适用于C++、C#、Ruby、Go等</li>
</ul>
</li>
<li>嵌入式SQL(Embedded SQL)：提供程序与数据库服务器交互的方法<ul>
<li>SQL语句在编译时转换为函数调用</li>
<li>在运行时，这些函数调用使用提供动态SQL工具的API连接到数据库</li>
</ul>
</li>
</ul>
<h3 id="5-1-1-JDBC"><a href="#5-1-1-JDBC" class="headerlink" title="5.1.1 JDBC"></a>5.1.1 JDBC</h3><ul>
<li>JDBC是一个JAVA API，用于与支持SQL的数据库系统进行通信</li>
<li>JDBC支持用于查询和更新数据以及检索查询结果的各种功能</li>
<li>JDBC还支持元数据检索，例如查询数据库中存在的关系以及关系属性的名称和类型</li>
</ul>
<p><strong>JDBC一般与数据库通信的模型</strong></p>
<ol>
<li><p>打开连接</p>
</li>
<li><p>创建”statement”对象</p>
</li>
<li><p>使用”statement”对象执行查询以发送查询并获取结果</p>
</li>
<li><p>用于处理错误的异常机制</p>
</li>
</ol>
<blockquote>
<p>在下面的程序中，必须在开头出导入java.sql.*,里面包含了JDBC提供的功能借口定义</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String dbid,String userid,String passwd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Connection conn=DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:2000:univdb&quot;</span>,userid,passwd</span><br><span class="line">        );</span><br><span class="line">        Statement stmt=conn.createStatement();</span><br><span class="line">        ...Do actual work here...</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(SQLException sqle)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SQLException: &quot;</span>+sqle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Database Connection:在Java程序访问数据库的第一步是建立与数据库的连接，连接好后才能执行SQL语句。具体来说，需要使用DriverManager类的getConnection()方法，它接受以下参数：<ul>
<li>数据库相关信息，包括URL/机器名，协议，端口号，数据库名<ul>
<li>JDBC并没有规定协议，协议取决于数据库实现</li>
<li>JDBC支持多种协议，比如 jdbc:oracle:thin 是 Oracle 支持的协议，而 jdbc:mysql 是 MySQL 支持的协议等</li>
</ul>
</li>
<li>数据库用户名</li>
<li>密码</li>
<li>返回一个Connection对象，用于与数据库通信</li>
</ul>
</li>
<li>SQL Statements:建立连接后，就要将SQL语句发送到数据库系统，然后在里面执行语句，在java中通过Statement类的实例来做到这一点。Statement对象并非SQL语句本身，而是一种让Java程序里调用和传送SQL语句到数据库相关的方法的对象，而执行语句需要调用executeQuery()或executeUpdate()方法，它们分别对应查询语句和费查询语句(更新，插入，删除，创建)等的执行，并且后者会返回一个表示被插入/更新/删除的元组数(如果是创建语句的话则返回0)</li>
<li>Exceptions<ul>
<li>执行任何的SQL语句都有可能抛出异常，所以编程时需要记得用try{…}catch{…}语句块捕获异常</li>
<li>异常可以分为SQLException(与SQL相关的异常)和Exception(一般的异常，与Java相关，比如空指针，数组越界等)</li>
<li>如果可以的话，最好编写一个完整的异常处理函数，以应对各种异常</li>
</ul>
</li>
<li>Resource Management<ul>
<li>建立连接、创建语句以及其他JDBC对象都会占用系统资源，所以需要确保程序能够关闭上述这些资源，以免产生资源池耗尽导致的故障</li>
<li>一种方法是显式调用关闭语句(比如conn.close()、stmt.close()分别关闭连接和语句)，但一旦遇到异常，提前退出的话，这些关闭语句就来不及被调用，那么问题还是没解决</li>
<li>更可靠的方法是使用try-with-resources构造块，就是在try关键字和语句块之间加上圆括号，里面包含连接、语句对象等资源，这样的话当离开try语句块时，这些资源会被自动关闭</li>
</ul>
</li>
</ul>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;insert into instructor values(&#x27;77987&#x27;,&#x27;Kim&#x27;,&#x27;Physics&#x27;,&#x27;98000&#x27;)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException sqle)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Could not insert tuple. &quot;</span>+sqle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">    <span class="string">&quot;select dept_name, avg(salary)</span></span><br><span class="line"><span class="string">    from instructor</span></span><br><span class="line"><span class="string">    group by dept_name&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">while</span>(rset.next())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(rset.getString(<span class="string">&quot;dept_name&quot;</span>)+<span class="string">&quot; &quot;</span>+rset.getFloat(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用executeQuery()方法执行查询语句后，检索得到的元组会放在一个ResultSet对象上，但是一次只能取其中的一个元组</li>
<li>具体来说，该对象调用next()方法获取下一个元组（如果还有的话），返回值是</li>
<li>另外，该对象提供了一些以get开头的方法来获取元组中具体属性的值，它们接收单个参数，可以使属性名(字符串)，也可以是属性的位置(整数值从1开始，可以看成是属性的编号)，常见的get方法有<ul>
<li>getString():可以检索<strong>任意</strong>SQL基本数据类型</li>
<li>getFloat():仅限于获取浮点数</li>
</ul>
</li>
</ul>
<h4 id="Getting-Result-Fields"><a href="#Getting-Result-Fields" class="headerlink" title="Getting Result Fields"></a>Getting Result Fields</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rset.getString(“dept_name”)</span><br><span class="line">rset.getString(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果dept_name是select result的第一个参数，上面这两行语句是等价的</p>
</blockquote>
<p>对于NULL值，可以使用wasNULL()方法来检查是否获取到了NULL值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rset.getInt(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(rset.wasNULL())</span><br><span class="line">    System.out.println(<span class="string">&quot;Got null value&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="Prepared-Statements"><a href="#Prepared-Statements" class="headerlink" title="Prepared Statements"></a>Prepared Statements</h4><p>我们不必预先编写一条完整的SQL语句，而是先创建一条预备语句(Prepared Statements),其中语句中出现的值用<code>?</code>替代(占用符)，之后再将具体的值插入到对应位置上。数据库系统会编译好这种预备语句。在执行这种语句的时候，数据库系统复用先前编译好的预备语句，然后将具体指应用到语句中，构成一条完整的语句</p>
<ul>
<li><code>Connection</code>类的<code>prepareStatement()</code>方法用于设置预备语句，该方法返回的是一个<code>PreparedStatement</code>对象，该对象具有<code>executeQuery()</code>和<code>executeUpdate()</code>方法</li>
<li>在 <code>prepareStatement()</code> 语句内的 SQL 语句具体值必须用 <code>?</code> 替代，之后可以用 set 开头的方法来设置具体值（比如 setInt()、setString()）。这类方法接收两个参数，第 1 个参数指明设置的是第几个 ?（从 1 开始），第 2 个参数是具体值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(</span><br><span class="line">    <span class="string">&quot;INSERT INTO instructor VALUES (?,?,?,?)&quot;</span></span><br><span class="line">);</span><br><span class="line">pSmt.setString(<span class="number">1</span>,<span class="string">&quot;88877&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">2</span>,<span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL语句等价为<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> instructor <span class="keyword">VALUES</span>(&quot;88878&quot;, &quot;Perry&quot;, &quot;Finance&quot;, <span class="number">125000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>在获取用户输入并将其添加到查询时，必须使用预备语句</p>
<p>切勿通过连接作为输入获取的字符串来创建查询，例如<code>insert into instructor values(&#39;&quot;+ID+&quot; &#39;,&#39;&quot;+name+&quot; &#39; dept_name+&quot; &#39;,&#39;&quot;+salary+&quot; &#39;);</code>这时候，如果name字段为<code>D&#39;Souza</code>,那么查询就会变成<code>insert into instructor values(’ 88879 ’, ’ D’Souza ’, ’ Finance ’, 125000);</code>这会导致SQL语法错误</p>
<p>事实上，这就是著名的SQL注入攻击，攻击者可以通过输入恶意字符串来执行SQL语句，比如删除表、插入数据等</p>
</blockquote>
<h4 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h4><blockquote>
<p>MetaData是描述数据库自身结构、组织、关系和特征的数据，而不是数据库中存储的实际业务数据。它提供了理解和管理数据所需的信息框架</p>
</blockquote>
<p>加入在Java程序中执行这样一条SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;SELECT * FROM instructor WHERE name = &#x27;&quot; <span class="operator">+</span> name <span class="operator">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure>
<p>其中<code>name</code>是字符换变量</p>
<p>如果 name = “X’ OR ‘Y’ = ‘Y”，那么最终的语句就会变成</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;SELECT * FROM instructor WHERE name = &#x27;&quot; <span class="operator">+</span> &quot;X&#x27; OR &#x27;Y&#x27; = &#x27;Y&quot; <span class="operator">+</span> &quot;&#x27;&quot;</span><br></pre></td></tr></table></figure>
<p>整理得</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;SELECT * FROM instructor WHERE name = &#x27;X&#x27; OR &#x27;Y&#x27; = &#x27;Y&#x27;</span><br></pre></td></tr></table></figure>
<p>由于WHERE子句恒为true，因此查询语句就能被执行，表里的全部内容都能被查到</p>
<p>如果使用预备语句及其set方法时，上述问题就不会发生了，因为所有输入的引号都会被转化为转义字符，不会破坏原字符串的结构</p>
<h4 id="Metadata-Features"><a href="#Metadata-Features" class="headerlink" title="Metadata Features"></a>Metadata Features</h4><p>通常，Java程序会在运行时，从数据库系统中获取数据声明</p>
<p>用于存储执行查询语句的结果的ResultSet接口有一个方法<code>getMetaData()</code>，里面包含结果集的元数据(Metadata)。而这个<code>ResultSetMetaData</code>对象也有一些寻找元数据信息的方法，比如结果的列数、具体列的名称和类型等等，这样我们就能获取数据声明(即模式)了</p>
<p>执行Query获取ResultSet(重命名为rs后)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rsmd.getColumnCount();i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(rsmd.getColumnTypeName(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getColumnCount()</code>方法返回元数(Arity)即列数</li>
<li><code>getColumnName()</code>方法返回列名</li>
<li><code>getColumnTypeName()</code>方法返回数据类型名，它们都接收单个表示列位置的整型参数(从1开始)<br>`</li>
</ul>
<p><code>Connection</code> 接口有一个方法 <code>getMetaData()</code>，它返回一个 DatabaseMetaData 对象。而 DatabaseMetaData 接口则提供了寻找<strong>数据库元数据</strong>shen的途径，提供了更为丰富的方法，比如返回产品名、版本号等等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line">ResultSet rs=dbmd.getColumns(<span class="literal">null</span>,<span class="string">&quot;univdb&quot;</span>,<span class="string">&quot;department&quot;</span>,<span class="string">&quot;%&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(rs.next())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>),rs.getSring(<span class="string">&quot;TYPE_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getColumns</code>方法接收四个参数<ul>
<li>目录名：<code>null</code>表示忽略该值</li>
<li>模式名</li>
<li>表名</li>
<li>列名：<code>%</code>表示返回所有列</li>
</ul>
</li>
</ul>
<p>DatabaseMetaData 还有其他方法：</p>
<ul>
<li><code>getTables()</code>：列出数据库中的所有表。前三个参数和 getColumns() 一致，最后一个参数用于限制符合条件的表，如果设为 null 则返回所有表（包括系统内部的表）</li>
<li><code>getPrimaryKeys()</code>：获取主键</li>
<li><code>getCrossReference()</code>：获取外键参照</li>
</ul>
<h4 id="Transaction-Control"><a href="#Transaction-Control" class="headerlink" title="Transaction Control"></a>Transaction Control</h4><ul>
<li>默认情况下，每个 SQL 语句都被视为自动提交的单独事务，这对于具有多个更新的事务来说是个比较麻烦的事情</li>
<li>我们可以在 Connection 中关闭自动提交<ul>
<li><code>conn.setAutoCommit(false);</code></li>
</ul>
</li>
<li>然后，我们必须显式提交或回滚事务<ul>
<li><code>conn.commit();</code>或<code>conn.rollback();</code></li>
</ul>
</li>
<li><code>conn.setAutoCommit(true)</code> 表示开启自动提交</li>
</ul>
<h3 id="5-1-2-SQLJ"><a href="#5-1-2-SQLJ" class="headerlink" title="5.1.2 SQLJ"></a>5.1.2 SQLJ</h3><blockquote>
<p>JDBC有时过于动态，编译器无法很好地提供捕获错误</p>
</blockquote>
<p>在Java中，也提供了嵌入式的SQL语句，这种语句称为SQLJ</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#sql iterator <span class="title function_">deptInfoIter</span><span class="params">(String dept name,<span class="type">int</span> avgSal)</span></span><br><span class="line"><span class="type">deptInfoIter</span> <span class="variable">iter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">#<span class="type">sql</span> <span class="variable">iter</span> <span class="operator">=</span> &#123;select dept_name,avg(salary) as avgSal from instructor group by dept_name&#125;;</span><br><span class="line"><span class="keyword">while</span>(iter.next())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> iter.dept_name();</span><br><span class="line">    <span class="type">int</span> <span class="variable">avgSal</span> <span class="operator">=</span> iter.avgSal();</span><br><span class="line">    System.out.println(deptName+<span class="string">&quot; &quot;</span>+avgSal);</span><br><span class="line">&#125;</span><br><span class="line">iter.close();</span><br></pre></td></tr></table></figure>
<h3 id="5-1-3-ODBC"><a href="#5-1-3-ODBC" class="headerlink" title="5.1.3 ODBC"></a>5.1.3 ODBC</h3><ul>
<li>开放数据库连接（Open Database Connectivity,ODBC）标准<ul>
<li>应用程序与数据库服务器通信的标准</li>
<li>当客户端程序发起ODBC API的调用时，库代码便与服务器通信，执行需要执行的动作，并返回结果</li>
</ul>
</li>
<li>应用于 GUI、电子表格等应用程序</li>
<li>ODBC 最初为 Basic 和 C 定义，可用于多种语言</li>
<li>每个支持 ODBC 的数据库系统都提供了一个必须与客户端程序链接的“驱动程序”库</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-68.png" alt="alt text"></p>
<ul>
<li>当客户端程序进行ODBC API调用时，库中的代码将与服务器通信以执行请求并获取结果</li>
<li>ODBC程序首先分配一个SQL环境，然后分配一个数据库连接处理器</li>
<li>使用SQLConnect()打开数据库连接<ul>
<li>SQLConnect()的参数：<ul>
<li>连接处理器</li>
<li>要连接的服务器</li>
<li>用户标识符</li>
<li>密码</li>
</ul>
</li>
<li>还必须指定参数的类型:SQL_NTS,表示前一个参数是以NULL结尾的字符串</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INT <span class="title function_">odbcExample</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RETCODE error;</span><br><span class="line">    HENV env;<span class="comment">//environment </span></span><br><span class="line">    HDBC conn;<span class="comment">//database connection</span></span><br><span class="line"></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    SQLAllocConnect(env,&amp;conn);</span><br><span class="line">    SQLConnect(conn,<span class="string">&quot;db.yale.edu&quot;</span>,SQL_NTS,<span class="string">&quot;avi&quot;</span>,SQL_NTS,<span class="string">&quot;avipasswd&quot;</span>);</span><br><span class="line">    &#123;Do actua; work&#125;</span><br><span class="line"></span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序使用<code>SQLExecDirect()</code>向数据库发送SQL命令</li>
<li>使用SQLFetch()获取结果元组</li>
<li>SQLBindCol()将C语言变量绑定到查询结果的属性<ul>
<li>当获取Tuples时，其<code>attribute</code>值会自动存储在相应的C变量中</li>
<li>SQLBindCol()的参数：<ul>
<li>ODBCstmt变量，查询结果中的属性位置</li>
<li>从SQL到C的类型转换</li>
<li>变量的地址</li>
<li>对于字符数组等可变长度类型<ul>
<li>变量的最大长度</li>
<li>用于在获取元组时存储实际长度的位置</li>
<li>注：Length字段返回负值表示该字段为NULL值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> deptname[<span class="number">80</span>];</span><br><span class="line"><span class="type">float</span> salary;</span><br><span class="line"><span class="type">int</span> lenOut1,lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* sqlquery = <span class="string">&quot;SELECT dept_name,SUM(salary)&quot;</span></span><br><span class="line">                <span class="string">&quot;FROM instructor&quot;</span></span><br><span class="line">                <span class="string">&quot; GROUP BY dept_name&quot;</span>;</span><br><span class="line">SQLAllocStmt(conn,&amp;stmt);</span><br><span class="line">error = SQLExecDirect(stmt,sqlquery,SQL_NTS);</span><br><span class="line"><span class="keyword">if</span>(error == SQL_SUCCESS)&#123;</span><br><span class="line">    SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="number">80</span>, &amp;lenOut1);</span><br><span class="line">    SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2);</span><br><span class="line">    <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s %g\n&quot;</span>, deptname, salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SQLFreeStmt(stmt,SQL_DROP);</span><br></pre></td></tr></table></figure>
<h4 id="ODBC-Prepared-Statements"><a href="#ODBC-Prepared-Statements" class="headerlink" title="ODBC Prepared Statements"></a>ODBC Prepared Statements</h4><ul>
<li>预备语句<ul>
<li>SQL语句在数据库中已经编译好</li>
<li>可以有占位符：例如<code>insert into account values(?,?,?)</code></li>
<li>使用占位符的实际值重复执行</li>
</ul>
</li>
<li>使用SQLPrepare()准备预备语句<ul>
<li>SQLPrepare(stmt,<code>&lt;SQL String&gt;</code>);</li>
</ul>
</li>
<li>绑定参数<ul>
<li>SQLBindParameter(stmt,<code>&lt;parameter#&gt;</code>,…type information and value omiitted for simplicity..)</li>
</ul>
</li>
<li>执行语句 <ul>
<li>retcode = SQLExecute(stmt);</li>
</ul>
</li>
</ul>
<h4 id="More-ODBC-Features"><a href="#More-ODBC-Features" class="headerlink" title="More ODBC Features"></a>More ODBC Features</h4><ul>
<li>元数据功能：<ul>
<li>查找数据库中的所有关系，并在数据库中查找查询结果或关系的列名称和类型</li>
</ul>
</li>
<li>默认情况下，每个SQL语句都被视为自动提交的单独事务<ul>
<li>可以关闭连接上的自动提交<code>SQLSetConnectOption(conn,SQL_AUTOCOMMIT,0)</code></li>
<li>事务必须由SQLTransaction(conn,SQL_COMMIT)或SQLTransact(conn, SQL_ROLLBACK)进行处理</li>
</ul>
</li>
</ul>
<h3 id="5-1-4-Embedded-SQL"><a href="#5-1-4-Embedded-SQL" class="headerlink" title="5.1.4 Embedded SQL"></a>5.1.4 Embedded SQL</h3><ul>
<li>SQL标准定义了SQL在各种编程语言中的嵌入</li>
<li>嵌入SQL查询的语言称为主机语言，主机语言中允许的SQL结构包括嵌入式SQL</li>
<li>这些语言的基本形式遵循在操作系统R将SQL嵌入到PL/1中的形式</li>
<li>EXEC SQL语句在主机语言中用于标识对预处理器的嵌入式SQL请求：<ul>
<li>EXEC SQL 嵌入式SQL语句</li>
<li>这样的语句因语言而异</li>
</ul>
</li>
<li>在某些语言中(如COBOL)中，分号被ED-EXEC替换</li>
<li>在 Java 中，嵌入使用 #SQL { …. }; ；在 C 中，使用 EXEC SQL <code>&lt;embedded SQL statement&gt;</code>;</li>
<li>在执行任何 SQL 语句之前，程序必须首先连接到数据库</li>
<li>这是通过以下方式完成的：<ul>
<li>使用密码的 EXEC-SQL 连接到服务器用户用户名;</li>
<li>此处，server 标识要建立连接的服务器</li>
</ul>
</li>
</ul>
<h4 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h4><ul>
<li>主机语言的变量可以在嵌入式SQL语句中使用<ul>
<li>他们的前面有冒号以区别于SQL中的变量，eg.<code>credit_amount</code></li>
</ul>
</li>
<li>如上所述使用的主机变量必须在<code>DECLARE</code>部分声明，如下面所示。但是用于声明变量的语法尊村通常的主机语言语法<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION; </span><br><span class="line">    <span class="type">int</span> account_number;</span><br><span class="line">    <span class="type">float</span> credit_amount;</span><br><span class="line">EXEC SQL END DECLARE SECTION;   </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Query-1"><a href="#Query-1" class="headerlink" title="Query"></a>Query</h4><ul>
<li>要编写嵌入式SQL查询，我们使用<code>declare a cursor for &lt;SQL query&gt;语句</code>,其中变量c用于标识查询</li>
<li>在主机语言中，查找完成超过主机语言中变量credit_amount中存储的学分的学生的ID和姓名</li>
<li>在SQL中指定查询，如下所示：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> </span><br><span class="line"><span class="keyword">declare</span> c <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> ID,name </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> tot_cred <span class="operator">&gt;</span> :credit_amount;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Open-and-Fetch"><a href="#Open-and-Fetch" class="headerlink" title="Open and Fetch"></a>Open and Fetch</h4><p>open语句如下所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> c;</span><br></pre></td></tr></table></figure>
<p>此语句使数据库系统执行查询并将结果保存在临时关系中，查询在执行open语句时使用主句语言变量credit-amount的值</p>
<p>fetch语句导致查询结果中的一个元组值放在主机语言变量上：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> c <span class="keyword">INTO</span> :si, :sn;</span><br></pre></td></tr></table></figure>
<p>重复调用fetch可以获取查询结果中的连续元组</p>
<h4 id="Close"><a href="#Close" class="headerlink" title="Close"></a>Close</h4><p>SQL 通信区域 （SQL Communication Area, SQLCA）中名为 SQLSTATE 的变量设置为“02000”，以指示没有更多数据</p>
<p>我们可以用 close 语句会导致<strong>数据库系统删除保存查询结果的临时关系</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> c;</span><br></pre></td></tr></table></figure>
<h4 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h4><ul>
<li>嵌入式SQL表达式也可以用于数据库修改(更新、插入和删除)</li>
<li>可以通过声明游标用于更新cursor获取的元组</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> </span><br><span class="line"><span class="keyword">declare</span> c <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们通过在cursor上执行fetch操作来迭代元组，在获取每个元组之后，我们执行以下代码：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor </span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary<span class="operator">+</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> c;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-2-Procedural-Constructs-in-SQL"><a href="#5-2-Procedural-Constructs-in-SQL" class="headerlink" title="5.2 Procedural Constructs in SQL"></a>5.2 Procedural Constructs in SQL</h2><h3 id="5-2-1-Procedural-Extensions-and-Stored-Procedurals"><a href="#5-2-1-Procedural-Extensions-and-Stored-Procedurals" class="headerlink" title="5.2.1 Procedural Extensions and Stored Procedurals"></a>5.2.1 Procedural Extensions and Stored Procedurals</h3><ul>
<li>SQL提供模块语言<ul>
<li>允许在SQL中定义过程，使用if-then-else语句，for和while循环等</li>
</ul>
</li>
<li>存储过程<ul>
<li>可以在数据库中存储过程</li>
<li>然后使用call语句执行他们</li>
<li>允许外部应用程序在不知道详细信息的情况下对数据库进行操作<h3 id="5-2-2-Functions-and-Procedures"><a href="#5-2-2-Functions-and-Procedures" class="headerlink" title="5.2.2 Functions and Procedures"></a>5.2.2 Functions and Procedures</h3></li>
</ul>
</li>
<li>函数和过程允许将”业务逻辑(Business Logic)”存储在数据库中并根据SQL语句执行</li>
<li>这些可以由SQL的过程组件或外部编程语言定义</li>
<li>我们在这里介绍的语法由SQL标准定义<ul>
<li>大多数数据库都实现此语法的非标准版本</li>
</ul>
</li>
</ul>
<h4 id="1-SQL-Functions"><a href="#1-SQL-Functions" class="headerlink" title="1 SQL Functions"></a>1 SQL Functions</h4><ul>
<li>定义一个函数，该函数在给定部门名称的情况下，返回该部门中的老师人数总数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Declaration</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(dept_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">integer</span><span class="comment">--指定返回值类型</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> d_count interger;<span class="comment">--声明一个局部变量d_count</span></span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> d_count</span><br><span class="line">        <span class="keyword">from</span> instructor<span class="comment">--结果存入d_count</span></span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> dept_name;</span><br><span class="line">    <span class="keyword">return</span> d_count;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Invocation</span><br><span class="line"><span class="keyword">select</span> dept_name, budget</span><br><span class="line"><span class="keyword">from</span> department</span><br><span class="line"><span class="keyword">where</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<p>此外，SQL标准还支持将表作为返回结果的函数，这样的函数称为表函数(Tble Functions),也可以看作是带参数的实体化视图。具体的函数定义和调用如下所示</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Declaration</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> instructor_of(dept_name <span class="type">varchar</span>(<span class="number">20</span>))</span><br><span class="line">    <span class="keyword">returns</span> <span class="keyword">table</span>(</span><br><span class="line">        ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">        salary <span class="type">numeric</span>(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">table</span>(</span><br><span class="line">        <span class="keyword">select</span> ID, name, dept_name, salary</span><br><span class="line">        <span class="keyword">from</span> instructor</span><br><span class="line">        <span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> instructor_of.dept_name</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Invocation</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span>(instructor_of(<span class="string">&#x27;Finance&#x27;</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>在函数定义内使用参数时，如果参数名有重名的情况，那么需要加上<code>函数名.</code>前缀(这就是在第十一行改为<code>instructor_of</code>)</li>
</ul>
<h4 id="2-SQL-Procedures"><a href="#2-SQL-Procedures" class="headerlink" title="2 SQL Procedures"></a>2 SQL Procedures</h4><ul>
<li>在上面的例子中，dept_count函数还可以改写为<code>procedure</code>:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Declaration</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">in</span> dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">out</span> d_count <span class="type">integer</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> d_count</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关键字<code>in</code>和<code>out</code>分别表示接收进来的参数和存放返回结果的参数</li>
<li>我们可以使用call语句从SQL过程或嵌入式SQL调用过程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> d_count <span class="type">integer</span>;</span><br><span class="line"><span class="keyword">call</span> dept_count_proc(<span class="string">&#x27;Physics&#x27;</span>,d_count);</span><br></pre></td></tr></table></figure>
<p>SQL允许多个参数不同的函数或过程同名，因为SQL会同时根据函数/过程名以及参数来识别函数/过程 </p>
<h3 id="5-2-3-Procedural-Constructs"><a href="#5-2-3-Procedural-Constructs" class="headerlink" title="5.2.3 Procedural Constructs"></a>5.2.3 Procedural Constructs</h3><ul>
<li>大多数数据库系统都实现了一下标准语法的变体<ul>
<li>所以用户必须阅读系统手册，了解哪些功能适用于用户的系统</li>
</ul>
</li>
<li>复合语句：begin…end…<ul>
<li>我们可以再begin和end之间包含多个SQL语句</li>
<li>局部变量可以再复合语句中声明</li>
</ul>
</li>
<li>循环语句<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--while statements</span></span><br><span class="line">while <span class="type">boolean</span> expression do </span><br><span class="line">    sequence <span class="keyword">of</span> statements;</span><br><span class="line"><span class="keyword">end</span> while</span><br><span class="line"></span><br><span class="line"><span class="comment">--Repeat Statements </span></span><br><span class="line">repeat </span><br><span class="line">    sequence <span class="keyword">of</span> statements;</span><br><span class="line">until <span class="type">boolean</span> expression</span><br><span class="line"></span><br><span class="line"><span class="comment">--for statements</span></span><br><span class="line"><span class="keyword">declare</span> n <span class="type">integer</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">as</span> <span class="comment">--r作为当前的一个游标，对关系中的每个元组进行遍历</span></span><br><span class="line">    <span class="keyword">select</span> budget <span class="keyword">from</span> department </span><br><span class="line">    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">do </span><br><span class="line">    <span class="keyword">set</span> n <span class="operator">=</span> n<span class="operator">-</span>r.budget</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">for</span></span><br></pre></td></tr></table></figure></li>
<li>循环体内使用<code>leave</code>关键字可提前退出循环，而<code>iterate</code>则忽略当前元组，处理下一个元组。它们类似于编程语言的<code>break</code>和<code>continue</code></li>
<li>条件分之语句</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if <span class="type">boolean</span> expression </span><br><span class="line"><span class="keyword">then</span> statement <span class="keyword">or</span> compound statement</span><br><span class="line"><span class="keyword">else</span> <span class="type">boolean</span> expression</span><br><span class="line"><span class="keyword">then</span> statement <span class="keyword">or</span> compound statement</span><br><span class="line"><span class="keyword">else</span> statement <span class="keyword">or</span> compound statement</span><br><span class="line"><span class="keyword">end</span> if</span><br></pre></td></tr></table></figure>
<h3 id="5-2-4-External-Language-Functions-Procedures"><a href="#5-2-4-External-Language-Functions-Procedures" class="headerlink" title="5.2.4 External Language Functions/Procedures"></a>5.2.4 External Language Functions/Procedures</h3><p>上述介绍的构造块鲜有数据库支持，因此程序员转而使用外部的编程语言：先用其它编程语言定义函数后，再用SQL语句导入外部的过程或函数，比如<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">in</span> dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">out</span> count <span class="type">integer</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">language</span> C </span><br><span class="line"><span class="keyword">external</span> name <span class="string">&#x27;/usr/avi/bin/dept_count_proc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> dept_count(</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="type">integer</span> </span><br><span class="line"><span class="keyword">language</span> C </span><br><span class="line"><span class="keyword">external</span> name <span class="string">&#x27;/usr/avi/bin/dept_count_func&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>外部语言功能/过程的好处：许多操作更高效，表现力更强</li>
<li>缺点：<ul>
<li>实现功能的代码可能需要加载导数据库系统中并在数据库系统的地址空间中执行，可能会有<ul>
<li>数据库结构意外损坏的风险</li>
<li>安全风险，允许用户访问未经授权的数据</li>
</ul>
</li>
<li>还有其它选择，它们可以提供良好的安全性，但代价是性能可能会变差</li>
<li>当效率比安全性更重要时，更偏向在数据库系统空间中直接执行</li>
</ul>
</li>
</ul>
<p>对于外部语言造成的风险，数据库系统提供了一些安全机制，比如：</p>
<ul>
<li>使用沙盒技术<ul>
<li>即使用像 Java 这样的安全语言，它不能用于访问/损坏数据库代码的其他部分</li>
</ul>
</li>
<li>或者，在单独的进程中运行外部语言函数/过程，而不访问数据库进程的内存<ul>
<li>通过进程间通信传输参数和结果</li>
</ul>
</li>
<li>两者都有性能开销</li>
<li>许多数据库系统同时支持上述方法以及在数据库系统地址空间中直接执行</li>
</ul>
<h2 id="5-3-Triggers"><a href="#5-3-Triggers" class="headerlink" title="5.3 Triggers"></a>5.3 Triggers</h2><p>触发器(Trigger)是一种系统自动执行的语句，作为对数据库修改的“副作用”。要想定义一个触发器，需要：</p>
<ul>
<li>指定触发器何时执行—这点可以分解为检查触发器的时间(Event)<ul>
<li>可以使插入、删除或者更新</li>
<li>更新时的触发器可以限制为特定属性<code>after update of takes on grade</code></li>
</ul>
</li>
<li>可以引用更新之前和之后的属性值<ul>
<li><code>referencing old row as</code>:用于删除和更新</li>
<li><code>referencing new row as</code>:用于插入和更新</li>
</ul>
</li>
<li>执行触发器满足的条件(Condition)</li>
<li>指定触发器需要执行的动作(Actions)</li>
</ul>
<p>要设计触发机制，我们必须：</p>
<ul>
<li>指定要执行触发器的条件</li>
<li><p>指定触发器执行时要执行的操作</p>
</li>
<li><p>对于一个表格<code>account_log(account,amount,datetime)</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> account_trigger after <span class="keyword">update</span> <span class="keyword">of</span> account <span class="keyword">on</span> balance</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> new_row</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> old_row</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> nrow.balance <span class="operator">-</span> orow.balance <span class="operator">&gt;=</span> <span class="number">200000</span> <span class="keyword">or</span> </span><br><span class="line">    orow.balance <span class="operator">-</span> nrow.balance <span class="operator">&gt;=</span> <span class="number">50000</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">insert into</span> account_log <span class="keyword">values</span> (nrow.account<span class="operator">-</span>number,nrow.balance <span class="operator">-</span> orow.balance,<span class="built_in">current_time</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>time_slot_id</code>不是主键，因此我们无法创建从section到timeslot的外检约束，再删除操作中不会引起其他影响。但我们可以设计一个触发器，用来检查当前课程的<code>time_slot_id</code>是否在表内，在section和timeslot上使用触发器来实施完整性约束</p>
</li>
<li><p>检查新记录的<code>time_slot_id</code>是否存在于<code>timeslot</code>表中，从而保证section表中的<code>time_slot_id</code>都是有效的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 </span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id</span><br><span class="line">    <span class="keyword">FROM</span> time_slot <span class="comment">/* time_slot_id not present in time_slot */</span></span><br><span class="line">))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>for each row</code>字句能够显式迭代每一个被插入的行记录</li>
<li><code>referencing new row as nrow</code>子句创建了一个过渡变量(Transition Variable)，用于临时存储被插入的行记录</li>
<li><p><code>when</code>语句指明了触发器的触发条件</p>
</li>
<li><p>time_slot_id 不是主键，所以当 time_slot_id 已经被删完了，但依然有课程在引用，就要 rollback</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> timeslot_check2 after <span class="keyword">delete</span> <span class="keyword">on</span> timeslot</span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">old</span> <span class="type">row</span> <span class="keyword">as</span> orow</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (orow.time_slot_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> time_slot_id</span><br><span class="line">        <span class="keyword">from</span> time_slot</span><br><span class="line">    ) </span><br><span class="line">    <span class="keyword">and</span> orow.time_slot_id <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> time_slot_id</span><br><span class="line">        <span class="keyword">from</span> section</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">rollback</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>触发器可以在事件之前激活，这可以用做额外的约束</p>
</li>
<li><p>将空白部分设置为NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> setnull_trigger before <span class="keyword">update</span> <span class="keyword">of</span> takes  </span><br><span class="line"><span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> <span class="keyword">as</span> nrow  </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  </span><br><span class="line"><span class="keyword">when</span> (nrow.grade <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">begin</span> <span class="keyword">atomic</span>  <span class="comment">--作为一个原子操作执行</span></span><br><span class="line">    <span class="keyword">set</span> nrow.grade <span class="operator">=</span> <span class="keyword">null</span>;  </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们使用触发器来保持 credits_earned 的值，如果本来挂科，或者没有成绩，更新后不再挂科而且有成绩，就把学分加上去。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned </span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">    <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> </span><br><span class="line">        (<span class="keyword">SELECT</span> credits</span><br><span class="line">         <span class="keyword">FROM</span> course</span><br><span class="line">         <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id)</span><br><span class="line">    <span class="keyword">WHERE</span> student.id <span class="operator">=</span> nrow.id;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>很多数据库系统还支持其他触发事件，比如用户登录数据库、系统关机、修改系统设置等。</p>
<p>在上述例子中，可以看到触发器既可以在事件发生前执行，也可以在事件发生后执行。一般来说，前者作为一个额外的约束限制，不仅阻止非法行为引起的错误，还要采取补救措施，使语句变得合法。</p>
<p>除了将触发器的动作一行行地应用到表中的每个行记录上，也可以将触发器一次性作用于满足 SQL 的所有行记录上，只要：</p>
<ul>
<li>将 for each row 改为 for each statement</li>
<li>并且使用 referencing old table as 和 referencing new table as 来创建过渡表</li>
<li>我们还可以决定启用或禁用触发器，相关语法为：alter trigger trigger_name disable</li>
</ul>
<p>有些数据库采用另一种语法：disable trigger trigger_name。<br>此外，还可以删除触发器：drop trigger trigger_name。</p>
<p>与函数 / 过程的语法类似，由于很多数据库系统在 SQL 相关标准建立前就广泛使用触发器了，因此几乎每个数据库系统都有自己的触发器语法，它们是互不兼容的</p>
<h3 id="When-not-to-use-Triggers"><a href="#When-not-to-use-Triggers" class="headerlink" title="When not to use Triggers"></a>When not to use Triggers</h3><p>实际上，很多看似能够用触发器解决的问题， SQL 标准早已为我们提供了更方便的方法来解决这些问题，所以在以下场景中，没有必要使用触发器：</p>
<ul>
<li>维护实体化视图：现在很多数据库系统都支持自动维护了，因此无需使用触发器手动维护</li>
<li>维护数据库的拷贝：理由同上</li>
<li>从备份拷贝上加载数据，或备份地点上复制数据库更新</li>
</ul>
<p>编写触发器的时候需小心，因为在运行时，一个触发器的错误可能会触发下一个触发器，最严重的情况下会出现无限的连锁反应。解决方案有：</p>
<ul>
<li>某些数据库系统规定了最大的触发器链的长度，超过限制就会报错</li>
<li>另外的数据库系统泽会根据触发器是否尝试引用更新后导致自身首先出发的关系来判断是否产生错误</li>
</ul>
<h1 id="Chapter-6-Entity-Relationship-Model"><a href="#Chapter-6-Entity-Relationship-Model" class="headerlink" title="Chapter 6:Entity-Relationship Model"></a>Chapter 6:Entity-Relationship Model</h1><h2 id="Database-Design-Process"><a href="#Database-Design-Process" class="headerlink" title="Database Design Process"></a>Database Design Process</h2><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-69.png" alt="alt text"></p>
<h2 id="1-Design-phases"><a href="#1-Design-phases" class="headerlink" title="1. Design phases"></a>1. Design phases</h2><ul>
<li>初始阶段(需求规范)：充分描述潜在数据库用户的数据需求</li>
<li>第二阶段(概念设计)：选择数据模型<ul>
<li>应用所选数据模型的概念</li>
<li>将这些需求转换为数据库的概念模式</li>
<li>完全开发的概念模式代表了企业的功能要求：描述对数据执行的操作(或事务)类型</li>
</ul>
</li>
<li>最后阶段(数据库设计)：从抽象数据模型转向数据库的实现<ul>
<li>逻辑设计(Logical Design)：决定书苦苦模式<ul>
<li>数据库设计要求我们找到一个”好的”关系模式集合</li>
<li>业务决策——我们应该在数据库中记录哪些属性</li>
<li>计算机科学决策——我们应该拥有哪些关系模式，以及属性应该如何在各种关系模式之间分配</li>
</ul>
</li>
<li>物理设计——决定数据库的物理布局</li>
</ul>
</li>
</ul>
<h2 id="2-Design-Alternatives"><a href="#2-Design-Alternatives" class="headerlink" title="2. Design Alternatives"></a>2. Design Alternatives</h2><ul>
<li>在设计数据库架构时，我们必须确保避免两个主要陷阱<ul>
<li>冗余：糟糕的设计可能会导致重复的信息<ul>
<li>信息的冗余表示可能会导致各种信息副本之间的数据不一致</li>
</ul>
</li>
<li>不完整：糟糕的设计可能会使企业</li>
</ul>
</li>
<li>避免糟糕的设计是不够的。可能有很多好的设计让我们必须从中进行选择</li>
<li>数据库设计可能是一个具有挑战性的问题<ul>
<li>巨大的设计空间<h2 id="3-Design-Approaches"><a href="#3-Design-Approaches" class="headerlink" title="3. Design Approaches"></a>3. Design Approaches</h2></li>
</ul>
</li>
<li>实体关系模型<ul>
<li>将企业建模为实体和关系的集合</li>
<li>实体：可以与其他对象区别开来的事物或对象<ul>
<li>由一组属性描述</li>
</ul>
</li>
<li>关系：多个实体之间的关联</li>
<li>用实体关系图以图示方式表示</li>
</ul>
</li>
<li>归一化理论<ul>
<li>正式确定哪些设计是坏的，并对其进行测试</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-70.png" alt="alt text">  </p>
<ul>
<li>一个方形款就是一个实体的集合</li>
<li>实体与实体之间有关系，一个菱形框表示关系<ul>
<li>一对一(↔)</li>
<li>多对一(→)</li>
<li>一对多(←)</li>
<li>这里<code>instructor</code>属性不需要<code>dept</code>属性，因为在<code>department</code>实体里有了，否则会冗余</li>
</ul>
</li>
<li>每个实体直接转换为关系模式。关系转换为元组，元素为两个表的<code>foreign key</code>.对于一对多的情况(如<code>instructor</code>和<code>department</code>)转换后primary key仍为ID</li>
<li>为了减少表的数量可以把主键相同的表合并</li>
<li>双横线与单横线<ul>
<li>双横线表示每个对象都必须参与关系，而单横线则表示对象可以不参与关系。</li>
<li>如<code>course_dept</code>和<code>course</code>为双横线，则表示每一个课程都要对应一个开课部门，而<code>department</code>和<code>course_dept</code>为单横线，说明有的院系可以不开设课程</li>
</ul>
</li>
<li>有些联系是隐含的，如授课老师和听课的同学</li>
<li><code>section</code>不足以唯一确定元组，称为弱实体(weak entity)，依赖于另一个实体，因为<code>course_id</code>放在<code>section</code>会有冗余，因此没有这个属性，导致形成一个弱实体(对应的relation要加上双框)，<code>section</code>不能离开<code>course</code>存在</li>
<li><code>relationship</code>上也可以带属性，如<code>takes</code>上的<code>grade</code></li>
<li>关系双方可以是相同的实体集合，<code>course</code>这里的<code>preeq</code>是多对多，表示一门课可以有多门预修课，一门课也可以是多门课的预修课。{}里面是多个值，表示复合属性。这里表示<code>time_slot_id</code>实际上可以由这三个属性复合而成</li>
</ul>
<h2 id="4-Database-Modeling"><a href="#4-Database-Modeling" class="headerlink" title="4. Database Modeling"></a>4. Database Modeling</h2><h3 id="4-1-Entities"><a href="#4-1-Entities" class="headerlink" title="4.1 Entities"></a>4.1 Entities</h3><ul>
<li>数据库可以建模为：<ul>
<li>实体的集合</li>
<li>实体之间的关系</li>
</ul>
</li>
<li>实体是存在且可以与其他对象区分开来的对象，如特定人员、公司、事件、工厂</li>
<li>实体具有属性，如对于一个人来说，有地址、姓名、性别等</li>
<li>实体集是一组共享相同属性的相同类型的实体，如所有人员、公司、树、假日的集合</li>
<li>实体集可以按如下方式以图形方式表示<ul>
<li>实体集以矩形框表示</li>
<li>实体矩形内列出的属性</li>
<li>下划线表示主键属性<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-71.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="4-2-Relationship-Sets"><a href="#4-2-Relationship-Sets" class="headerlink" title="4.2 Relationship Sets"></a>4.2 Relationship Sets</h3><ul>
<li>关系是多个实体之间的关联</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-72.png" alt="alt text"></p>
<ul>
<li><p>关系集是$n \geq 2$个实体之间的数学关系，每个实体都取自实体集，即${e_1,e_2,…,e_n|e_1 \in E_1,e_2 \in E_2,…,e_n \in E_n}$,其中$(e_1,e_2,…,e_n)$是一个关系</p>
<ul>
<li>按照上面的例子，$(44553,22222) \in advisor$</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-73.png" alt="alt text"></p>
<h3 id="4-3-Relationship-Set-with-Attributes"><a href="#4-3-Relationship-Set-with-Attributes" class="headerlink" title="4.3 Relationship Set with Attributes"></a>4.3 Relationship Set with Attributes</h3><p>关系集也可以有属性，例如实体集instructor和student之间的advisor关系集就可能具有属性date,该属性跟踪student开始与advisor关联的时间</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-74.png" alt="alt text"><br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-75.png" alt="alt text"></p>
<h3 id="4-4-Role"><a href="#4-4-Role" class="headerlink" title="4.4 Role"></a>4.4 Role</h3><ul>
<li>关系的实体集不需要是不同的<ul>
<li>实体集的每次出现都在关系中扮演一个<code>Role</code></li>
</ul>
</li>
</ul>
</li>
<li>标签<code>course_id</code>和<code>prereq_id</code>都被称为<code>Role</code></li>
</ul>
<h3 id="4-5-Degree-of-a-Relationship-Set"><a href="#4-5-Degree-of-a-Relationship-Set" class="headerlink" title="4.5 Degree of a Relationship Set"></a>4.5 Degree of a Relationship Set</h3><ul>
<li>二元联系(Binary Relationship)<ul>
<li>涉及两个实体集(或称为degree=2)</li>
<li>数据库系统中的大多数关系都是二元的</li>
</ul>
</li>
<li>在某些情况下，将关系表示为非二元关系会更方便</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-76.png" alt="alt text"></p>
<h3 id="4-6-Attributes"><a href="#4-6-Attributes" class="headerlink" title="4.6 Attributes"></a>4.6 Attributes</h3><ul>
<li>实体由一组属性表示，这些属性是实体集的所有成员都拥有的属性<ul>
<li><code>instructor = (ID, name, street, city, salary)</code>,<code>course = (course_id, title, credits)</code></li>
</ul>
</li>
<li>域(domain)—-每个属性的允许值集</li>
<li>属性类型<ul>
<li>Simple和Composite属性</li>
<li>单值(Single-valued)和多值(Multi-valued)属性 eg.phone_numbers,可以同时拥有多个电话号码，所以电话号码这一属性不一定只有一个值</li>
</ul>
</li>
<li><p>派生(Derived)属性</p>
<ul>
<li>可以从其他属性计算</li>
<li><p>eg.给定date_of_birth，可以计算出年龄</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-77.png" alt="alt text"></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-7-Mapping-Cardinality-Constraints"><a href="#4-7-Mapping-Cardinality-Constraints" class="headerlink" title="4.7 Mapping Cardinality Constraints"></a>4.7 Mapping Cardinality Constraints</h3><ul>
<li>二元关系集的映射基数约束表示另一个实体可以通过关系集关联到实体数</li>
<li>在描述二元关系时最有用</li>
<li>对于二元关系集，映射基数必须是一对一、一对多、多对一、多对多类型之一</li>
<li>我们通过在关系集和实体集之间绘制一条有向线（→）表示“一”，用一条无向线（-）表示“多”</li>
</ul>
<h4 id="4-7-1-One-to-One-Relationships"><a href="#4-7-1-One-to-One-Relationships" class="headerlink" title="4.7.1 One-to-One Relationships"></a>4.7.1 One-to-One Relationships</h4><ul>
<li>教师和学生之间的一对一关系：<ul>
<li>一个学生通过advisor<strong>最多</strong>与一名教师关联，可以没有</li>
<li>一名教师通过advisor<strong>最多</strong>与一名学生关联，可以没有</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-78.png" alt="alt text"></p>
<h4 id="4-7-2-One-to-Many-Relationships"><a href="#4-7-2-One-to-Many-Relationships" class="headerlink" title="4.7.2 One-to-Many Relationships"></a>4.7.2 One-to-Many Relationships</h4><ul>
<li>教师和学生之间的一对多关系：<ul>
<li>一名教师通过advisor与多个(包括0个)学生关联</li>
<li>一个学生通过advisor最多与一名教师关联</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-79.png" alt="alt text"></p>
<h4 id="4-7-3-Many-to-One-Relationships"><a href="#4-7-3-Many-to-One-Relationships" class="headerlink" title="4.7.3 Many-to-One Relationships"></a>4.7.3 Many-to-One Relationships</h4><ul>
<li>教师和学生之间的多对一关系<ul>
<li>一名教师通过advisor最多与一名学生关联</li>
<li>一名学生通过advisor与多个(包括0个)教师关联</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-80.png" alt="alt text"></p>
<h4 id="4-7-4-Many-to-Many-Relationships"><a href="#4-7-4-Many-to-Many-Relationships" class="headerlink" title="4.7.4 Many-to-Many Relationships"></a>4.7.4 Many-to-Many Relationships</h4><ul>
<li>教师和学生之间的多对多关系<ul>
<li>一名教师通过advisor与多个(包括0个)学生关联</li>
<li>一名学生通过advisor与多个(包括0个)教师关联</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-81.png" alt="alt text"></p>
<h3 id="4-8-Total-and-Partial-Participation"><a href="#4-8-Total-and-Partial-Participation" class="headerlink" title="4.8 Total and Partial Participation"></a>4.8 Total and Partial Participation</h3><ul>
<li>完全参与(Total Participation)通常使用双线表示，表示实体集中的每个实体都至少参与关系集中的一个关系<ul>
<li>例如每一个学生都应当至少有一个相关的advisor<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-82.png" alt="alt text"></li>
</ul>
</li>
<li>部分参与(Partial Participation)通常使用单线表示，表示某些实体可能不参与关系集中的任何关系<ul>
<li>例如一个教师可能没有相关的advisor</li>
</ul>
</li>
<li>一条线可能具有关联的最小和最大的基数，以l..h的形式表示关系，其中l是最小基数，h是最大基数<ul>
<li>最小值是1表示完全参与</li>
<li>最大值是1表示实体最多参与一个</li>
<li>最大值*表示无限制</li>
<li>例如，教师可以为0个或更多学生提供建议。学生必须有一名advisor,不能有多个advisor<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-83.png" alt="alt text"></li>
</ul>
</li>
<li>我们最多允许三元(或更高度数)关系中的一个箭头 来表示基数约束</li>
<li>例如，proj_guide到instructor的箭头表示每个学生最多有一个项目的instructor<ul>
<li>原因：这与主键的解释有关。假设有如下关系图，那么对该关系图的主键解释有两种<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/253211ac7e01c92106952a82893f4d4.jpg" alt="alt text"></li>
<li>来自$E_1,E_2$的一个特定实体组合可以和至多一个来自$E_3,E_4$的实体组合相关联。因此，联系R的主键可以用主键$E_1,E_2$的并集来构造</li>
<li>来自$E_1,E_2,E_3$的一个特定实体组合至多可与来自$E_4$的一个实体组合相关联，那么，可以用$E_1,E_2,E_3$主键的并集构成R的主键。$E_1,E_2,E_4$的主码的并集也是如此<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-84.png" alt="alt text"></li>
</ul>
</li>
</ul>
<h3 id="4-9-Primary-Key"><a href="#4-9-Primary-Key" class="headerlink" title="4.9 Primary Key"></a>4.9 Primary Key</h3><ul>
<li>主键提供了一种指定如何区分实体和关系的方法，我们将考虑实体集、关系集、弱实体集</li>
<li>根据定义 各个实体是不同的</li>
<li>从数据库的角度来看，它们之间的差异必须用它们的属性来表示</li>
<li>实体的属性值必须使其能够唯一标识实体<ul>
<li>实体集中的任何两个实体集都不允许所有属性具有完全相同的值</li>
</ul>
</li>
<li>实体的键就是一组足以将实体区分开来的属性</li>
<li>为了区分关系集的各种关系，我们使用关系集中实体的各个主键<ul>
<li>设R为涉及实体集$E_1,E_2,…,E_n$的关系集</li>
<li>R的主键由$E_1,E_2,…,E_n$的各个主键组成</li>
<li>如果关系集R具有与其关联的属性$a_1,a_2,…,a_m$，则R的主键还包括属性$a_1,a_2,…,a_m$</li>
<li>eg.advisor关系集的主键是instructor.ID和student.ID:<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-85.png" alt="alt text"></li>
</ul>
</li>
<li>关系集的主键选择取决于关系集的映射基数<ul>
<li>如果二元关系为一对一关系，任一参与实体集的主键都可以构成一个最小超级键(Minimal Superkey),并且可以选择其中任意一个作为主键</li>
<li>如果二元关系为一对多关系或多对一，“多“关系一端的主键是最小超级键，作为主键</li>
<li>如果二元关系为多对多关系，两个实体集的主键的并集是最小超级键</li>
</ul>
</li>
</ul>
<h3 id="4-10-Weak-Entity-Sets"><a href="#4-10-Weak-Entity-Sets" class="headerlink" title="4.10 Weak Entity Sets"></a>4.10 Weak Entity Sets</h3><ul>
<li>没有主键的实体集称为弱实体集</li>
<li>弱实体集的存在取决于表示性实体集(Identifying Entity Set)的存在<ul>
<li>它必须通过从表示到弱实体集的一对多关系集与标识实体集相关</li>
<li>我们使用双菱形来描绘的标识性联系(Identifying Relationship)</li>
</ul>
</li>
<li>弱实体集的分辨符(Discriminator，或称为部分键)是指当弱实体集所依赖的标识实体已知时区分实体集的所有实体的属性集</li>
<li>我们用虚线为弱实体集的分辨符画下划线</li>
<li>我们将弱实体的识别关系放在双菱形中</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-86.png" alt="alt text"></p>
<p>注意：强实体集的主键不会与弱实体集一起显式存储，因为它隐含在标识关系中</p>
<p>如果显式存储<code>course_id</code>则section可以成为强实体，但section和course之间的关系将由course和section通用属性定义的隐式关系course_id复制</p>
<h3 id="4-11-Rebundant-Attributes"><a href="#4-11-Rebundant-Attributes" class="headerlink" title="4.11 Rebundant Attributes"></a>4.11 Rebundant Attributes</h3><ul>
<li>假设我们有实体集<ul>
<li>student，属性为：ID, name, tot_cred, dept_name</li>
<li>department，属性为：dept_name, building, budget</li>
</ul>
</li>
<li>我们使用关系集stu_dept对每个学生都有一个关联部门这一事实进行建模</li>
<li>下面student中的属性dept_name复制了关系中存在的信息，因此是多余的，并且需要被删除</li>
<li>但是，当转换回表时，在某些情况下，该属性会重新引入</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-87.png" alt="alt text"></p>
<h2 id="5-Reduction-to-Relational-Schemas"><a href="#5-Reduction-to-Relational-Schemas" class="headerlink" title="5. Reduction to Relational Schemas"></a>5. Reduction to Relational Schemas</h2><ul>
<li>实体集和关系集可以统一表示为表示数据库内容的关系架构</li>
<li>符合E-R图的数据库可以由架构集合表示</li>
<li>对于每个实体集和关系集，都有一个唯一的架构，该架构分配有相应的实体集或关系集的名称</li>
<li>每个架构都有许多列(通常对应于属性)，这些列具有唯一的名称</li>
</ul>
<h3 id="5-1-Representing-Entity-Sets-with-Simple-Attributes"><a href="#5-1-Representing-Entity-Sets-with-Simple-Attributes" class="headerlink" title="5.1 Representing Entity Sets with Simple Attributes"></a>5.1 Representing Entity Sets with Simple Attributes</h3><ul>
<li>强实体集简化为具有相同属性的架构</li>
<li>弱实体集将变成一个表，该表包含标识强实体集的主键<ul>
<li>表的主键是弱实体集的分辨符与标识强实体集的主键的并集</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-88.png" alt="alt text"></p>
<ul>
<li>section表的主键是<code>(course_id,sec_id,semester,year)</code></li>
</ul>
<h3 id="5-2-Representing-Relational-Sets"><a href="#5-2-Representing-Relational-Sets" class="headerlink" title="5.2 Representing Relational Sets"></a>5.2 Representing Relational Sets</h3><p>一个多对多关系表示为一个架构，其中包含两个参与实体集的主键的属性</p>
<ul>
<li>e.g.对于一个关系集advisor的模式：advisor=(<u>s_id,i_id</u>)</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-89.png" alt="alt text"></p>
<h3 id="5-3-Rebundancy-of-Schemas"><a href="#5-3-Rebundancy-of-Schemas" class="headerlink" title="5.3 Rebundancy of Schemas"></a>5.3 Rebundancy of Schemas</h3><p>在多段总计的多对一和一对多关系集可以通过向”多”的一段添加一个额外的属性来表示，该属性包含“一”一端的主键</p>
<ul>
<li>e.g. 将关系集inst_dept创建模式稀释到两个实体集中</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-90.png" alt="alt text"></p>
<ul>
<li><p>对于一对一关系集，可以选择任何一方作为“多”的一端</p>
<ul>
<li>也就是说，可以将更多的属性添加到与两个实体集对应的任意表中</li>
</ul>
</li>
<li><p>如果参与在“多”的一端是部分参与，则在与“多”的一端对应的模式中用额外的属性替换模式可能会导致null值</p>
</li>
<li>与将弱实体集链接到其标识的强实体集的关系集对应的模式是多余的<ul>
<li>e.g.section模式已包含将显示在sec_course模式中的属性</li>
</ul>
</li>
</ul>
<h3 id="5-4-Composite-and-Multivalued-Attributes"><a href="#5-4-Composite-and-Multivalued-Attributes" class="headerlink" title="5.4 Composite and Multivalued Attributes"></a>5.4 Composite and Multivalued Attributes</h3><ul>
<li>通过为每个组件属性创建单独的属性来扁平化复合属性<ul>
<li>就像在C语言里定义了一个结构，但是关系数据库里每个属性都必须是简单数据类型，就必须把这些复合属性铺平</li>
<li>e.g.给定的实体集instructor,first_name, last_name 与实体集对应的模式具有两个属性 name_first_name 和 name_last_name</li>
<li>如果没有歧义，则省略前缀</li>
<li>忽略多值属性，扩展instructor模式为：instructor(ID, first_name, middle_initial,  last_name, street_number, street_name, apt_number, city, state, zip_code,     date_of_birth, age)<ul>
<li>phone_number属性被省略</li>
</ul>
</li>
</ul>
</li>
<li>实体E的多值属性M由单独的模式EM表示<ul>
<li>模式EM具有对应于E的主键的属性和对应域多值属性M的属性<ul>
<li>e.g.instructor的多值属性phone_number由模式inst_phone表示：inst_phone(<u>ID,phone_number</u>)</li>
</ul>
</li>
<li>多值属性的每个值都映射到模式EM上关系的单独元祖<ul>
<li>e.g.主键为222222，456-7890 和 123-4567 的 instructor 实体映射到两个元组：(22222,456-7890)和(22222,123-4567)</li>
</ul>
</li>
</ul>
</li>
<li>特殊情况：实体time_slot只有一个除主键属性之外的属性，并且该属性是多值的<ul>
<li>time_slot(<u>time_slot_id</u>,{day,start_time,end_time})可以被拆分为<ul>
<li>time_slot(<u>time_slot_id</u>)</li>
<li>time_slot_details(<u>time_slot_id,day,start_time</u>.end_time)</li>
</ul>
</li>
<li>优化：不创建实体对应的关系，time_slot_details(<u>time_slot_id,day,start_time</u>.end_time)</li>
</ul>
</li>
<li>但是因为这个优化使得time_slot属性不能是外键，可能需要用trigger来实现</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-91.png" alt="alt text"></p>
<h2 id="6-Design-Issues"><a href="#6-Design-Issues" class="headerlink" title="6. Design Issues"></a>6. Design Issues</h2><h3 id="6-1-Common-Mistakes-in-E-R-Diagrams"><a href="#6-1-Common-Mistakes-in-E-R-Diagrams" class="headerlink" title="6.1 Common Mistakes in E-R Diagrams"></a>6.1 Common Mistakes in E-R Diagrams</h3><ul>
<li><p>信息冗余<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-92.png" alt="alt text"></p>
<blockquote>
<p>student的dept_name应该去掉</p>
</blockquote>
</li>
<li><p>关系属性使用不当<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-93.png" alt="alt text"></p>
<blockquote>
<p>这是一门课，可能会有很多次作业，不能只用一个实体</p>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-94.png" alt="alt text"></p>
</blockquote>
</li>
</ul>
<h3 id="6-2-Placement-of-Relationship-Attributes"><a href="#6-2-Placement-of-Relationship-Attributes" class="headerlink" title="6.2 Placement of Relationship Attributes"></a>6.2 Placement of Relationship Attributes</h3><p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-95.png" alt="alt text"></p>
<ul>
<li>第一种方法：可以记录每次访问日期</li>
<li>第二种方法：只能记录用户最近一次访问日期，不完整</li>
</ul>
<h3 id="6-3-Binary-VS-Non-Binary-Relationships"><a href="#6-3-Binary-VS-Non-Binary-Relationships" class="headerlink" title="6.3 Binary VS Non-Binary Relationships"></a>6.3 Binary VS Non-Binary Relationships</h3><ul>
<li>尽管可以用多个不同的二元关系集替换任何非二元关系集，但n元关系集可以更清楚地显示多个实体参与单个关系</li>
<li>一些看起来非二元的关系可能更适合使用二元关系来表示<ul>
<li>例如，将孩子与他的父亲和母亲联系起来的三元关系父母最好用两种二元关系来代替</li>
<li>使用两个二元关系允许出现部分信息(例如，只有母亲知道的信息)</li>
</ul>
</li>
<li>但是有些关系天生就是非二元的</li>
</ul>
<h3 id="6-4-Converting-Non-Binary-Relationships-to-Binary-Form"><a href="#6-4-Converting-Non-Binary-Relationships-to-Binary-Form" class="headerlink" title="6.4 Converting Non-Binary Relationships to Binary Form"></a>6.4 Converting Non-Binary Relationships to Binary Form</h3><p>通常，任何非二元关系都可以通过创建人工实体集来使用二元关系来表示</p>
<ul>
<li>将实体集 A、B 和 C 之间的 R 替换为实体集 E 和三个关系集：<br><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-96.png" alt="alt text"></li>
<li>为E创建特殊标识属性</li>
<li>将R的所有属性添加到E</li>
<li>对于每一个R中的关系$(a_i,b_i,c_i)$<ul>
<li>在实体集E这种建立新实体$c_i$</li>
<li>将$(e_i,a_i)$添加到$R_A$;将$(e_i,b_i)$添加到$R_B$;将$(e_i,c_i)$添加到$R_C$</li>
</ul>
</li>
<li>我们还需要转换所有的约束<ul>
<li>可能无法转换所有约束</li>
<li>已翻译的模式中可能不存在不能对应于R的任何实例</li>
<li>我们可以通过使 E 成为由三个关系集标识的弱实体集来避免创建标识属性</li>
</ul>
</li>
</ul>
<h3 id="6-5-E-R-Desogn-Decisions"><a href="#6-5-E-R-Desogn-Decisions" class="headerlink" title="6.5 E-R Desogn Decisions"></a>6.5 E-R Desogn Decisions</h3><ul>
<li>使用属性或实体集来表示对象</li>
<li>实际概念是用实体集还是关系集最好地表达</li>
<li>使用三元关系或二元关系</li>
<li>使用强实体集或弱实体集</li>
</ul>
<h3 id="6-6-Extended-ER-Features"><a href="#6-6-Extended-ER-Features" class="headerlink" title="6.6 Extended ER Features"></a>6.6 Extended ER Features</h3><ul>
<li>特化(Specialization)<ul>
<li>自上而下的设计过程：我们再实体集中指定与几何中的其他实体不同的子分组</li>
<li>属性继承：较低级别的实体集继承其链接到的较高级别实体集的所有属性和关系参与</li>
</ul>
</li>
<li>概化(Generalization)<ul>
<li>自下而上的设计过程：相同特征的多个实体集合并到更高级别的实体集中</li>
</ul>
</li>
<li>特化和概化是彼此的简单倒置，它们在E-R图中以相同的方式表示</li>
<li>术语特化和概化可以互相使用</li>
</ul>
<p><img src="/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-Database-System/image-97.png" alt="alt text"></p>
<ul>
<li>特化和概化的设计约束<ul>
<li>对实体是否可以属于单个概化中的多个较低级别实体集的约束<ul>
<li>不相交(Disjoint)<ul>
<li>一个实体只能属于一个较低级别的实体集</li>
<li>在E-R图中，通过让多个较低级别的实体集链接到同一个三角形来表示</li>
</ul>
</li>
<li>重叠(Overlapping)<ul>
<li>一个实体可以属于多个较低级别的实体集</li>
</ul>
</li>
</ul>
</li>
<li>完全性约束(Completeness Constraint)<ul>
<li>指较高级别实体集中的实体是否必须至少属于概化中的至少一个较低级别实体集<ul>
<li>全部(Total):实体必须属于较低级别的实体集之一</li>
<li>部分(Partial):实体不必属于较低级别的实体集之一</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
</search>
